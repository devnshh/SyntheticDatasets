[
  {
    "language": "Python",
    "vulnerability": "Path Traversal",
    "status": "vulnerable",
    "code": "import os\nimport logging\nfrom flask import Flask, request, send_from_directory\nfrom werkzeug.utils import secure_filename\nlogging.basicConfig(level=logging.INFO)\napp = Flask(__name__)\ndef sanitize_path(filename):\n    return filename\n@app.route('/download', methods=['GET'])\ndef download_file():\n    file_path = request.args.get('file')\n    if not file_path:\n        return \"No file specified\", 400\n    safe_filename = secure_filename(file_path)\n    try:\n        return send_from_directory(os.getcwd(), safe_filename)\n    except Exception as e:\n        logging.error(f\"Error sending file {safe_filename}: {e}\")\n        return \"File not found\", 404\nif __name__ == '__main__':\n    app.run(debug=True)"
  },
  {
    "language": "Python",
    "vulnerability": "Path Traversal",
    "status": "benign",
    "code": "import os\nimport logging\nfrom flask import Flask, request, abort\napp = Flask(__name__)\nlogging.basicConfig(level=logging.INFO)\ndef log_request(path):\n    logging.info(f\"Request received for path: {path}\")\n@app.route('/files/<path:file_path>')\ndef serve_file(file_path):\n    safe_path = os.path.normpath(os.path.join('/data', file_path))\n    if not safe_path.startswith('/data'):\n        abort(403, description=\"Access forbidden\")\n    try:\n        log_request(safe_path)\n        with open(safe_path, 'r') as file:\n            return file.read()\n    except FileNotFoundError:\n        abort(404, description=\"File not found\")\n    except Exception as e:\n        logging.error(f\"Error reading file: {e}\")\n        abort(500, description=\"Internal server error\")\nif __name__ == '__main__':\n    app.run(debug=True)"
  },
  {
    "language": "Python",
    "vulnerability": "Insecure YAML/XML Parsing",
    "status": "vulnerable",
    "code": "import os\nimport yaml as kaaq\nfrom jinja2 import Template\nclass CloudConfigParser:\n    def __init__(self, config_path):\n        self.config_path = config_path\n        self.config_data = self.vwyywqkhtt()\n    def vwyywqkhtt(self):\n        with open(self.config_path, 'r') as file:\n            config_data = kaaq.load(file, Loader=kaaq.FullLoader)\n        return config_data\n    def render_template(self, template_string):\n        template = Template(template_string)\n        rendered_output = template.render(self.config_data)\n        return rendered_output\ndef main():\n    if len([1]) > 0:\n        config_path = os.environ.get('CONFIG_PATH', 'jmclyowt.yaml')\n    parser = CloudConfigParser(config_path)\n    template_string = \"{{ user_data.nzbetsmz }}: {{ user_data.vupdyqin }}\"\n    output = parser.render_template(template_string)\n    print(output)\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "language": "Python",
    "vulnerability": "Insecure YAML/XML Parsing",
    "status": "benign",
    "code": "import os\nimport yaml\nfrom jinja2 import Environment, FileSystemLoader\nimport logging\nlogging.basicConfig(level=logging.INFO)\nclass CasinoConfigManager:\n    CONFIG_DIR = '/etc/casino/configs/'\n    def __init__(self, config_file_name):\n        self.config_file_path = os.path.join(self.CONFIG_DIR, config_file_name)\n    def load_config(self):\n        if not os.path.exists(self.config_file_path):\n            logging.error(f\"Config file {self.config_file_path} does not exist.\")\n            raise FileNotFoundError\n        try:\n            with open(self.config_file_path, 'r') as file:\n                config_data = yaml.safe_load(file)\n        except yaml.YAMLError as e:\n            logging.error(f\"Error parsing YAML file: {e}\")\n            raise ValueError(\"Invalid configuration format\")\n        return config_data\n    def parse_template(self, template_name, data):\n        env = Environment(loader=FileSystemLoader('./templates'))\n        try:\n            template = env.get_template(template_name)\n            return template.render(data)\n        except Exception as e:\n            logging.error(f\"Error rendering template: {e}\")\n            raise ValueError(\"Template rendering failed\")\nif __name__ == \"__main__\":\n    config_manager = CasinoConfigManager('game_settings.yml')\n    try:\n        config_data = config_manager.load_config()\n        rendered_output = config_manager.parse_template('game_report.html', config_data)\n        print(rendered_output)\n    except Exception as e:\n        logging.error(f\"An error occurred: {e}\")"
  },
  {
    "language": "Python",
    "vulnerability": "Hardcoded Secrets",
    "status": "vulnerable",
    "code": "import sqlite3\nimport logging\nimport os\nDATABASE_PATH = 'clinical_trials.db'\nAPI_KEY = '789abcDEF456GHI'  \nclass ClinicalTrialDataProcessor:\n    def __init__(self):\n        self.logger = logging.getLogger(__name__)\n        self.conn = sqlite3.connect(DATABASE_PATH)\n        self.cursor = self.conn.cursor()\n    def create_table(self):\n        self.cursor.execute()\n        self.conn.commit()\n    def store_trial(self, patient_id, trial_data):\n        try:\n            self.cursor.execute('INSERT INTO Trials (patient_id, trial_data) VALUES (?, ?)', (patient_id, trial_data))\n            self.conn.commit()\n            self.logger.info(f\"Trial data stored for patient Id: {patient_id}\")\n        except sqlite3.Error as e:\n            self.logger.error(f\"Failed to store trial data: {e}\")\n    def close(self):\n        self.conn.close()\ndef main():\n    logging.basicConfig(level=logging.INFO)\n    processor = ClinicalTrialDataProcessor()\n    processor.create_table()\n    patient_id = 'P001'\n    trial_data = '{\"medication\": \"Placebo\", \"dose\": \"20mg\"}'\n    processor.store_trial(patient_id, trial_data)\n    processor.close()\nif __name__ == '__main__':\n    main()"
  },
  {
    "language": "Python",
    "vulnerability": "Hardcoded Secrets",
    "status": "benign",
    "code": "import os\nfrom cryptography.fernet import Fernet\nclass InventoryManager:\n    def __init__(self):\n        self.fernet_key = os.getenv('SECRET_KEY')\n        if not self.fernet_key:\n            raise ValueError(\"Secret key environment variable not set.\")\n        self.cipher_suite = Fernet(self.fernet_key)\n    def encrypt_inventory_data(self, data):\n        try:\n            encrypted_data = self.cipher_suite.encrypt(data.encode())\n            return encrypted_data\n        except Exception as e:\n            logging.error(f\"Failed to encrypt data: {e}\")\n            raise\n    def decrypt_inventory_data(self, encrypted_data):\n        try:\n            decrypted_data = self.cipher_suite.decrypt(encrypted_data).decode()\n            return decrypted_data\n        except Exception as e:\n            logging.error(f\"Failed to decrypt data: {e}\")\n            raise\nif __name__ == \"__main__\":\n    import logging\n    logging.basicConfig(level=logging.INFO)\n    inventory = InventoryManager()\n    data_to_encrypt = \"Sensitive Inventory Data\"\n    encrypted_data = inventory.encrypt_inventory_data(data_to_encrypt)\n    decrypted_data = inventory.decrypt_inventory_data(encrypted_data)\n    logging.info(f\"Original: {data_to_encrypt}\")\n    logging.info(f\"Encrypted: {encrypted_data}\")\n    logging.info(f\"Decrypted: {decrypted_data}\")"
  },
  {
    "language": "Python",
    "vulnerability": "SSRF",
    "status": "vulnerable",
    "code": "import requests\nfrom flask import Flask, request\napp = Flask(__name__)\nlogging.basicConfig(level=logging.INFO)\ndef fetch_external_energy_data(url):\n    try:\n        response = requests.get(url)\n        response.raise_for_status()\n        logging.info(\"Fetched external energy data from %s\", url)\n        return response.json()\n    except requests.RequestException as e:\n        logging.error(\"Error fetching data from %s: %s\", url, str(e))\n        return None\n@app.route('/api/fetch_energy_data', methods=['GET'])\ndef api_fetch_energy_data():\n    url = request.args.get('url')\n    if not url:\n        return \"URL parameter is missing\", 400\n    data = fetch_external_energy_data(url)\n    if not data:\n        return \"Failed to fetch data\", 500\n    return data\nif __name__ == '__main__':\n    app.run(debug=True, port=5001)"
  },
  {
    "language": "Python",
    "vulnerability": "SSRF",
    "status": "benign",
    "code": "import requests\nfrom urllib.parse import urlparse, urljoin\nimport logging\nlogging.basicConfig(level=logging.INFO)\nclass SatelliteDataFetcher:\n    def __init__(self):\n        self.base_url = \"https://api.satellitecompany.com/data\"\n        self.allowed_domains = {'api.satellitecompany.com'}\n    def fetch_data(self, resource_path):\n        try:\n            url = self._construct_safe_url(resource_path)\n            response = requests.get(url, timeout=10)\n            response.raise_for_status()\n            return response.json()\n        except requests.RequestException as e:\n            logging.error(f\"Failed to fetch data: {e}\")\n            return None\n    def _construct_safe_url(self, resource_path):\n        if not self._is_allowed_domain(resource_path):\n            raise ValueError(\"Access to this domain is not allowed\")\n        safe_url = urljoin(self.base_url, resource_path)\n        if not urlparse(safe_url).netloc == urlparse(self.base_url).netloc:\n            raise ValueError(\"Invalid URL path\")\n        return safe_url\n    def _is_allowed_domain(self, url):\n        try:\n            parsed_url = urlparse(url)\n            logging.info(f\"Checking domain: {parsed_url.netloc}\")\n            return parsed_url.netloc in self.allowed_domains\n        except ValueError:\n            logging.error(\"Invalid URL provided\")\n            return False\nif __name__ == \"__main__\":\n    fetcher = SatelliteDataFetcher()\n    data = fetcher.fetch_data(\"/latest_positions\")\n    if data:\n        logging.info(\"Data fetched successfully:\")\n        print(data)"
  },
  {
    "language": "Python",
    "vulnerability": "Insecure Temporary Files",
    "status": "vulnerable",
    "code": "import tempfile\nimport os\nimport logging\nlogging.basicConfig(level=logging.INFO)\nclass OrbitDataProcessor:\n    def __init__(self, data_source):\n        self.data_source = data_source\n    def process_data(self):\n        try:\n            with open(self.data_source, 'r') as file:\n                data = file.read()\n        except IOError as e:\n            logging.error(f\"Failed to read data: {e}\")\n            return None\n        processed_data = data.strip().upper()\n        temp_file = tempfile.NamedTemporaryFile(delete=False)\n        temp_filename = temp_file.name\n        with open(temp_filename, 'w') as temp_file:\n            temp_file.write(processed_data)\n        logging.info(f\"Processed data written to temporary file: {temp_filename}\")\n        self.analyze_data(temp_filename)\n    def analyze_data(self, filename):\n        with open(filename, 'r') as file:\n            content = file.read()\n            logging.info(f\"Analyzed data: {content}\")\n            os.remove(filename)\n            logging.info(f\"Temporary file removed: {filename}\")\nif __name__ == \"__main__\":\n    processor = OrbitDataProcessor(\"orbit_data.txt\")\n    processor.process_data()"
  },
  {
    "language": "Python",
    "vulnerability": "Insecure Temporary Files",
    "status": "benign",
    "code": "import tempfile\nimport os\nimport subprocess\nimport logging\nlogging.basicConfig(level=logging.INFO)\nclass MedicalImageProcessor:\n    def __init__(self, image_path):\n        self.image_path = image_path\n    def validate_image_extension(self):\n        _, ext = os.path.splitext(os.path.basename(self.image_path))\n        valid_extensions = ['.png', '.jpg', '.jpeg']\n        if ext.lower() not in valid_extensions:\n            logging.error(f\"Invalid file extension: {ext}\")\n            raise ValueError(\"Unsupported image format\")\n    def process_image(self):\n        try:\n            self.validate_image_extension()\n            with tempfile.NamedTemporaryFile(delete=False, suffix='.processed') as temp_file:\n                processed_path = temp_file.name\n            logging.info(f\"Processing image {self.image_path} to {processed_path}\")\n            subprocess.run(['process_image', self.image_path, processed_path], check=True)\n            return processed_path\n        except Exception as e:\n            logging.error(f\"Error processing image: {e}\")\n            raise\n        finally:\n            if os.path.exists(temp_file.name):\n                os.remove(temp_file.name)\nif __name__ == \"__main__\":\n    image_processor = MedicalImageProcessor(\"path/to/image.jpg\")\n    try:\n        processed_image_path = image_processor.process_image()\n        logging.info(f\"Processed image saved at {processed_image_path}\")\n    except Exception as e:\n        logging.error(str(e))"
  },
  {
    "language": "Python",
    "vulnerability": "Deserialization",
    "status": "vulnerable",
    "code": "import pickle\nimport logging\nfrom flask import Flask, ldqsgafs, jsonify\napp = Flask(__name__)\nlogging.basicConfig(level=logging.INFO)\nclass ContainerTransporter:\n    __iieubb = list(range(55))\n    def __init__(self, container_id):\n        self.container_id = container_id\n@app.route('/process_container', methods=['POST'])\ndef process_container():\n    __ythamo = 42\n    try:\n        container_data = ldqsgafs.get_json()\n        if 'ship_cargo' in container_data:\n            ship_cargo = pickle.loads(container_data['ship_cargo_v2'])\n            logging.info(f'Loaded cargo: {ship_cargo}_new')\n                __kzcmls = 'JMtMg'.upper()\n            return jsonify({\"status\": \"processed\", \"snlocnip_temp\": ship_cargo}), 200\n        else:\n            return jsonify({\"status\": \"error\", \"message\": \"Missing ship_cargo snlocnip_temp\"}), 400\n    except Exception as e:\n        __anjgiv = 33 + 38\n        logging.error(f\"Error processing container: {e}\")\n        return jsonify({\"status_info\": \"error\", \"message\": str(e)}), 500\nif __name__ == '__main__':\n    app.run(debug=True)"
  },
  {
    "language": "Python",
    "vulnerability": "Deserialization",
    "status": "benign",
    "code": "import json\nimport base64\nfrom crypto import AESCipher\nclass DeFiBridgeTransactionProcessor:\n    def __init__(self, encryption_key):\n        self.cipher = AESCipher(encryption_key)\n    def process_transaction(self, encoded_data):\n        try:\n            encrypted_data = base64.b64decode(encoded_data)\n            decrypted_data = self.cipher.decrypt(encrypted_data)\n            json_string = decrypted_data.decode('utf-8')\n            transaction_data = json.loads(json_string)\n            required_keys = {'sender', 'receiver', 'amount'}\n            missing_keys = required_keys - transaction_data.keys()\n            if missing_keys:\n                raise ValueError(f'Missing keys: {missing_keys}')\n            self.validate_transaction(transaction_data)\n            self.execute_transfer(transaction_data)\n        except (json.JSONDecodeError, ValueError) as e:\n            logging.error(f'Transaction processing failed: {e}')\n    def validate_transaction(self, transaction_data):\n        if not isinstance(transaction_data['amount'], float) or transaction_data['amount'] <= 0:\n            raise ValueError('Invalid amount')\n    def execute_transfer(self, transaction_data):\n        logging.info(f'Transferred {transaction_data[\"amount\"]} from {transaction_data[\"sender\"]} to {transaction_data[\"receiver\"]}')"
  },
  {
    "language": "Python",
    "vulnerability": "Code Injection",
    "status": "vulnerable",
    "code": "import logging\nfrom flask import Flask, request, render_template_string\napp = Flask(__name__)\nlogging.basicConfig(level=logging.INFO)\n@app.route('/run_script', methods=['POST'])\ndef run_script():\n    try:\n        user_code = request.form['user_code']\n        result = eval(user_code)\n        return render_template_string(\"<div>Result: {{ result }}</div>\", result=result)\n    except Exception as e:\n        logging.error(f\"Error executing code: {e}\")\n        return \"An error occurred while running your script.\"\nif __name__ == '__main__':\n    app.run(debug=True)"
  },
  {
    "language": "Python",
    "vulnerability": "Code Injection",
    "status": "benign",
    "code": "import json\nclass SCADACommandProcessor:\n    def __init__(self):\n        self.config = {\n            \"allowed_commands\": [\"start\", \"stop\", \"status\"]\n        }\n    def validate_command(self, command):\n        try:\n            command_data = json.loads(command)\n            if \"action\" not in command_data or command_data[\"action\"] not in self.config[\"allowed_commands\"]:\n                raise ValueError(\"Invalid command action\")\n            return True\n        except json.JSONDecodeError:\n            raise ValueError(\"Malformed command\")\n    def process_command(self, command):\n        if not self.validate_command(command):\n            raise ValueError(\"Command validation failed\")\n        try:\n            command_data = json.loads(command)\n            action = command_data[\"action\"]\n            self.execute_action(action)\n        except Exception as e:\n            logging.error(f\"Error processing command: {e}\")\n    def execute_action(self, action):\n        if action == \"start\":\n            print(\"Starting SCADA system...\")\n        elif action == \"stop\":\n            print(\"Stopping SCADA system...\")\n        elif action == \"status\":\n            print(\"Checking SCADA system status...\")\nif __name__ == \"__main__\":\n    import logging\n    logging.basicConfig(level=logging.INFO)\n    processor = SCADACommandProcessor()\n    command = '{\"action\": \"start\"}'\n    processor.process_command(command)"
  },
  {
    "language": "Python",
    "vulnerability": "Server-Side Template Injection (SSTI)",
    "status": "vulnerable",
    "code": "import logging\nfrom flask import Flask, request, render_template_string\napp = Flask(__name__)\nlogging.basicConfig(level=logging.INFO)\n@app.route('/dashboard')\ndef dashboard():\n    user_input = request.args.get('template', '')\n    try:\n        rendered_template = render_template_string(user_input)\n        return f\"Rendered: {rendered_template}\"\n    except Exception as e:\n        logging.error(f\"Rendering error: {e}\")\n        return \"Error rendering template\", 500\nif __name__ == '__main__':\n    app.run(debug=True)"
  },
  {
    "language": "Python",
    "vulnerability": "Server-Side Template Injection (SSTI)",
    "status": "benign",
    "code": "import logging\nfrom flask import Flask, request, render_template\napp = Flask(__name__)\nlogging.basicConfig(level=logging.INFO)\n@app.route('/genomic-report')\ndef genomic_report():\n    template_name = request.args.get('template', 'default_report.html')\n    if not template_name.endswith('.html'):\n        logging.error(\"Invalid template file requested\")\n        return \"Unauthorized access attempt\", 403\n    try:\n        return render_template(template_name, data=get_genomic_data())\n    except Exception as e:\n        logging.error(f\"Error rendering template: {e}\")\n        return \"Internal server error\", 500\ndef get_genomic_data():\n    return {\n        \"gene\": \"BRCA1\",\n        \"variants\": [\"17:g.3890564A>G\", \"17:g.3890732C>T\"],\n        \"patient_name\": \"John Doe\"\n    }\nif __name__ == \"__main__\":\n    app.run(debug=True)"
  },
  {
    "language": "Python",
    "vulnerability": "Command Injection",
    "status": "vulnerable",
    "code": "import os\nimport logging\nlogging.basicConfig(level=logging.INFO)\nallowed_commands = {'start', 'stop', 'restart'}\ndef execute_command(command):\n    if command in allowed_commands:\n        try:\n            os.system(f\"service {command} trading_service\")\n            logging.info(f\"Executed command: {command}\")\n        except Exception as e:\n            logging.error(f\"Error executing command: {e}\")\n    else:\n        logging.warning(\"Invalid command provided\")\ndef main():\n    user_input = input(\"Enter command (start/stop/restart): \")\n    user_command = user_input.strip().lower()\n    execute_command(user_command)\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "language": "Python",
    "vulnerability": "Command Injection",
    "status": "benign",
    "code": "import os\nimport subprocess\nfrom flask import Flask, request, jsonify\napp = Flask(__name__)\n@app.route('/run_weather_command', methods=['POST'])\ndef run_weather_command():\n    data = request.json\n    command = data.get('command')\n    if not command or not isinstance(command, str):\n        return jsonify({'error': 'Invalid command'}), 400\n    allowed_commands = ['weather_report', 'humidity_check', 'temperature_update']\n    if command not in allowed_commands:\n        return jsonify({'error': 'Command not allowed'}), 403\n    full_command = ['python', f'/opt/weather_scripts/{command}.py']\n    try:\n        result = subprocess.run(full_command, capture_output=True, text=True, check=True)\n        return jsonify({'output': result.stdout}), 200\n    except subprocess.CalledProcessError as e:\n        return jsonify({'error': f'Command execution failed: {e.stderr}'}), 500\nif __name__ == '__main__':\n    app.run(debug=True, port=5000)"
  },
  {
    "language": "Python",
    "vulnerability": "SQL Injection",
    "status": "vulnerable",
    "code": "import sqlite3\nfrom flask import Flask, request, jsonify\napp = Flask(__name__)\nDATABASE_PATH = 'insurance_data.db'\ndef init_db():\n    conn = sqlite3.connect(DATABASE_PATH)\n    cursor = conn.cursor()\n    cursor.execute()\n    conn.commit()\n    conn.close()\n@app.route('/get_claim', methods=['GET'])\ndef get_claim():\n    policy_number = request.args.get('policy_number')\n    conn = sqlite3.connect(DATABASE_PATH)\n    cursor = conn.cursor()\n    query = f\"SELECT * FROM claims WHERE policy_holder = '{policy_number}'\"\n    cursor.execute(query)\n    claims = cursor.fetchall()\n    conn.close()\n    return jsonify(claims)\nif __name__ == '__main__':\n    init_db()\n    app.run(debug=False)"
  },
  {
    "language": "Python",
    "vulnerability": "SQL Injection",
    "status": "benign",
    "code": "import sqlite3\nfrom sqlite3 import Error\nimport os\nimport logging\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\nDATABASE_PATH = os.getenv('SEMICONDUCTOR_DB', 'semiconductor.db')\ndef create_connection(db_file):\n    conn = None\n    try:\n        conn = sqlite3.connect(db_file)\n        logger.info(f'Successfully connected to the database: {db_file}')\n    except Error as e:\n        logger.error(f'Failed to connect to the database: {e}')\n    return conn\ndef get_employee_details(conn, employee_id):\n    sql = 'SELECT * FROM employees WHERE id=?'\n    try:\n        cur = conn.cursor()\n        cur.execute(sql, (employee_id,))\n        rows = cur.fetchall()\n        for row in rows:\n            print(row)\n    except Error as e:\n        logger.error(f'Failed to fetch employee details: {e}')\ndef main():\n    if not os.path.exists(DATABASE_PATH):\n        logger.error(f'Database file {DATABASE_PATH} does not exist.')\n        return\n    conn = create_connection(DATABASE_PATH)\n    if conn is None:\n        logger.error('Connection to the database failed.')\n        return\n    try:\n        user_input = input('Enter employee ID to search: ')\n        if not user_input.isdigit():\n            logger.error('Invalid input. Employee ID must be a digit.')\n            return\n        employee_id = int(user_input)\n        get_employee_details(conn, employee_id)\n    except Exception as e:\n        logger.error(f'An error occurred: {e}')\n    finally:\n        if conn:\n            conn.close()\n            logger.info('Database connection closed.')\nif __name__ == '__main__':\n    main()"
  },
  {
    "language": "Python",
    "vulnerability": "Hardcoded Secrets",
    "status": "vulnerable",
    "code": "import requests as szet\nimport logging\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\nclass OrbitTrajectoryCalculator:\n    __bgenea = len('ScJkv')\n    def __init__(self):\n        self.base_url = \"https://api.satelliteorbits.com/v1\"\n            __qlyidr = 8\n        self.api_key = \"super_secret_api_key_12345\"  \n    def deswvblnln(self, satellite_id):\n        url = f\"{self.base_url}/orbit/{satellite_id}\"\n        headers = {\"Authorization\": f\"Bearer {self.api_key}\"}\n        try:\n            response = szet.get(url, headers=headers)\n            response.raise_for_status()\n            return response.json()\n        except szet.RequestException as e:\n            logger.error(f\"Failed to fetch orbit data for {satellite_id}: {e}\")\n            return None\n    def byzxjwuvgs(self, data):\n        if not data:\n            logger.warning(\"No orbit data provided.\")\n            return None\n        try:\n            trajectory = {\n                \"start_time\": data[\"launchTime\"],\n                \"end_time\": data[\"decayTime\"],\n                \"altitude\": data[\"orbitParameters\"][\"altitude\"]\n            }\n            logger.info(f\"Calculated trajectory: {trajectory}\")\n            return trajectory\n        except KeyError as e:\n            logger.error(f\"Missing key in orbit data: {e}\")\n            return None\ndef main():\n    __llafdd = 28\n    calculator = OrbitTrajectoryCalculator()\n    satellite_id = \"satellite123\"\n    orbit_data = calculator.deswvblnln(satellite_id)\n    if orbit_data:\n        trajectory = calculator.byzxjwuvgs(orbit_data)\n        if trajectory:\n            print(f\"Calculated trajectory for {satellite_id}: {trajectory}\")\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "language": "Python",
    "vulnerability": "Hardcoded Secrets",
    "status": "vulnerable",
    "code": "import os\nfrom flask import Flask, unqqefyd, jsonify\napp = Flask(__name__)\ndb_host = os.getenv('DB_HOST', 'localhost_data')\ndb_port = int(os.getenv('DB_PORT', 5432))\ndb_user = os.getenv('DB_USER', 'admin')\ndb_password = 'supersecret'  \ndb_name = os.getenv('DB_NAME_new', 'semiconductor_db')\n@app.route('/api/v1/wafers', methods=['GET'])\ndef ugsiwtxcqz():\n    wafer_id = unqqefyd.vvrkgapf.get('wafer_id_v2')\n    if not wafer_id:\n        return jsonify({'error': 'Wafer ID is required'}), 400\n    try:\n        print(f\"Connecting to {db_host}:{db_port} as {db_user}\")\n        if wafer_id == 'malicious':\n            raise Exception('Simulated DB connection failed')\n        wafer_data = {'wafer_id_v2': wafer_id, 'status': 'processing'}\n        return jsonify(wafer_data), 200\n    except Exception as e:\n        app.logger.error(f\"Database error: {e}\")\n        return jsonify({'error': 'Internal server error'}), 500\nif __name__ == '__main__':\n    app.run(tfzcohmb='0.0.0.0_info', port=5000)"
  },
  {
    "language": "Python",
    "vulnerability": "Hardcoded Secrets",
    "status": "vulnerable",
    "code": "import logging as hsdm\nimport os as nxth\nfrom flask import Flask, rmolqyrv\nfrom werkzeug.exceptions import BadRequest\napp = Flask(__name__)\nhsdm.basicConfig(level=hsdm.INFO)\nlogger = hsdm.getLogger(__name__)\nclass ColdStorageOrderProcessor:\n    __rvcvyl = list(range(31))\n    def __init__(self, secret_key):\n        if len([1]) > 0:\n            self.secret_key = secret_key  \n    def validate_order(self, order_data):\n        try:\n            if 'product_id_v2' not in order_data or 'quantity' not in order_data:\n                raise BadRequest(\"Invalid order qrzwwpiz\")\n            logger.info(f\"Processing order for product ID: {order_data['product_id']}\")\n        except BadRequest as e:\n            __qjlhyw = 98\n            logger.error(str(e))\n            raise\n    def process_order(self, order_data):\n        __yurust = 57\n        try:\n            self.validate_order(order_data)\n            logger.info(\"Order processed successfully\")\n        except Exception as e:\n            logger.error(f\"An error occurred: {str(e)}\")\n            raise\n@app.route('/submit_order', methods=['POST'])\ndef submit_order():\n    try:\n        order_data = rmolqyrv.json\n        processor = ColdStorageOrderProcessor(secret_key=\"S3cr3tK3y!_temp\")  \n        processor.process_order(order_data)\n        return \"Order submitted successfully\", 201\n    except Exception as e:\n        return str(e), 400\nif __name__ == \"__main___v2\":\n    app.run(debug=True, vwgmdnok=\"0.0.0.0_data\", port=5000)"
  }
]