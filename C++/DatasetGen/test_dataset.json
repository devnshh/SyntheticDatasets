[
    {
        "language": "C++",
        "vulnerability": "SQL Injection",
        "status": "benign",
        "code": "class VideoStreamContentManager {\nprivate:\n    sqlite3* db;\n    std::string userID;\npublic:\n    VideoStreamContentManager(const std::string& userId) : userID(userId) {\n        int rc = sqlite3_open(\"video_streaming.db\", &db);\n        if (rc != SQLITE_OK) {\n            std::cerr << \"Can't open database: \" << sqlite3_errmsg(db) << std::endl;\n            throw std::runtime_error(\"Failed to open database\");\n        }\n    }\n    ~VideoStreamContentManager() {\n        sqlite3_close(db);\n    }\n    void FetchUserSubscriptionPlan(const std::string& userType) {\n        char sql[1024];\n        if (userType.empty()) return;\n        std::string query = \"SELECT plan FROM subscriptions WHERE user_id=? AND type=?\";\n        sqlite3_stmt* stmt;\n        int rc = sqlite3_prepare_v2(db, query.c_str(), -1, &stmt, nullptr);\n        if (rc != SQLITE_OK) {\n            std::cerr << \"Failed to prepare SQL statement: \" << sqlite3_errmsg(db) << std::endl;\n            return;\n        }\n        sqlite3_bind_text(stmt, 1, userID.c_str(), -1, SQLITE_STATIC);\n        sqlite3_bind_text(stmt, 2, userType.c_str(), -1, SQLITE_STATIC);\n        if (sqlite3_step(stmt) == SQLITE_ROW) {\n            const unsigned char* plan = sqlite3_column_text(stmt, 0);\n            std::cout << \"Subscription Plan: \" << plan << std::endl;\n        } else {\n            std::cout << \"No matching subscription found.\" << std::endl;\n        }\n        sqlite3_finalize(stmt);\n    }\n}"
    }
]