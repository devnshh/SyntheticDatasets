{
    "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
    "input": "{\n\tstruct sctp_association *asoc = sctp_id2assoc(sk, id);\n\tstruct sctp_sock *sp = sctp_sk(sk);\n \tstruct socket *sock;\n \tint err = 0;\n \n \tif (!asoc)\n \t\treturn -EINVAL;\n \n\t/* If there is a thread waiting on more sndbuf space for\n\t * sending on this asoc, it cannot be peeled.\n\t */\n\tif (waitqueue_active(&asoc->wait))\n\t\treturn -EBUSY;\n\n\t/* An association cannot be branched off from an already peeled-off\n\t * socket, nor is this supported for tcp style sockets.\n\t */\n\tif (!sctp_style(sk, UDP))\n\t\treturn -EINVAL;\n\n\t/* Create a new socket.  */\n\terr = sock_create(sk->sk_family, SOCK_SEQPACKET, IPPROTO_SCTP, &sock);\n\tif (err < 0)\n\t\treturn err;\n\n\tsctp_copy_sock(sock->sk, sk, asoc);\n\n\t/* Make peeled-off sockets more like 1-1 accepted sockets.\n\t * Set the daddr and initialize id to something more random\n\t */\n\tsp->pf->to_sk_daddr(&asoc->peer.primary_addr, sk);\n\n\t/* Populate the fields of the newsk from the oldsk and migrate the\n\t * asoc to the newsk.\n\t */\n\tsctp_sock_migrate(sk, sock->sk, asoc, SCTP_SOCKET_UDP_HIGH_BANDWIDTH);\n\n\t*sockp = sock;\n\n\treturn err;\n}\n",
    "output": "```json\n{\n  \"queries\": ['val sources = cpg.call.name(\"sctp_id2assoc|sock_create\").argument.l', 'val sinks = cpg.call.name(\"sctp_copy_sock|sctp_sock_migrate\").argument.l', 'val potentialFreeCalls = cpg.call.name(\"free\").argument.l', 'val sanitizedPaths = sinks.reachableByFlows(potentialFreeCalls).l', 'val vulnerablePaths = sinks.reachableByFlows(sources).filterNot(path => sanitizedPaths.contains(path)).l']\n}```"
},
{
    "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
    "input": "/* Romeo and Juliet's Mailing List Manager */\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n/* Function signatures */\nvoid addEmail(char * email, char ** mailingList, int * listSizePtr);\nvoid removeEmail(char * email, char ** mailingList, int * listSizePtr);\nvoid printMailingList(char ** mailingList, int listSize);\n\n/* Main function */\nint main()\n{\n    int listSize = 0;\n    char ** mailingList = malloc(listSize * sizeof(char*));\n\n    printf(\"\\n\\n********************************************\\n\");\n    printf(\"* Welcome to Romeo and Juliet's Mailing List *\\n\");\n    printf(\"********************************************\\n\\n\");\n\n    while (1)\n    {\n        printf(\"What would you like to do?\\n\");\n        printf(\"1. Add an email address\\n\");\n        printf(\"2. Remove an email address\\n\");\n        printf(\"3. Print the mailing list\\n\");\n        printf(\"4. Exit\\n\");\n\n        int choice;\n        scanf(\"%d\", &choice);\n\n        switch (choice)\n        {\n            case 1:\n                printf(\"Please enter the email address you want to add: \");\n                char emailToAdd[100];\n                scanf(\"%s\", emailToAdd);\n                addEmail(emailToAdd, mailingList, &listSize);\n                printf(\"Thank you! The email address has been added.\\n\");\n                break;\n\n            case 2:\n                printf(\"Please enter the email address you want to remove: \");\n                char emailToRemove[100];\n                scanf(\"%s\", emailToRemove);\n                removeEmail(emailToRemove, mailingList, &listSize);\n                printf(\"Thank you! The email address has been removed.\\n\");\n                break;\n\n            case 3:\n                printf(\"\\n--- Mailing List ---\\n\");\n                printMailingList(mailingList, listSize);\n                break;\n\n            case 4:\n                printf(\"Thank you for using Romeo and Juliet's Mailing List. Goodbye!\\n\\n\");\n                free(mailingList);\n                exit(0);\n\n            default:\n                printf(\"Invalid choice. Please try again.\\n\");\n                break;\n        }\n    }\n\n    return 0;\n}\n\n/* Function to add an email address to the mailing list */\nvoid addEmail(char * email, char ** mailingList, int * listSizePtr)\n{\n    (*listSizePtr)++;\n    mailingList = realloc(mailingList, (*listSizePtr) * sizeof(char*));\n    mailingList[(*listSizePtr) - 1] = malloc(strlen(email) + 1);\n    strcpy(mailingList[(*listSizePtr) - 1], email);\n}\n\n/* Function to remove an email address from the mailing list */\nvoid removeEmail(char * email, char ** mailingList, int * listSizePtr)\n{\n    int indexToRemove = -1;\n\n    for (int i = 0; i < (*listSizePtr); i++)\n    {\n        if (strcmp(mailingList[i], email) == 0)\n        {\n            indexToRemove = i;\n            break;\n        }\n    }\n\n    if (indexToRemove != -1)\n    {\n        free(mailingList[indexToRemove]);\n\n        for (int i = indexToRemove; i < (*listSizePtr) - 1; i++)\n        {\n            mailingList[i] = mailingList[i+1];\n        }\n\n        (*listSizePtr)--;\n        mailingList = realloc(mailingList, (*listSizePtr) * sizeof(char*));\n    }\n    else\n    {\n        printf(\"The email address you entered was not found in the mailing list.\\n\");\n    }\n}\n\n/* Function to print the mailing list */\nvoid printMailingList(char ** mailingList, int listSize)\n{\n    for (int i = 0; i < listSize; i++)\n    {\n        printf(\"%d. %s\\n\", i+1, mailingList[i]);\n    }\n}",
    "output": "```json\n{\n  \"queries\": ['val inputSources = cpg.call.name(\"scanf\").argument.isIdentifier.l', 'val strcpySinks = cpg.call.name(\"strcpy\").l', 'strcpySinks.reachableByFlows(inputSources)']\n}```"
},
{
    "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
    "input": "{\n\tstruct qrtr_node *node = ep->node;\n\tconst struct qrtr_hdr_v1 *v1;\n\tconst struct qrtr_hdr_v2 *v2;\n\tstruct qrtr_sock *ipc;\n\tstruct sk_buff *skb;\n\tstruct qrtr_cb *cb;\n\tsize_t size;\n\tunsigned int ver;\n\tsize_t hdrlen;\n\n\tif (len == 0 || len & 3)\n\t\treturn -EINVAL;\n\n\tskb = __netdev_alloc_skb(NULL, len, GFP_ATOMIC | __GFP_NOWARN);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tcb = (struct qrtr_cb *)skb->cb;\n\n\t/* Version field in v1 is little endian, so this works for both cases */\n\tver = *(u8*)data;\n\n\tswitch (ver) {\n\tcase QRTR_PROTO_VER_1:\n\t\tif (len < sizeof(*v1))\n\t\t\tgoto err;\n\t\tv1 = data;\n\t\thdrlen = sizeof(*v1);\n\n\t\tcb->type = le32_to_cpu(v1->type);\n\t\tcb->src_node = le32_to_cpu(v1->src_node_id);\n\t\tcb->src_port = le32_to_cpu(v1->src_port_id);\n\t\tcb->confirm_rx = !!v1->confirm_rx;\n\t\tcb->dst_node = le32_to_cpu(v1->dst_node_id);\n\t\tcb->dst_port = le32_to_cpu(v1->dst_port_id);\n\n\t\tsize = le32_to_cpu(v1->size);\n\t\tbreak;\n\tcase QRTR_PROTO_VER_2:\n\t\tif (len < sizeof(*v2))\n\t\t\tgoto err;\n\t\tv2 = data;\n\t\thdrlen = sizeof(*v2) + v2->optlen;\n\n\t\tcb->type = v2->type;\n\t\tcb->confirm_rx = !!(v2->flags & QRTR_FLAGS_CONFIRM_RX);\n\t\tcb->src_node = le16_to_cpu(v2->src_node_id);\n\t\tcb->src_port = le16_to_cpu(v2->src_port_id);\n\t\tcb->dst_node = le16_to_cpu(v2->dst_node_id);\n\t\tcb->dst_port = le16_to_cpu(v2->dst_port_id);\n\n\t\tif (cb->src_port == (u16)QRTR_PORT_CTRL)\n\t\t\tcb->src_port = QRTR_PORT_CTRL;\n\t\tif (cb->dst_port == (u16)QRTR_PORT_CTRL)\n\t\t\tcb->dst_port = QRTR_PORT_CTRL;\n\n\t\tsize = le32_to_cpu(v2->size);\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"qrtr: Invalid version %d\\n\", ver);\n\t\tgoto err;\n\t}\n\n\tif (len != ALIGN(size, 4) + hdrlen)\n\t\tgoto err;\n\n\tif (cb->dst_port != QRTR_PORT_CTRL && cb->type != QRTR_TYPE_DATA &&\n\t    cb->type != QRTR_TYPE_RESUME_TX)\n\t\tgoto err;\n\n\tskb_put_data(skb, data + hdrlen, size);\n\n\tqrtr_node_assign(node, cb->src_node);\n\n\tif (cb->type == QRTR_TYPE_NEW_SERVER) {\n\t\t/* Remote node endpoint can bridge other distant nodes */\n\t\tconst struct qrtr_ctrl_pkt *pkt = data + hdrlen;\n\n\t\tqrtr_node_assign(node, le32_to_cpu(pkt->server.node));\n\t}\n\n\tif (cb->type == QRTR_TYPE_RESUME_TX) {\n\t\tqrtr_tx_resume(node, skb);\n\t} else {\n\t\tipc = qrtr_port_lookup(cb->dst_port);\n\t\tif (!ipc)\n\t\t\tgoto err;\n\n\t\tif (sock_queue_rcv_skb(&ipc->sk, skb)) {\n\t\t\tqrtr_port_put(ipc);\n\t\t\tgoto err;\n\t\t}\n\n\t\tqrtr_port_put(ipc);\n\t}\n\n\treturn 0;\n\nerr:\n\tkfree_skb(skb);\n\treturn -EINVAL;\n\n}",
    "output": "```json\n{\n  \"queries\": ['val dataSources = cpg.method.name(\"qrtr_endpoint_post\").parameter.filter(_.name == \"data\").toList', 'val lenSources = cpg.method.name(\"qrtr_endpoint_post\").parameter.filter(_.name == \"len\").toList', 'def getSources = dataSources ++ lenSources', 'def getSinks = cpg.method.name(\"qrtr_endpoint_post\").call.name(\"skb_put_data\").argument.order(2).l', 'getSinks.reachableByFlows(getSources)']\n}```"
},
{
    "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
    "input": "#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <unistd.h>\n\n#define MAX_VERTS 10\n\ntypedef struct Node {\n  int data;\n  struct Node* next;\n} Node;\n\ntypedef struct Graph {\n  Node** graph;\n  int numVertices;\n} Graph;\n\nGraph* createGraph() {\n  Graph* graph = malloc(sizeof(Graph));\n  graph->numVertices = 0;\n  graph->graph = NULL;\n  return graph;\n}\n\nvoid insertVertex(Graph* graph, int data) {\n  graph->numVertices++;\n  graph->graph = realloc(graph->graph, graph->numVertices * sizeof(Node*));\n  graph->graph[graph->numVertices - 1] = malloc(sizeof(Node));\n  graph->graph[graph->numVertices - 1]->data = data;\n  graph->graph[graph->numVertices - 1]->next = NULL;\n}\n\nvoid traverseGraph(Graph* graph) {\n  for (int i = 0; i < graph->numVertices; i++) {\n    Node* current = graph->graph[i];\n    while (current) {\n      printf(\"%d \", current->data);\n      current = current->next;\n    }\n    printf(\"\\n\");\n  }\n}\n\nint main() {\n  Graph* graph = createGraph();\n  insertVertex(graph, 1);\n  insertVertex(graph, 2);\n  insertVertex(graph, 3);\n  insertVertex(graph, 4);\n  insertVertex(graph, 5);\n\n  traverseGraph(graph);\n\n  return 0;\n}",
    "output": "```json\n{\n  \"queries\": ['val insertVertexCalls = cpg.call.name(\"insertVertex\").argument.isIdentifier.l', 'val reallocSinks = cpg.call.name(\"realloc\").argument.order(1).code(\"graph->graph\").l', 'reallocSinks.reachableByFlows(insertVertexCalls)']\n}```"
}