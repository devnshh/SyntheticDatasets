[
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class PolicyLogAnalyzer {\n    private static final Logger LOG = Logger.getLogger(PolicyLogAnalyzer.class.getName());\n    private static final String VALID_LOG_MESSAGE = \"Policy {0} has been analyzed with result: {1}\";\n    public void analyzePolicy(String policyId, String result) {\n        if (policyId == null || !policyId.matches(\"\\\\d+\") || result == null) {\n            throw new IllegalArgumentException(\"Invalid input data\");\n        }\n        LOG.info(MessageFormat.format(VALID_LOG_MESSAGE, policyId, result));\n    }\n    public void processXmlData(String xmlInput) {\n        try {\n            DocumentBuilderFactory dbFactory = DocumentBuilderFactory.newInstance();\n            dbFactory.setFeature(\"http:\n            dbFactory.setFeature(\"http:\n            dbFactory.setFeature(\"http:\n            dbFactory.setFeature(\"http:\n            dbFactory.setXIncludeAware(false);\n            dbFactory.setExpandEntityReferences(false);\n            dbFactory.newDocumentBuilder().parse(xmlInput);\n        } catch (Exception e) {\n            LOG.severe(\"Error processing XML data: \" + e.getMessage());\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"info|debug|warn|error|severe\").argument.reachableByFlows(cpg.call.name(\"getParameter\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class SignalControlPanel {\n    Scanner scanner = new Scanner(System.in);\n    public void executeCommand() {\n        System.out.println(\"Enter the signal control command:\");\n        String userInput = scanner.nextLine();\n        try {\n            ProcessBuilder processBuilder = new ProcessBuilder(\"bash\", \"-c\", userInput);\n            processBuilder.start().waitFor();\n        } catch (IOException | InterruptedException e) {\n            System.err.println(\"Error executing command: \" + e.getMessage());\n        }\n    }\n    public static void main(String[] args) {\n        SignalControlPanel panel = new SignalControlPanel();\n        panel.executeCommand();\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['val sources = cpg.call.name(\"nextLine\").argument', 'val sinks = cpg.call.name(\"start\").argument', 'sinks.reachableByFlows(sources)']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class InventoryScanner {\n    private static final Logger logger = LogManager.getLogger(InventoryScanner.class);\n    public void scan_inventory(@NotNull String barcode) {\n        Path basePath = Paths.get(\"/data/inventory_scans\");\n        Path targetPath;\n        try {\n            targetPath = basePath.resolve(Paths.get(barcode)).normalize();\n            if (!targetPath.startsWith(basePath)) {\n                throw new IllegalArgumentException(\"Invalid barcode input\");\n            }\n            ProcessBuilder processBuilder = new ProcessBuilder(\"barcode_scanner\", \"--scan\", targetPath.toString());\n            processBuilder.redirectErrorStream(true);\n            Process process = processBuilder.start();\n            int exitCode = process.waitFor();\n            if (exitCode != 0) {\n                throw new IOException(\"Barcode scanning failed\");\n            }\n        } catch (IOException | InterruptedException e) {\n            logger.error(\"Error during inventory scan\", e);\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"start\").reachableByFlows(cpg.call.name(\"nextLine\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class InventoryManager {\n    private static final String INVENTORY_DIR = \"/var/military/logistics/inventory\";\n    public void updateInventoryQuantity(String itemId, int newQuantity) throws IOException {\n        File inventoryFile = new File(INVENTORY_DIR + \"/\" + itemId);\n        if (inventoryFile.exists() && inventoryFile.canWrite()) {\n            Thread.sleep(1000); \n            inventoryFile.createNewFile(); \n        }\n    }\n    public static void main(String[] args) {\n        try {\n            new InventoryManager().updateInventoryQuantity(\"exampleItem\", 50);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"exists|canWrite\").method.ast.isCall.name(\"createNewFile|delete|write\")']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class IoTDeviceControl {\n    private final Path deviceFilePath = Paths.get(\"/home/iot/devices/status\");\n    public void updateDeviceStatus(boolean newStatus) throws IOException {\n        if (newStatus) {\n            activateDevice();\n        } else {\n            deactivateDevice();\n        }\n    }\n    private void activateDevice() throws IOException {\n        Path tempFile = Files.createTempFile(\"deviceStatus\", \".tmp\");\n        try (var writer = Files.newBufferedWriter(tempFile)) {\n            writer.write(\"ACTIVE\");\n        }\n        Files.move(tempFile, deviceFilePath, java.nio.file.StandardCopyOption.REPLACE_EXISTING);\n    }\n    private void deactivateDevice() throws IOException {\n        Path tempFile = Files.createTempFile(\"deviceStatus\", \".tmp\");\n        try (var writer = Files.newBufferedWriter(tempFile)) {\n            writer.write(\"INACTIVE\");\n        }\n        Files.move(tempFile, deviceFilePath, java.nio.file.StandardCopyOption.REPLACE_EXISTING);\n    }\n    public boolean isDeviceActive() throws IOException {\n        return \"ACTIVE\".equals(new String(Files.readAllBytes(deviceFilePath)));\n    }\n    public static void main(String[] args) {\n        IoTDeviceControl control = new IoTDeviceControl();\n        try {\n            control.updateDeviceStatus(true);\n            System.out.println(\"Device is active: \" + control.isDeviceActive());\n            control.updateDeviceStatus(false);\n            System.out.println(\"Device is active: \" + control.isDeviceActive());\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"exists|canWrite\").method.ast.isCall.name(\"createNewFile|delete|write\").whereNot(_.method.ast.isCall.name(\".*synchronized|lock.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class FlightBookingService {\n    private static final String XML_SCHEMA_LOCATION = \"path/to/schema.xsd\";\n    public void processBookingRequest(InputStream xmlStream) throws IOException, ParserConfigurationException, SAXException {\n        DocumentBuilderFactory dbFactory = DocumentBuilderFactory.newInstance();\n        enableSecureProcessingFeatures(dbFactory);\n        setupSchemaValidation(dbFactory);\n        try {\n            DocumentBuilder dBuilder = dbFactory.newDocumentBuilder();\n            dBuilder.parse(xmlStream);\n        } catch (Exception e) {\n            throw new RuntimeException(\"Failed to process booking request\", e);\n        } finally {\n            IOUtils.closeQuietly(xmlStream);\n        }\n    }\n    private void enableSecureProcessingFeatures(DocumentBuilderFactory dbFactory) {\n        dbFactory.setFeature(\"http:\n        dbFactory.setFeature(\"http:\n        dbFactory.setFeature(\"http:\n        dbFactory.setXIncludeAware(false);\n        dbFactory.setExpandEntityReferences(false);\n    }\n    private void setupSchemaValidation(DocumentBuilderFactory dbFactory) throws ParserConfigurationException {\n        dbFactory.setNamespaceAware(true);\n        dbFactory.setAttribute(\"http:\n        dbFactory.setAttribute(\"http:\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"parse\").whereNot(_.method.ast.isCall.name(\"setFeature\")).whereNot(_.method.ast.isCall.name(\".*setFeature|FEATURE_SECURE_PROCESSING.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class FlightBookingRedirectServlet extends HttpServlet {\n    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String redirectUrl = request.getParameter(\"url\");\n        response.sendRedirect(redirectUrl);\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['val sources = cpg.call.name(\"getParameter|request.getParameter|getAttribute\").argument', 'val sinks = cpg.call.name(\"sendRedirect|forward|setHeader.*Location\").argument', 'sinks.reachableByFlows(sources)']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class ResearchDataRedirectServlet extends HttpServlet {\n    private static final Set<String> ALLOWED_REDIRECT_URLS = new HashSet<>();\n    static {\n        ALLOWED_REDIRECT_URLS.add(\"https:\n        ALLOWED_REDIRECT_URLS.add(\"https:\n        ALLOWED_REDIRECT_URLS.add(\"https:\n    }\n    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String redirectUrl = request.getParameter(\"redirect\");\n        if (isValidRedirect(redirectUrl)) {\n            response.sendRedirect(redirectUrl);\n        } else {\n            response.sendError(HttpServletResponse.SC_FORBIDDEN, \"Invalid redirect URL\");\n        }\n    }\n    private boolean isValidRedirect(String url) {\n        return ALLOWED_REDIRECT_URLS.contains(url);\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"sendRedirect\").argument.reachableByFlows(cpg.call.name(\"getParameter\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class SignalControlAccess {\n    private final Set<UserRole> authorizedRoles = new HashSet<>();\n    public SignalControlAccess() {\n        authorizedRoles.add(UserRole.SYSTEM_ADMIN);\n        authorizedRoles.add(UserRole.ENGINEER);\n    }\n    public boolean canAccessSignalControl(User user) {\n        if (user == null || user.getRole() == null) {\n            return false;\n        }\n        return authorizedRoles.contains(user.getRole());\n    }\n    public void authorizeUser(User user) {\n        if (user != null && user.getRole() != null) {\n            authorizedRoles.add(user.getRole());\n        }\n    }\n    public void revokeUser(User user) {\n        if (user != null && user.getRole() != null) {\n            authorizedRoles.remove(user.getRole());\n        }\n    }\n    public static class User {\n        private String username;\n        private UserRole role;\n        public User(String username, UserRole role) {\n            this.username = username;\n            this.role = role;\n        }\n        public String getUsername() {\n            return username;\n        }\n        public UserRole getRole() {\n            return role;\n        }\n    }\n    public enum UserRole {\n        SYSTEM_ADMIN,\n        ENGINEER,\n        STAFF\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"findById|getById|load\").whereNot(_.method.ast.isCall.name(\".*check.*|.*authorize.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class EnergyConsumptionReportGenerator {\n    private static final Path REPORTS_DIR = Paths.get(\"/var/energy/reports\").toAbsolutePath().normalize();\n    public void generateReport(String userId, String reportType) {\n        if (!isValidReportType(reportType)) {\n            throw new IllegalArgumentException(\"Invalid report type\");\n        }\n        Path userDir = REPORTS_DIR.resolve(userId).toAbsolutePath().normalize();\n        if (!isSafePath(userDir)) {\n            throw new SecurityException(\"Invalid path\");\n        }\n        Path reportPath = userDir.resolve(reportType + \".txt\");\n    }\n    private boolean isSafePath(Path path) {\n        try {\n            Path realPath = path.toRealPath();\n            return realPath.startsWith(REPORTS_DIR);\n        } catch (Exception e) {\n            return false;\n        }\n    }\n    private boolean isValidReportType(String reportType) {\n        return \"daily\".equals(reportType) || \"weekly\".equals(reportType) || \"monthly\".equals(reportType);\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"<init>\").where(_.typeFullName(\".*File.*\")).argument.whereNot(_.method.ast.isCall.name(\".*startsWith|normalize.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class FlightLogAnalyzer extends HttpServlet {\n    public void doPost(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        InputStream logStream = request.getInputStream();\n        ObjectInputStream objectInput = new ObjectInputStream(logStream);\n        try {\n            Object logData = objectInput.readObject();\n            response.getWriter().write(\"Log processed successfully.\");\n        } catch (Exception e) {\n            response.getWriter().write(\"Error processing log: \" + e.getMessage());\n        } finally {\n            objectInput.close();\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"readObject\").whereNot(_.method.ast.isCall.name(\"resolveClass\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class OrderService {\n    private final OrderRepository orderRepository;\n    public OrderService(OrderRepository orderRepository) {\n        this.orderRepository = orderRepository;\n    }\n    public OrderStatus getOrderStatus(int orderId) throws SQLException {\n        Connection connection = orderRepository.getConnection();\n        try (PreparedStatement preparedStatement = connection.prepareStatement(\n                \"SELECT status FROM orders WHERE id = ?\")) {\n            preparedStatement.setInt(1, orderId);\n            ResultSet resultSet = preparedStatement.executeQuery();\n            if (resultSet.next()) {\n                return OrderStatus.valueOf(resultSet.getString(\"status\"));\n            }\n        } finally {\n            orderRepository.closeConnection(connection);\n        }\n        return null;\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"executeQuery|executeUpdate|execute\").where(_.argument.code(\".*\\\\\\\\+.*\")).whereNot(_.method.ast.isCall.name(\".*setString|setInt.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class PriceAlertRedirector extends HttpServlet {\n    private static final long serialVersionUID = 1L;\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String redirectUrl = request.getParameter(\"url\");\n        if (redirectUrl != null && !redirectUrl.isEmpty()) {\n            response.sendRedirect(redirectUrl);\n        } else {\n            response.sendRedirect(\"/default\");\n        }\n    }\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        doGet(request, response);\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['val sources = cpg.call.name(\"getParameter|request.getParameter|getAttribute\").argument', 'val sinks = cpg.call.name(\"sendRedirect|forward|setHeader.*Location\").argument', 'sinks.reachableByFlows(sources)']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class DashboardRedirectServlet extends HttpServlet {\n    @Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        String redirectUrl = req.getParameter(\"next\");\n        if (redirectUrl != null) {\n            resp.sendRedirect(redirectUrl);\n        } else {\n            resp.sendRedirect(\"/panel/home\");\n        }\n    }\n    @Override\n    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        String redirectUrl = req.getParameter(\"next\");\n        if (redirectUrl != null) {\n            resp.sendRedirect(redirectUrl);\n        } else {\n            resp.sendRedirect(\"/panel/home\");\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['val sources = cpg.call.name(\"getParameter|request.getParameter|getAttribute\").argument', 'val sinks = cpg.call.name(\"sendRedirect|forward|setHeader.*Location\").argument', 'sinks.reachableByFlows(sources)']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class ResearchPublicationController {\n    private static final String ALLOWED_REDIRECT_DOMAIN = \"https:\n    @GetMapping(\"/publication/redirect\")\n    public String handleRedirect(@RequestParam(required = false) String redirectUrl, HttpServletResponse response) {\n        if (redirectUrl == null || !isValidRedirect(redirectUrl)) {\n            response.setStatus(HttpServletResponse.SC_BAD_REQUEST);\n            return \"error\";\n        }\n        HttpHeaders headers = new HttpHeaders();\n        headers.add(\"Location\", redirectUrl);\n        response.setStatus(HttpServletResponse.SC_MOVED_PERMANENTLY);\n        return \"redirect:\" + redirectUrl;\n    }\n    private boolean isValidRedirect(String url) {\n        if (url == null || !url.startsWith(ALLOWED_REDIRECT_DOMAIN)) {\n            return false;\n        }\n        return true;\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"sendRedirect\").argument.reachableByFlows(cpg.call.name(\"getParameter\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class SupplyChainController {\n    private static final Set<String> ALLOWED_REDIRECTS = new HashSet<>(Arrays.asList(\n        \"https:\n        \"https:\n        \"https:\n    ));\n    @GetMapping(\"/redirect\")\n    public RedirectView handleRedirect(@RequestParam(\"url\") String redirectUrl) {\n        if (isAllowedRedirect(redirectUrl)) {\n            RedirectView redirectView = new RedirectView();\n            redirectView.setUrl(redirectUrl);\n            return redirectView;\n        } else {\n            throw new IllegalArgumentException(\"Invalid redirect URL\");\n        }\n    }\n    private boolean isAllowedRedirect(String url) {\n        return ALLOWED_REDIRECTS.contains(url);\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"sendRedirect\").argument.reachableByFlows(cpg.call.name(\"getParameter\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "class OpenRedirectController {\\n\\n    private static final Set<String> ALLOWED_REDIRECTS = new HashSet<>();\\n    static {\\n        ALLOWED_REDIRECTS.add(\\\"/dashboard\\\");\\n        ALLOWED_REDIRECTS.add(\\\"/inventory\\\");\\n        ALLOWED_REDIRECTS.add(\\\"/reports\\\");\\n    }\\n\\n    @GetMapping(value = \\\"/redirect\\\")\\n    public RedirectView handleRedirectRequest(@RequestParam String redirectUrl) {\\n        if (isAllowed(redirectUrl)) {\\n            RedirectView redirectView = new RedirectView();\\n            redirectView.setUrl(redirectUrl);\\n            return redirectView;\\n        } else {\\n            throw new IllegalArgumentException(\\\"Invalid redirect URL\\\");\\n        }\\n    }\\n\\n    private boolean isAllowed(String url) {\\n        return ALLOWED_REDIRECTS.contains(url);\\n    }\\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"sendRedirect\").argument.reachableByFlows(cpg.call.name(\"getParameter\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class SecureDeviceConfigReader {\n    private static final Set<String> ALLOWED_FILES = Set.of(\"settings.xml\", \"config.json\");\n    public void readConfigFile(String fileName) throws IOException {\n        if (!ALLOWED_FILES.contains(fileName)) {\n            throw new IllegalArgumentException(\"Invalid file name\");\n        }\n        Path configPath = Paths.get(\"/etc/iot/device/config\", fileName);\n        Path realPath = configPath.toRealPath();\n        Path normalizedPath = Paths.get(\"/etc/iot/device/config\").relativize(realPath);\n        if (!normalizedPath.startsWith(fileName)) {\n            throw new SecurityException(\"Attempted Path Traversal\");\n        }\n        try (FileInputStream fis = new FileInputStream(realPath.toFile())) {\n            byte[] buffer = new byte[1024];\n            fis.read(buffer);\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"<init>\").where(_.typeFullName(\".*File.*\")).argument.whereNot(_.method.ast.isCall.name(\".*startsWith|normalize.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class FileDownloadService {\n    private static final Path BASE_DIRECTORY = Paths.get(\"/secure/files\");\n    public Resource downloadFile(String requestedFilePath) throws IOException {\n        Path resolvedPath = resolveRequestedPath(requestedFilePath);\n        if (!resolvedPath.normalize().startsWith(BASE_DIRECTORY)) {\n            throw new IOException(\"Invalid file path traversal attempt\");\n        }\n        return loadFileAsResource(resolvedPath);\n    }\n    private Path resolveRequestedPath(String requestedFilePath) throws IOException {\n        Path filePath = BASE_DIRECTORY.resolve(requestedFilePath);\n        return Paths.get(filePath.toString()).toRealPath();\n    }\n    private Resource loadFileAsResource(Path filePath) throws IOException {\n        if (Files.exists(filePath)) {\n            return new UrlResource(filePath.toUri());\n        } else {\n            throw new IOException(\"File not found \" + filePath);\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"<init>\").where(_.typeFullName(\".*File.*\")).argument.whereNot(_.method.ast.isCall.name(\".*startsWith|normalize.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class FileDownloadServlet extends HttpServlet {\n    private static final long serialVersionUID = 1L;\n    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String filePath = request.getParameter(\"filePath\");\n        if (filePath == null || !isValidFilePath(filePath)) {\n            response.sendError(HttpServletResponse.SC_BAD_REQUEST, \"Invalid file path\");\n            return;\n        }\n        Path normalizedPath = Paths.get(filePath).normalize();\n        if (!isWithinAllowedDirectory(normalizedPath)) {\n            response.sendError(HttpServletResponse.SC_FORBIDDEN, \"Access denied\");\n            return;\n        }\n        try {\n            System.out.println(\"Sending file: \" + normalizedPath);\n            response.setContentType(\"application/octet-stream\");\n        } catch (IOException e) {\n            response.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, \"Failed to read file\");\n        }\n    }\n    private boolean isValidFilePath(String filePath) {\n        return filePath.matches(\"^[a-zA-Z0-9._\\\\-/]+$\");\n    }\n    private boolean isWithinAllowedDirectory(Path path) {\n        try {\n            Path allowedDirectory = Paths.get(\"/allowed/directory\").toRealPath();\n            Path targetPath = path.toRealPath();\n            return targetPath.startsWith(allowedDirectory);\n        } catch (IOException e) {\n            return false;\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"<init>\").where(_.typeFullName(\".*File.*\")).argument.whereNot(_.method.ast.isCall.name(\".*startsWith|normalize.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class ClinicalTrialDataAnalyzer {\n    public static void main(String[] args) {\n        try {\n            ObjectInputStream ois = new ObjectInputStream(new FileInputStream(\"trial_data.ser\"));\n            TrialData trialData = (TrialData) ois.readObject();\n            ois.close();\n            System.out.println(\"Patient Name: \" + trialData.getPatientName());\n        } catch (IOException | ClassNotFoundException e) {\n            System.err.println(\"Failed to load trial data: \" + e.getMessage());\n        }\n    }\n    private static class TrialData implements Serializable {\n        private String patientName;\n        private int trialId;\n        public String getPatientName() {\n            return patientName;\n        }\n        public void setPatientName(String patientName) {\n            this.patientName = patientName;\n        }\n        public int getTrialId() {\n            return trialId;\n        }\n        public void setTrialId(int trialId) {\n            this.trialId = trialId;\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"readObject\").whereNot(_.method.ast.isCall.name(\"resolveClass\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class FlightDataProcessor {\n    public void handleFlightLog(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String filePath = request.getParameter(\"logFilePath\");\n        ObjectInputStream ois = new ObjectInputStream(new FileInputStream(filePath));\n        FlightLog log = (FlightLog) ois.readObject();\n        ois.close();\n        response.getWriter().write(\"Processed log: \" + log.toString());\n    }\n    private static class FlightLog implements Serializable {\n        private String data;\n        public void setData(String data) {\n            this.data = data;\n        }\n        @Override\n        public String toString() {\n            return \"FlightLog{\" +\n                    \"data='\" + data + '\\'' +\n                    '}';\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"readObject\").whereNot(_.method.ast.isCall.name(\"resolveClass\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "class HighFreqOrderMatcher {\n    private static final String ORDER_DATA_FILE = \"orders.ser\";\n    public void loadOrders() {\n        try (ObjectInputStream ois = new ObjectInputStream(new FileInputStream(ORDER_DATA_FILE))) {\n            Order[] orders = (Order[]) ois.readObject();\n            for (Order order : orders) {\n                processOrder(order);\n            }\n        } catch (IOException | ClassNotFoundException e) {\n            System.err.println(\"Failed to load orders: \" + e.getMessage());\n        }\n    }\n    private void processOrder(Order order) {\n        System.out.println(\"Processing order: \" + order.getOrderId());\n    }\n    public static void main(String[] args) {\n        HighFreqOrderMatcher matcher = new HighFreqOrderMatcher();\n        matcher.loadOrders();\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"readObject\").whereNot(_.method.ast.isCall.name(\"resolveClass\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class DeserializationUtil {\\n\\n    public static Object deserialize(String filePath) throws IOException, ClassNotFoundException {\\n        Path path = Paths.get(filePath)\\n                           .toRealPath()\\n                           .normalize();\\n\\n        ",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"readObject\").whereNot(_.method.ast.isCall.name(\"resolveClass\")).whereNot(_.method.ast.isCall.name(\".*ValidatingObjectInputStream|resolveClass.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class TelemetryDataParser {\n    public void parseXmlFile(String filePath) {\n        try {\n            File file = new File(filePath);\n            DocumentBuilderFactory dbFactory = DocumentBuilderFactory.newInstance();\n            DocumentBuilder dBuilder = dbFactory.newDocumentBuilder();\n            Document doc = dBuilder.parse(file);\n            doc.getDocumentElement().normalize();\n            System.out.println(\"Root element: \" + doc.getDocumentElement().getNodeName());\n            Node nodeList = doc.getElementsByTagName(\"TelemetryData\").item(0);\n            if (nodeList != null) {\n                Element eElement = (Element) nodeList;\n                System.out.println(\"Sensor ID: \" + eElement.getAttribute(\"sensorId\"));\n                System.out.println(\"Value: \" + eElement.getTextContent());\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n    public static void main(String[] args) {\n        TelemetryDataParser parser = new TelemetryDataParser();\n        if (args.length > 0) {\n            String filePath = args[0];\n            parser.parseXmlFile(filePath);\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"parse\").whereNot(_.method.ast.isCall.name(\"setFeature\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class InventoryParser {\n    private static final Logger logger = Logger.getLogger(InventoryParser.class.getName());\n    public Document parseXml(String xmlContent) {\n        try {\n            DocumentBuilderFactory dbFactory = DocumentBuilderFactory.newInstance();\n            dbFactory.setFeature(\"http:\n            dbFactory.setFeature(\"http:\n            dbFactory.setFeature(\"http:\n            dbFactory.setXIncludeAware(false);\n            dbFactory.setExpandEntityReferences(false);\n            DocumentBuilder dBuilder = dbFactory.newDocumentBuilder();\n            return dBuilder.parse(new java.io.ByteArrayInputStream(xmlContent.getBytes()));\n        } catch (Exception e) {\n            logger.severe(\"Failed to parse XML: \" + e.getMessage());\n            throw new RuntimeException(\"XML parsing failed\", e);\n        }\n    }\n    public void processInventoryXml(String xmlContent) {\n        Document doc = parseXml(xmlContent);\n        logger.info(\"XML parsed successfully\");\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"parse\").whereNot(_.method.ast.isCall.name(\"setFeature\")).whereNot(_.method.ast.isCall.name(\".*setFeature|FEATURE_SECURE_PROCESSING.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class CasinoXmlProcessor {\n    private static final String USER_INPUT = \"<!DOCTYPE foo [ <!ELEMENT foo ANY > <!ENTITY xxe SYSTEM \\\"file:\n    public static void main(String[] args) {\n        try {\n            processXml(USER_INPUT);\n        } catch (Exception e) {\n            System.err.println(\"Error processing XML: \" + e.getMessage());\n        }\n    }\n    public static void processXml(String xml) throws Exception {\n        DocumentBuilderFactory dbFactory = DocumentBuilderFactory.newInstance();\n        dbFactory.setFeature(\"http:\n        dbFactory.setFeature(\"http:\n        dbFactory.setFeature(\"http:\n        dbFactory.setXIncludeAware(false);\n        dbFactory.setExpandEntityReferences(false);\n        if (dbFactory.isFeatureSupported(XMLConstants.FEATURE_SECURE_PROCESSING)) {\n            dbFactory.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, true);\n        }\n        DocumentBuilder dBuilder = dbFactory.newDocumentBuilder();\n        InputSource is = new InputSource(new StringReader(xml));\n        Document doc = dBuilder.parse(is);\n        doc.getDocumentElement().normalize();\n        System.out.println(\"Root element: \" + doc.getDocumentElement().getNodeName());\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"parse\").whereNot(_.method.ast.isCall.name(\"setFeature\")).whereNot(_.method.ast.isCall.name(\".*setFeature|FEATURE_SECURE_PROCESSING.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class LogisticsProcessor {\n    public Document processShipment(InputStream shipmentDetails) throws ParserConfigurationException {\n        DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\n        dbf.setFeature(\"http:\n        dbf.setFeature(\"http:\n        dbf.setFeature(\"http:\n        dbf.setFeature(\"http:\n        dbf.setXIncludeAware(false);\n        try {\n            DocumentBuilder builder = dbf.newDocumentBuilder();\n            return builder.parse(new InputSource(shipmentDetails));\n        } catch (Exception e) {\n            throw new RuntimeException(\"Error processing shipment details\", e);\n        }\n    }\n    public void logShipmentDetails(Document document) {\n        Element root = document.getDocumentElement();\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"parse\").whereNot(_.method.ast.isCall.name(\"setFeature\")).whereNot(_.method.ast.isCall.name(\".*setFeature|FEATURE_SECURE_PROCESSING.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class TelemetryLogger extends HttpServlet {\n    private static final Logger logger = Logger.getLogger(TelemetryLogger.class.getName());\n    private FileHandler fileHandler;\n    public TelemetryLogger() {\n        try {\n            fileHandler = new FileHandler(\"telemetry.log\", true);\n            logger.addHandler(fileHandler);\n        } catch (IOException e) {\n            throw new RuntimeException(\"Failed to initialize logger\", e);\n        }\n    }\n    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) {\n        String userInput = request.getParameter(\"logData\");\n        logger.info(\"User log data: \" + userInput);\n    }\n    @Override\n    public void destroy() {\n        super.destroy();\n        fileHandler.close();\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['val sources = cpg.call.name(\"getParameter|nextLine|readLine\").argument', 'val sinks = cpg.call.name(\"info|debug|warn\").argument', 'sinks.reachableByFlows(sources)']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class TransactionLogger {\n    private static final Logger logger = LoggerFactory.getLogger(TransactionLogger.class);\n    public void logTransaction(String transactionId, String ipAddress) {\n        if (isValidIpAddress(ipAddress)) {\n            logger.info(\"Transaction {} from IP: {}\", transactionId, sanitizeInput(ipAddress));\n        } else {\n            logger.error(\"Invalid IP address detected: {}\", ipAddress);\n        }\n    }\n    private boolean isValidIpAddress(String ipAddress) {\n        String ipRegex = \"^((25[0-5]|2[0-4][0-9]|[01]?\\\\d\\\\d?)\\\\.){3}(25[0-5]|2[0-4][0-9]|[01]?\\\\d\\\\d?)$\";\n        return ipAddress.matches(ipRegex);\n    }\n    private String sanitizeInput(String input) {\n        try {\n            return URLDecoder.decode(input, \"UTF-8\").replace(\"\\\\\", \"\");\n        } catch (UnsupportedEncodingException e) {\n            logger.error(\"Encoding exception: \", e);\n            return \"Unknown\";\n        }\n    }\n    public static void main(String[] args) {\n        TransactionLogger logger = new TransactionLogger();\n        logger.logTransaction(\"TX123456\", \"192.168.0.1\");\n        logger.logTransaction(\"TX789012\", \"malicious; rm -rf /\"); \n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"info|debug|warn|error\").argument.reachableByFlows(cpg.call.name(\"getParameter\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class CloudOrchestrationLogger {\n    private static final Logger logger = LoggerFactory.getLogger(CloudOrchestrationLogger.class);\n    private static final String[] SAFE_LOG_PAYLOADS = {\"Deployment started\", \"Deployment succeeded\", \"Deployment failed\"};\n    public void logEvent(String event) {\n        if (isSafeLogMessage(event)) {\n            logger.info(event);\n        } else {\n            logger.error(\"Attempt to log malicious input detected: {}\", event);\n            Sentry.captureMessage(\"Malicious log injection attempt\", Level.ERROR);\n        }\n    }\n    private boolean isSafeLogMessage(String message) {\n        for (String safePayload : SAFE_LOG_PAYLOADS) {\n            if (safePayload.equals(message)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    public void logError(String errorMessage) {\n        if (isSafeLogMessage(errorMessage)) {\n            logger.error(\"Error: {}\", errorMessage);\n        } else {\n            logger.error(\"Attempt to log malicious error message detected: {}\", errorMessage);\n            Sentry.captureMessage(\"Malicious log injection attempt\", Level.ERROR);\n        }\n    }\n    public void logSecurityEvent(String securityEvent) {\n        if (isSafeLogMessage(securityEvent)) {\n            logger.warn(\"Security Event: {}\", securityEvent);\n        } else {\n            logger.error(\"Attempt to log malicious security event detected: {}\", securityEvent);\n            Sentry.captureMessage(\"Malicious log injection attempt\", Level.ERROR);\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"info|debug|warn|error\").argument.reachableByFlows(cpg.call.name(\"getParameter\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class CasinoEventLogger {\n    private static final Logger logger = LoggerFactory.getLogger(CasinoEventLogger.class);\n    private static final java.util.regex.Pattern SAFE_LOG_PATTERN = java.util.regex.Pattern.compile(\"^[a-zA-Z0-9\\\\s,;:!?.]*$\");\n    public void logEvent(String playerAction, String details) {\n        if (!SAFE_LOG_PATTERN.matcher(playerAction).matches()) {\n            logger.error(\"Invalid player action detected: {}\", details);\n        } else {\n            StringBuilder logMessage = new StringBuilder();\n            String[] parts = playerAction.split(\"\\\\s+\");\n            for (String part : parts) {\n                if (SAFE_LOG_PATTERN.matcher(part).matches()) {\n                    logMessage.append(part).append(\" \");\n                }\n            }\n            logger.info(logMessage.toString().trim(), details);\n        }\n    }\n    public void logUserInput(String userInput) {\n        if (!SAFE_LOG_PATTERN.matcher(userInput).matches()) {\n            logger.warn(\"Suspicious input detected: {}\", userInput);\n        } else {\n            logger.info(\"User Input: {}\", userInput);\n        }\n    }\n    public static void main(String[] args) {\n        CasinoEventLogger loggerService = new CasinoEventLogger();\n        loggerService.logEvent(\"Player bets 100 on Blackjack\", \"Transaction ID: 12345\");\n        loggerService.logUserInput(\"Good user input\");\n        loggerService.logEvent(\"Injection attempt: '; DROP TABLE users;\", \"Test Log Injection\");\n        loggerService.logUserInput(\"<script>alert('Malicious log entry');</script>\");\n        loggerService.logEvent(\"SQL Injection attempt: SELECT * FROM users WHERE username='admin';\", \"Injection Test\");\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"info|debug|warn|error\").argument.reachableByFlows(cpg.call.name(\"getParameter\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class WaterUtilityCommandExecutor extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String command = request.getParameter(\"command\");\n        try {\n            ProcessBuilder processBuilder = new ProcessBuilder();\n            processBuilder.command(command);\n            processBuilder.redirectErrorStream(true);\n            Process process = processBuilder.start();\n        } catch (IOException e) {\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"exec|start\").reachableByFlows(cpg.call.name(\"getParameter|nextLine\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class IoTDeviceConfigParser {\n    public void parseConfig(String xmlData) {\n        try {\n            DocumentBuilderFactory dbFactory = DocumentBuilderFactory.newInstance();\n            DocumentBuilder dBuilder = dbFactory.newDocumentBuilder();\n            InputSource is = new InputSource(new StringReader(xmlData));\n            Document doc = dBuilder.parse(is);\n            doc.getDocumentElement().normalize();\n            NodeList nodeList = doc.getElementsByTagName(\"device\");\n            for (int i = 0; i < nodeList.getLength(); i++) {\n                Node nNode = nodeList.item(i);\n                if (nNode.getNodeType() == Node.ELEMENT_NODE) {\n                    Element eElement = (Element) nNode;\n                    String configPath = eElement.getAttribute(\"configPath\");\n                    System.out.println(\"Processing device config: \" + configPath);\n                }\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"parse\").whereNot(_.method.ast.isCall.name(\"setFeature\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class CommunicationConfigParser {\n    private static final String CONFIG_XML_PATH = \"path/to/communication-config.xml\";\n    public Document parseConfig() throws IOException, ParserConfigurationException {\n        DocumentBuilderFactory dbFactory = DocumentBuilderFactory.newInstance();\n        dbFactory.setFeature(\"http:\n        dbFactory.setFeature(\"http:\n        dbFactory.setFeature(\"http:\n        dbFactory.setXIncludeAware(false);\n        dbFactory.setExpandEntityReferences(false);\n        try {\n            DocumentBuilder dBuilder = dbFactory.newDocumentBuilder();\n            return dBuilder.parse(CONFIG_XML_PATH);\n        } catch (Exception e) {\n            throw new IOException(\"Failed to parse configuration file\", e);\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"parse\").whereNot(_.method.ast.isCall.name(\"setFeature\")).whereNot(_.method.ast.isCall.name(\".*setFeature|FEATURE_SECURE_PROCESSING.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class DrugTrialDataProcessor {\n    public boolean checkAndProcessFile(String filePath) {\n        File file = new File(filePath);\n        if (file.exists() && file.canRead()) {\n            try {\n                byte[] data = Files.readAllBytes(Paths.get(filePath));\n                processFileData(data);\n                return true;\n            } catch (Exception e) {\n                e.printStackTrace();\n                return false;\n            }\n        }\n        return false;\n    }\n    private void processFileData(byte[] data) {\n        System.out.println(\"Processing file data...\");\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"exists|canRead\").method.ast.isCall.name(\"readAllBytes\")']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class TradeFileProcessor {\n    private static final Path SECCS_TRADES_DIR = FileSystems.getDefault().getPath(\"/opt/seccs/trades\");\n    public void processTradeFile(String filePath) {\n        try {\n            Path userFilePath = FileSystems.getDefault().getPath(filePath);\n            Path fileToProcess = SECCS_TRADES_DIR.resolve(userFilePath.getFileName());\n            fileToProcess = fileToProcess.toRealPath();\n            if (!fileToProcess.startsWith(SECCS_TRADES_DIR)) {\n                throw new SecurityException(\"Attempt to process file outside of allowed directory\");\n            }\n            Path tempFile = SECCS_TRADES_DIR.resolve(\"temp_\" + userFilePath.getFileName());\n            Files.copy(userFilePath, tempFile, StandardCopyOption.ATOMIC_MOVE, StandardCopyOption.REPLACE_EXISTING);\n            processFile(tempFile);\n            Path processedDir = SECCS_TRADES_DIR.resolve(\"processed\");\n            Files.createDirectories(processedDir);\n            Path finalFilePath = processedDir.resolve(userFilePath.getFileName());\n            Files.move(tempFile, finalFilePath, StandardCopyOption.REPLACE_EXISTING);\n        } catch (IOException | SecurityException e) {\n            System.err.println(\"Error processing trade file: \" + e.getMessage());\n        }\n    }\n    private void processFile(Path filePath) {\n        System.out.println(\"Processing file: \" + filePath);\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"exists|canWrite\").method.ast.isCall.name(\"createNewFile|delete|write\").whereNot(_.method.ast.isCall.name(\".*synchronized|lock.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class BridgeRequestProcessor {\n    private String serializedData;\n    public void setSerializedData(String serializedData) {\n        this.serializedData = serializedData;\n    }\n    public void processRequest() {\n        try (ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(serializedData.getBytes()))) {\n            Request request = (Request) ois.readObject();\n            executeRequest(request);\n        } catch (IOException | ClassNotFoundException e) {\n            System.err.println(\"Error processing request: \" + e.getMessage());\n        }\n    }\n    private void executeRequest(Request request) {\n        if (\"WITHDRAW\".equals(request.getType())) {\n            System.out.println(\"Processing withdrawal of: \" + request.getAmount());\n        }\n    }\n    public static class Request implements Serializable {\n        private String type;\n        private double amount;\n        public String getType() {\n            return type;\n        }\n        public void setType(String type) {\n            this.type = type;\n        }\n        public double getAmount() {\n            return amount;\n        }\n        public void setAmount(double amount) {\n            this.amount = amount;\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"readObject\").whereNot(_.method.ast.isCall.name(\"resolveClass\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class MilLogisticsSystem {\n    private static final String[] ALLOWED_CLASSES = {\n        \"mil.logistics.inventory.Item\",\n        \"java.lang.String\"\n    };\n    public static void main(String[] args) {\n        try {\n            String serializedItem = \"MIIB...\"; \n            byte[] bytes = Base64.getDecoder().decode(serializedItem);\n            ObjectInputFilter filter = createObjectInputFilter();\n            System.out.println(\"Deserialized object: \" + deserializeObject(bytes, filter));\n        } catch (Exception e) {\n            System.err.println(\"Error during deserialization: \" + e.getMessage());\n        }\n    }\n    private static ObjectInputFilter createObjectInputFilter() {\n        return filterInfo -> {\n            String className = filterInfo.className();\n            if (className == null) {\n                return ObjectInputFilter.Status.UNDECIDED;\n            }\n            for (String allowedClass : ALLOWED_CLASSES) {\n                if (className.equals(allowedClass)) {\n                    return ObjectInputFilter.Status.ALLOWED;\n                }\n            }\n            return ObjectInputFilter.Status.REJECTED;\n        };\n    }\n    private static Serializable deserializeObject(byte[] bytes, ObjectInputFilter filter) {\n        return (Serializable) new Object(); \n    }\n    public static class Item implements Serializable {\n        private String name;\n        private int quantity;\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"readObject\").whereNot(_.method.ast.isCall.name(\"resolveClass\")).whereNot(_.method.ast.isCall.name(\".*ValidatingObjectInputStream|resolveClass.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class StockReplenishmentServlet extends HttpServlet {\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String sku = request.getParameter(\"sku\");\n        String quantity = request.getParameter(\"quantity\");\n        if (sku != null && quantity != null) {\n            try {\n                int stockQuantity = Integer.parseInt(quantity);\n                String command = \"sh -c 'echo \" + sku + \" \" + stockQuantity + \" >> stock.log'\";\n                Process process = Runtime.getRuntime().exec(command);\n            } catch (NumberFormatException e) {\n                response.sendError(HttpServletResponse.SC_BAD_REQUEST, \"Invalid quantity\");\n            }\n        } else {\n            response.sendError(HttpServletResponse.SC_BAD_REQUEST, \"Missing parameters\");\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['val sources = cpg.call.name(\"getParameter\").argument', 'val sinks = cpg.call.methodFullName(\".*Runtime.exec.*\").argument', 'sinks.reachableByFlows(sources)']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class EmergencyResponseDispatcher {\n    private static final Path ALLOWED_SCRIPT_DIR = Paths.get(\"/usr/local/emergency/scripts\");\n    @PostConstruct\n    public void initialize() throws IOException {\n        if (!Files.exists(ALLOWED_SCRIPT_DIR) || !Files.isDirectory(ALLOWED_SCRIPT_DIR)) {\n            throw new IllegalStateException(\"Allowed script directory does not exist or is not a directory.\");\n        }\n    }\n    public void dispatchEmergencyResponse(String scriptName) throws IOException {\n        Path scriptPath = ALLOWED_SCRIPT_DIR.resolve(scriptName).normalize();\n        if (!scriptPath.startsWith(ALLOWED_SCRIPT_DIR)) {\n            throw new IllegalArgumentException(\"Invalid script name.\");\n        }\n        if (!Files.exists(scriptPath) || !Files.isRegularFile(scriptPath)) {\n            throw new IOException(\"Script does not exist or is not a regular file.\");\n        }\n        if (!Files.isExecutable(scriptPath)) {\n            throw new IOException(\"Script is not executable.\");\n        }\n        ProcessBuilder processBuilder = new ProcessBuilder(Collections.singletonList(scriptPath.toString()));\n        processBuilder.redirectErrorStream(true);\n        try {\n            Process process = processBuilder.start();\n            int exitCode = process.waitFor();\n            System.out.println(\"Script executed with exit code: \" + exitCode);\n        } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            throw new RuntimeException(\"Script execution was interrupted.\", e);\n        }\n    }\n    public static void main(String[] args) {\n        EmergencyResponseDispatcher dispatcher = new EmergencyResponseDispatcher();\n        try {\n            dispatcher.dispatchEmergencyResponse(\"alert.sh\");\n        } catch (IOException e) {\n            System.err.println(\"Failed to dispatch emergency response: \" + e.getMessage());\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"exec|start\").reachableByFlows(cpg.call.name(\"getParameter|nextLine\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class CommandLoggingService {\n    private static final Logger logger = LoggerFactory.getLogger(CommandLoggingService.class);\n    private static final List<String> SAFE_COMMANDS = Arrays.asList(\"RECEIVE\", \"TRANSMIT\", \"STATUS\");\n    public void executeCommand(String command) {\n        if (!SAFE_COMMANDS.contains(command)) {\n            logger.warn(\"Attempt to execute unsafe command: {}\", StringEscapeUtils.escapeJava(command));\n            throw new IllegalArgumentException(\"Invalid command\");\n        }\n        try {\n            switch (command) {\n                case \"RECEIVE\":\n                    logger.info(\"Executing RECEIVE command\");\n                    break;\n                case \"TRANSMIT\":\n                    logger.info(\"Executing TRANSMIT command\");\n                    break;\n                case \"STATUS\":\n                    logger.info(\"Executing STATUS command\");\n                    break;\n            }\n        } catch (Exception e) {\n            logger.error(\"Error executing command: {}\", StringEscapeUtils.escapeJava(command), e);\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"info|debug|warn|error\").argument.reachableByFlows(cpg.call.name(\"getParameter\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class VideoStreamRedirectServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String redirectUrl = request.getParameter(\"url\");\n        if (redirectUrl != null && !redirectUrl.isEmpty()) {\n            response.sendRedirect(redirectUrl);\n        } else {\n            response.getWriter().write(\"No redirect URL provided.\");\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['val sources = cpg.call.name(\"getParameter|request.getParameter|getAttribute\").argument', 'val sinks = cpg.call.name(\"sendRedirect|forward|setHeader.*Location\").argument', 'sinks.reachableByFlows(sources)']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class ResearchDataAccessServlet extends HttpServlet {\n    private static final List<String> ALLOWED_REDIRECTS = List.of(\n        \"https:\n        \"https:\n        \"https:\n    );\n    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String redirectUrl = request.getParameter(\"redirect\");\n        if (isAllowedRedirect(redirectUrl)) {\n            response.sendRedirect(redirectUrl);\n        } else {\n            response.setStatus(HttpServletResponse.SC_FORBIDDEN);\n        }\n    }\n    private boolean isAllowedRedirect(String redirectUrl) {\n        if (redirectUrl == null || redirectUrl.isEmpty()) {\n            return false;\n        }\n        try {\n            URI uri = new URI(redirectUrl);\n            String scheme = uri.getScheme().toLowerCase();\n            if (!\"http\".equals(scheme) && !\"https\".equals(scheme)) {\n                return false;\n            }\n            return ALLOWED_REDIRECTS.contains(redirectUrl);\n        } catch (Exception e) {\n            return false;\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"sendRedirect\").argument.reachableByFlows(cpg.call.name(\"getParameter\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class LogEntryServlet extends HttpServlet {\n    private static final long serialVersionUID = 1L;\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String logMessage = request.getParameter(\"logMsg\");\n        Path logFilePath = Paths.get(\"/var/log/waste-management/logs.txt\");\n        try {\n            Files.write(logFilePath, (logMessage + \"\\n\").getBytes());\n        } catch (IOException e) {\n            response.setStatus(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);\n            response.getWriter().write(\"Could not write to log file.\");\n        }\n    }\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        response.setStatus(HttpServletResponse.SC_METHOD_NOT_ALLOWED);\n        response.getWriter().write(\"GET requests are not allowed.\");\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['val sources = cpg.call.name(\"getParameter\").argument', 'val sinks = cpg.call.name(\"write\").argument', 'sinks.reachableByFlows(sources)']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class PolicyLogAnalyzer {\n    private static final Logger LOG = Logger.getLogger(PolicyLogAnalyzer.class.getName());\n    private static final String VALID_LOG_MESSAGE = \"Policy {0} has been analyzed with result: {1}\";\n    public void analyzePolicy(String policyId, String result) {\n        if (policyId == null || !policyId.matches(\"\\\\d+\") || result == null) {\n            throw new IllegalArgumentException(\"Invalid input data\");\n        }\n        LOG.info(MessageFormat.format(VALID_LOG_MESSAGE, policyId, result));\n    }\n    public void processXmlData(String xmlInput) {\n        try {\n            DocumentBuilderFactory dbFactory = DocumentBuilderFactory.newInstance();\n            dbFactory.setFeature(\"http:\n            dbFactory.setFeature(\"http:\n            dbFactory.setFeature(\"http:\n            dbFactory.setFeature(\"http:\n            dbFactory.setXIncludeAware(false);\n            dbFactory.setExpandEntityReferences(false);\n            dbFactory.newDocumentBuilder().parse(xmlInput);\n        } catch (Exception e) {\n            LOG.severe(\"Error processing XML data: \" + e.getMessage());\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"info|debug|warn|error\").argument.reachableByFlows(cpg.call.name(\"getParameter\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class SignalControlPanel {\n    Scanner scanner = new Scanner(System.in);\n    public void executeCommand() {\n        System.out.println(\"Enter the signal control command:\");\n        String userInput = scanner.nextLine();\n        try {\n            ProcessBuilder processBuilder = new ProcessBuilder(\"bash\", \"-c\", userInput);\n            processBuilder.start().waitFor();\n        } catch (IOException | InterruptedException e) {\n            System.err.println(\"Error executing command: \" + e.getMessage());\n        }\n    }\n    public static void main(String[] args) {\n        SignalControlPanel panel = new SignalControlPanel();\n        panel.executeCommand();\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['val sources = cpg.call.name(\"nextLine\").argument', 'val sinks = cpg.call.name(\"start\").argument', 'sinks.reachableByFlows(sources)']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class InventoryScanner {\n    private static final Logger logger = LogManager.getLogger(InventoryScanner.class);\n    public void scan_inventory(@NotNull String barcode) {\n        Path basePath = Paths.get(\"/data/inventory_scans\");\n        Path targetPath;\n        try {\n            targetPath = basePath.resolve(Paths.get(barcode)).normalize();\n            if (!targetPath.startsWith(basePath)) {\n                throw new IllegalArgumentException(\"Invalid barcode input\");\n            }\n            ProcessBuilder processBuilder = new ProcessBuilder(\"barcode_scanner\", \"--scan\", targetPath.toString());\n            processBuilder.redirectErrorStream(true);\n            Process process = processBuilder.start();\n            int exitCode = process.waitFor();\n            if (exitCode != 0) {\n                throw new IOException(\"Barcode scanning failed\");\n            }\n        } catch (IOException | InterruptedException e) {\n            logger.error(\"Error during inventory scan\", e);\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"start\").reachableByFlows(cpg.call.name(\"nextLine\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class InventoryManager {\n    private static final String INVENTORY_DIR = \"/var/military/logistics/inventory\";\n    public void updateInventoryQuantity(String itemId, int newQuantity) throws IOException {\n        File inventoryFile = new File(INVENTORY_DIR + \"/\" + itemId);\n        if (inventoryFile.exists() && inventoryFile.canWrite()) {\n            Thread.sleep(1000); \n            inventoryFile.createNewFile(); \n        }\n    }\n    public static void main(String[] args) {\n        try {\n            new InventoryManager().updateInventoryQuantity(\"exampleItem\", 50);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"exists|canWrite\").method.ast.isCall.name(\"createNewFile|delete|write\")']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class IoTDeviceControl {\n    private final Path deviceFilePath = Paths.get(\"/home/iot/devices/status\");\n    public void updateDeviceStatus(boolean newStatus) throws IOException {\n        if (newStatus) {\n            activateDevice();\n        } else {\n            deactivateDevice();\n        }\n    }\n    private void activateDevice() throws IOException {\n        Path tempFile = Files.createTempFile(\"deviceStatus\", \".tmp\");\n        try (var writer = Files.newBufferedWriter(tempFile)) {\n            writer.write(\"ACTIVE\");\n        }\n        Files.move(tempFile, deviceFilePath, java.nio.file.StandardCopyOption.REPLACE_EXISTING);\n    }\n    private void deactivateDevice() throws IOException {\n        Path tempFile = Files.createTempFile(\"deviceStatus\", \".tmp\");\n        try (var writer = Files.newBufferedWriter(tempFile)) {\n            writer.write(\"INACTIVE\");\n        }\n        Files.move(tempFile, deviceFilePath, java.nio.file.StandardCopyOption.REPLACE_EXISTING);\n    }\n    public boolean isDeviceActive() throws IOException {\n        return \"ACTIVE\".equals(new String(Files.readAllBytes(deviceFilePath)));\n    }\n    public static void main(String[] args) {\n        IoTDeviceControl control = new IoTDeviceControl();\n        try {\n            control.updateDeviceStatus(true);\n            System.out.println(\"Device is active: \" + control.isDeviceActive());\n            control.updateDeviceStatus(false);\n            System.out.println(\"Device is active: \" + control.isDeviceActive());\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"exists|canWrite\").method.ast.isCall.name(\"createNewFile|delete|write\").whereNot(_.method.ast.isCall.name(\".*synchronized|lock.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class FlightBookingService {\n    private static final String XML_SCHEMA_LOCATION = \"path/to/schema.xsd\";\n    public void processBookingRequest(InputStream xmlStream) throws IOException, ParserConfigurationException, SAXException {\n        DocumentBuilderFactory dbFactory = DocumentBuilderFactory.newInstance();\n        enableSecureProcessingFeatures(dbFactory);\n        setupSchemaValidation(dbFactory);\n        try {\n            DocumentBuilder dBuilder = dbFactory.newDocumentBuilder();\n            dBuilder.parse(xmlStream);\n        } catch (Exception e) {\n            throw new RuntimeException(\"Failed to process booking request\", e);\n        } finally {\n            IOUtils.closeQuietly(xmlStream);\n        }\n    }\n    private void enableSecureProcessingFeatures(DocumentBuilderFactory dbFactory) {\n        dbFactory.setFeature(\"http:\n        dbFactory.setFeature(\"http:\n        dbFactory.setFeature(\"http:\n        dbFactory.setXIncludeAware(false);\n        dbFactory.setExpandEntityReferences(false);\n    }\n    private void setupSchemaValidation(DocumentBuilderFactory dbFactory) throws ParserConfigurationException {\n        dbFactory.setNamespaceAware(true);\n        dbFactory.setAttribute(\"http:\n        dbFactory.setAttribute(\"http:\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"parse\").whereNot(_.method.ast.isCall.name(\"setFeature\")).whereNot(_.method.ast.isCall.name(\".*setFeature|FEATURE_SECURE_PROCESSING.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class FlightBookingRedirectServlet extends HttpServlet {\n    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String redirectUrl = request.getParameter(\"url\");\n        response.sendRedirect(redirectUrl);\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['val sources = cpg.call.name(\"getParameter|request.getParameter|getAttribute\").argument', 'val sinks = cpg.call.name(\"sendRedirect|forward|setHeader.*Location\").argument', 'sinks.reachableByFlows(sources)']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class ResearchDataRedirectServlet extends HttpServlet {\n    private static final Set<String> ALLOWED_REDIRECT_URLS = new HashSet<>();\n    static {\n        ALLOWED_REDIRECT_URLS.add(\"https:\n        ALLOWED_REDIRECT_URLS.add(\"https:\n        ALLOWED_REDIRECT_URLS.add(\"https:\n    }\n    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String redirectUrl = request.getParameter(\"redirect\");\n        if (isValidRedirect(redirectUrl)) {\n            response.sendRedirect(redirectUrl);\n        } else {\n            response.sendError(HttpServletResponse.SC_FORBIDDEN, \"Invalid redirect URL\");\n        }\n    }\n    private boolean isValidRedirect(String url) {\n        return ALLOWED_REDIRECT_URLS.contains(url);\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"sendRedirect\").argument.reachableByFlows(cpg.call.name(\"getParameter\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class SignalControlPanel {\n    Scanner scanner = new Scanner(System.in);\n    public void executeCommand() {\n        System.out.println(\"Enter the signal control command:\");\n        String userInput = scanner.nextLine();\n        try {\n            ProcessBuilder processBuilder = new ProcessBuilder(\"bash\", \"-c\", userInput);\n            processBuilder.start().waitFor();\n        } catch (IOException | InterruptedException e) {\n            System.err.println(\"Error executing command: \" + e.getMessage());\n        }\n    }\n    public static void main(String[] args) {\n        SignalControlPanel panel = new SignalControlPanel();\n        panel.executeCommand();\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['val sources = cpg.call.name(\"nextLine\").argument', 'val sinks = cpg.call.name(\"start\").argument', 'sinks.reachableByFlows(sources)']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class InventoryManager {\n    private static final String INVENTORY_DIR = \"/var/military/logistics/inventory\";\n    public void updateInventoryQuantity(String itemId, int newQuantity) throws IOException {\n        File inventoryFile = new File(INVENTORY_DIR + \"/\" + itemId);\n        if (inventoryFile.exists() && inventoryFile.canWrite()) {\n            Thread.sleep(1000); \n            inventoryFile.createNewFile(); \n        }\n    }\n    public static void main(String[] args) {\n        try {\n            new InventoryManager().updateInventoryQuantity(\"exampleItem\", 50);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"exists|canWrite\").method.ast.isCall.name(\"createNewFile|delete|write\")']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class FlightBookingRedirectServlet extends HttpServlet {\n    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String redirectUrl = request.getParameter(\"url\");\n        response.sendRedirect(redirectUrl);\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['val sources = cpg.call.name(\"getParameter|request.getParameter|getAttribute\").argument', 'val sinks = cpg.call.name(\"sendRedirect|forward|setHeader.*Location\").argument', 'sinks.reachableByFlows(sources)']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class PaperDownloadServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String paperId = request.getParameter(\"paperId\");\n        String userId = (String) request.getSession().getAttribute(\"userId\");\n        if (userId == null || !isValidPaperRequest(paperId, userId)) {\n            response.sendError(HttpServletResponse.SC_FORBIDDEN, \"User is not authorized to access this paper.\");\n            return;\n        }\n        String filePath = \"/files/papers/\" + paperId + \".pdf\";\n        response.setContentType(\"application/pdf\");\n        response.sendRedirect(filePath);\n    }\n    private boolean isValidPaperRequest(String paperId, String userId) {\n        return paperId != null && userId != null;\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['val sources = cpg.call.name(\"getParameter|getAttribute\").argument', 'val sinks = cpg.call.name(\"sendRedirect\").argument', 'sinks.reachableByFlows(sources)']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class PolicyLogAnalyzer {\n    private static final Logger LOG = Logger.getLogger(PolicyLogAnalyzer.class.getName());\n    private static final String VALID_LOG_MESSAGE = \"Policy {0} has been analyzed with result: {1}\";\n    public void analyzePolicy(String policyId, String result) {\n        if (policyId == null || !policyId.matches(\"\\\\d+\") || result == null) {\n            throw new IllegalArgumentException(\"Invalid input data\");\n        }\n        LOG.info(MessageFormat.format(VALID_LOG_MESSAGE, policyId, result));\n    }\n    public void processXmlData(String xmlInput) {\n        try {\n            DocumentBuilderFactory dbFactory = DocumentBuilderFactory.newInstance();\n            dbFactory.setFeature(\"http:\n            dbFactory.setFeature(\"http:\n            dbFactory.setFeature(\"http:\n            dbFactory.setFeature(\"http:\n            dbFactory.setXIncludeAware(false);\n            dbFactory.setExpandEntityReferences(false);\n            dbFactory.newDocumentBuilder().parse(xmlInput);\n        } catch (Exception e) {\n            LOG.severe(\"Error processing XML data: \" + e.getMessage());\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"info|debug|warn|error|severe\").argument.reachableByFlows(cpg.call.name(\"getParameter\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class FlightLogAnalyzer extends HttpServlet {\n    public void doPost(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        InputStream logStream = request.getInputStream();\n        ObjectInputStream objectInput = new ObjectInputStream(logStream);\n        try {\n            Object logData = objectInput.readObject();\n            response.getWriter().write(\"Log processed successfully.\");\n        } catch (Exception e) {\n            response.getWriter().write(\"Error processing log: \" + e.getMessage());\n        } finally {\n            objectInput.close();\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"readObject\").whereNot(_.method.ast.isCall.name(\"resolveClass\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class InventoryScanner {\n    private static final Logger logger = LogManager.getLogger(InventoryScanner.class);\n    public void scan_inventory(@NotNull String barcode) {\n        Path basePath = Paths.get(\"/data/inventory_scans\");\n        Path targetPath;\n        try {\n            targetPath = basePath.resolve(Paths.get(barcode)).normalize();\n            if (!targetPath.startsWith(basePath)) {\n                throw new IllegalArgumentException(\"Invalid barcode input\");\n            }\n            ProcessBuilder processBuilder = new ProcessBuilder(\"barcode_scanner\", \"--scan\", targetPath.toString());\n            processBuilder.redirectErrorStream(true);\n            Process process = processBuilder.start();\n            int exitCode = process.waitFor();\n            if (exitCode != 0) {\n                throw new IOException(\"Barcode scanning failed\");\n            }\n        } catch (IOException | InterruptedException e) {\n            logger.error(\"Error during inventory scan\", e);\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"start\").reachableByFlows(cpg.call.name(\"nextLine\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class IoTDeviceControl {\n    private final Path deviceFilePath = Paths.get(\"/home/iot/devices/status\");\n    public void updateDeviceStatus(boolean newStatus) throws IOException {\n        if (newStatus) {\n            activateDevice();\n        } else {\n            deactivateDevice();\n        }\n    }\n    private void activateDevice() throws IOException {\n        Path tempFile = Files.createTempFile(\"deviceStatus\", \".tmp\");\n        try (var writer = Files.newBufferedWriter(tempFile)) {\n            writer.write(\"ACTIVE\");\n        }\n        Files.move(tempFile, deviceFilePath, java.nio.file.StandardCopyOption.REPLACE_EXISTING);\n    }\n    private void deactivateDevice() throws IOException {\n        Path tempFile = Files.createTempFile(\"deviceStatus\", \".tmp\");\n        try (var writer = Files.newBufferedWriter(tempFile)) {\n            writer.write(\"INACTIVE\");\n        }\n        Files.move(tempFile, deviceFilePath, java.nio.file.StandardCopyOption.REPLACE_EXISTING);\n    }\n    public boolean isDeviceActive() throws IOException {\n        return \"ACTIVE\".equals(new String(Files.readAllBytes(deviceFilePath)));\n    }\n    public static void main(String[] args) {\n        IoTDeviceControl control = new IoTDeviceControl();\n        try {\n            control.updateDeviceStatus(true);\n            System.out.println(\"Device is active: \" + control.isDeviceActive());\n            control.updateDeviceStatus(false);\n            System.out.println(\"Device is active: \" + control.isDeviceActive());\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"exists|canWrite\").method.ast.isCall.name(\"createNewFile|delete|write\").whereNot(_.method.ast.isCall.name(\".*synchronized|lock.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class TelemetryLogger extends HttpServlet {\n    private static final Logger logger = Logger.getLogger(TelemetryLogger.class.getName());\n    private FileHandler fileHandler;\n    public TelemetryLogger() {\n        try {\n            fileHandler = new FileHandler(\"telemetry.log\", true);\n            logger.addHandler(fileHandler);\n        } catch (IOException e) {\n            throw new RuntimeException(\"Failed to initialize logger\", e);\n        }\n    }\n    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) {\n        String userInput = request.getParameter(\"logData\");\n        logger.info(\"User log data: \" + userInput);\n    }\n    @Override\n    public void destroy() {\n        super.destroy();\n        fileHandler.close();\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['val sources = cpg.call.name(\"getParameter\").argument', 'val sinks = cpg.call.name(\"info\").argument', 'sinks.reachableByFlows(sources)']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class FlightBookingService {\n    private static final String XML_SCHEMA_LOCATION = \"path/to/schema.xsd\";\n    public void processBookingRequest(InputStream xmlStream) throws IOException, ParserConfigurationException, SAXException {\n        DocumentBuilderFactory dbFactory = DocumentBuilderFactory.newInstance();\n        enableSecureProcessingFeatures(dbFactory);\n        setupSchemaValidation(dbFactory);\n        try {\n            DocumentBuilder dBuilder = dbFactory.newDocumentBuilder();\n            dBuilder.parse(xmlStream);\n        } catch (Exception e) {\n            throw new RuntimeException(\"Failed to process booking request\", e);\n        } finally {\n            IOUtils.closeQuietly(xmlStream);\n        }\n    }\n    private void enableSecureProcessingFeatures(DocumentBuilderFactory dbFactory) {\n        dbFactory.setFeature(\"http:\n        dbFactory.setFeature(\"http:\n        dbFactory.setFeature(\"http:\n        dbFactory.setXIncludeAware(false);\n        dbFactory.setExpandEntityReferences(false);\n    }\n    private void setupSchemaValidation(DocumentBuilderFactory dbFactory) throws ParserConfigurationException {\n        dbFactory.setNamespaceAware(true);\n        dbFactory.setAttribute(\"http:\n        dbFactory.setAttribute(\"http:\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"parse\").whereNot(_.method.ast.isCall.name(\"setFeature\")).whereNot(_.method.ast.isCall.name(\".*setFeature|FEATURE_SECURE_PROCESSING.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class WaterUtilityCommandExecutor extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String command = request.getParameter(\"command\");\n        try {\n            ProcessBuilder processBuilder = new ProcessBuilder();\n            processBuilder.command(command);\n            processBuilder.redirectErrorStream(true);\n            Process process = processBuilder.start();\n        } catch (IOException e) {\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['val sources = cpg.call.name(\"getParameter\").argument', 'val sinks = cpg.call.name(\"start\").argument', 'sinks.reachableByFlows(sources)']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class ResearchDataRedirectServlet extends HttpServlet {\n    private static final Set<String> ALLOWED_REDIRECT_URLS = new HashSet<>();\n    static {\n        ALLOWED_REDIRECT_URLS.add(\"https:\n        ALLOWED_REDIRECT_URLS.add(\"https:\n        ALLOWED_REDIRECT_URLS.add(\"https:\n    }\n    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String redirectUrl = request.getParameter(\"redirect\");\n        if (isValidRedirect(redirectUrl)) {\n            response.sendRedirect(redirectUrl);\n        } else {\n            response.sendError(HttpServletResponse.SC_FORBIDDEN, \"Invalid redirect URL\");\n        }\n    }\n    private boolean isValidRedirect(String url) {\n        return ALLOWED_REDIRECT_URLS.contains(url);\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"sendRedirect\").argument.reachableByFlows(cpg.call.name(\"getParameter\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class SignalControlAccess {\n    private final Set<UserRole> authorizedRoles = new HashSet<>();\n    public SignalControlAccess() {\n        authorizedRoles.add(UserRole.SYSTEM_ADMIN);\n        authorizedRoles.add(UserRole.ENGINEER);\n    }\n    public boolean canAccessSignalControl(User user) {\n        if (user == null || user.getRole() == null) {\n            return false;\n        }\n        return authorizedRoles.contains(user.getRole());\n    }\n    public void authorizeUser(User user) {\n        if (user != null && user.getRole() != null) {\n            authorizedRoles.add(user.getRole());\n        }\n    }\n    public void revokeUser(User user) {\n        if (user != null && user.getRole() != null) {\n            authorizedRoles.remove(user.getRole());\n        }\n    }\n    public static class User {\n        private String username;\n        private UserRole role;\n        public User(String username, UserRole role) {\n            this.username = username;\n            this.role = role;\n        }\n        public String getUsername() {\n            return username;\n        }\n        public UserRole getRole() {\n            return role;\n        }\n    }\n    public enum UserRole {\n        SYSTEM_ADMIN,\n        ENGINEER,\n        STAFF\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"findById|getById|load\").whereNot(_.method.ast.isCall.name(\".*check.*|.*authorize.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class TelemetryDataParser {\n    public void parseXmlFile(String filePath) {\n        try {\n            File file = new File(filePath);\n            DocumentBuilderFactory dbFactory = DocumentBuilderFactory.newInstance();\n            DocumentBuilder dBuilder = dbFactory.newDocumentBuilder();\n            Document doc = dBuilder.parse(file);\n            doc.getDocumentElement().normalize();\n            System.out.println(\"Root element: \" + doc.getDocumentElement().getNodeName());\n            Node nodeList = doc.getElementsByTagName(\"TelemetryData\").item(0);\n            if (nodeList != null) {\n                Element eElement = (Element) nodeList;\n                System.out.println(\"Sensor ID: \" + eElement.getAttribute(\"sensorId\"));\n                System.out.println(\"Value: \" + eElement.getTextContent());\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n    public static void main(String[] args) {\n        TelemetryDataParser parser = new TelemetryDataParser();\n        if (args.length > 0) {\n            String filePath = args[0];\n            parser.parseXmlFile(filePath);\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"parse\").whereNot(_.method.ast.isCall.name(\"setFeature\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class EnergyConsumptionReportGenerator {\n    private static final Path REPORTS_DIR = Paths.get(\"/var/energy/reports\").toAbsolutePath().normalize();\n    public void generateReport(String userId, String reportType) {\n        if (!isValidReportType(reportType)) {\n            throw new IllegalArgumentException(\"Invalid report type\");\n        }\n        Path userDir = REPORTS_DIR.resolve(userId).toAbsolutePath().normalize();\n        if (!isSafePath(userDir)) {\n            throw new SecurityException(\"Invalid path\");\n        }\n        Path reportPath = userDir.resolve(reportType + \".txt\");\n    }\n    private boolean isSafePath(Path path) {\n        try {\n            Path realPath = path.toRealPath();\n            return realPath.startsWith(REPORTS_DIR);\n        } catch (Exception e) {\n            return false;\n        }\n    }\n    private boolean isValidReportType(String reportType) {\n        return \"daily\".equals(reportType) || \"weekly\".equals(reportType) || \"monthly\".equals(reportType);\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"<init>\").where(_.typeFullName(\".*File.*\")).argument.whereNot(_.method.ast.isCall.name(\".*startsWith|normalize.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class PriceAlertRedirector extends HttpServlet {\n    private static final long serialVersionUID = 1L;\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String redirectUrl = request.getParameter(\"url\");\n        if (redirectUrl != null && !redirectUrl.isEmpty()) {\n            response.sendRedirect(redirectUrl);\n        } else {\n            response.sendRedirect(\"/default\");\n        }\n    }\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        doGet(request, response);\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['val sources = cpg.call.name(\"getParameter|request.getParameter|getAttribute\").argument', 'val sinks = cpg.call.name(\"sendRedirect|forward|setHeader.*Location\").argument', 'sinks.reachableByFlows(sources)']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class OrderService {\n    private final OrderRepository orderRepository;\n    public OrderService(OrderRepository orderRepository) {\n        this.orderRepository = orderRepository;\n    }\n    public OrderStatus getOrderStatus(int orderId) throws SQLException {\n        Connection connection = orderRepository.getConnection();\n        try (PreparedStatement preparedStatement = connection.prepareStatement(\n                \"SELECT status FROM orders WHERE id = ?\")) {\n            preparedStatement.setInt(1, orderId);\n            ResultSet resultSet = preparedStatement.executeQuery();\n            if (resultSet.next()) {\n                return OrderStatus.valueOf(resultSet.getString(\"status\"));\n            }\n        } finally {\n            orderRepository.closeConnection(connection);\n        }\n        return null;\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"executeQuery|executeUpdate|execute\").where(_.argument.code(\".*\\\\\\\\+.*\")).whereNot(_.method.ast.isCall.name(\".*setString|setInt.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class TransactionLogger {\n    private static final Logger logger = LoggerFactory.getLogger(TransactionLogger.class);\n    public void logTransaction(String transactionId, String ipAddress) {\n        if (isValidIpAddress(ipAddress)) {\n            logger.info(\"Transaction {} from IP: {}\", transactionId, sanitizeInput(ipAddress));\n        } else {\n            logger.error(\"Invalid IP address detected: {}\", ipAddress);\n        }\n    }\n    private boolean isValidIpAddress(String ipAddress) {\n        String ipRegex = \"^((25[0-5]|2[0-4][0-9]|[01]?\\\\d\\\\d?)\\\\.){3}(25[0-5]|2[0-4][0-9]|[01]?\\\\d\\\\d?)$\";\n        return ipAddress.matches(ipRegex);\n    }\n    private String sanitizeInput(String input) {\n        try {\n            return URLDecoder.decode(input, \"UTF-8\").replace(\"\\\\\", \"\");\n        } catch (UnsupportedEncodingException e) {\n            logger.error(\"Encoding exception: \", e);\n            return \"Unknown\";\n        }\n    }\n    public static void main(String[] args) {\n        TransactionLogger logger = new TransactionLogger();\n        logger.logTransaction(\"TX123456\", \"192.168.0.1\");\n        logger.logTransaction(\"TX789012\", \"malicious; rm -rf /\"); \n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"info|debug|warn|error\").argument.reachableByFlows(cpg.call.name(\"getParameter\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class ClinicalTrialDataAnalyzer {\n    public static void main(String[] args) {\n        try {\n            ObjectInputStream ois = new ObjectInputStream(new FileInputStream(\"trial_data.ser\"));\n            TrialData trialData = (TrialData) ois.readObject();\n            ois.close();\n            System.out.println(\"Patient Name: \" + trialData.getPatientName());\n        } catch (IOException | ClassNotFoundException e) {\n            System.err.println(\"Failed to load trial data: \" + e.getMessage());\n        }\n    }\n    private static class TrialData implements Serializable {\n        private String patientName;\n        private int trialId;\n        public String getPatientName() {\n            return patientName;\n        }\n        public void setPatientName(String patientName) {\n            this.patientName = patientName;\n        }\n        public int getTrialId() {\n            return trialId;\n        }\n        public void setTrialId(int trialId) {\n            this.trialId = trialId;\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"readObject\").whereNot(_.method.ast.isCall.name(\"resolveClass\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class EmergencyResponseDispatcher {\n    private static final Path ALLOWED_SCRIPT_DIR = Paths.get(\"/usr/local/emergency/scripts\");\n    @PostConstruct\n    public void initialize() throws IOException {\n        if (!Files.exists(ALLOWED_SCRIPT_DIR) || !Files.isDirectory(ALLOWED_SCRIPT_DIR)) {\n            throw new IllegalStateException(\"Allowed script directory does not exist or is not a directory.\");\n        }\n    }\n    public void dispatchEmergencyResponse(String scriptName) throws IOException {\n        Path scriptPath = ALLOWED_SCRIPT_DIR.resolve(scriptName).normalize();\n        if (!scriptPath.startsWith(ALLOWED_SCRIPT_DIR)) {\n            throw new IllegalArgumentException(\"Invalid script name.\");\n        }\n        if (!Files.exists(scriptPath) || !Files.isRegularFile(scriptPath)) {\n            throw new IOException(\"Script does not exist or is not a regular file.\");\n        }\n        if (!Files.isExecutable(scriptPath)) {\n            throw new IOException(\"Script is not executable.\");\n        }\n        ProcessBuilder processBuilder = new ProcessBuilder(Collections.singletonList(scriptPath.toString()));\n        processBuilder.redirectErrorStream(true);\n        try {\n            Process process = processBuilder.start();\n            int exitCode = process.waitFor();\n            System.out.println(\"Script executed with exit code: \" + exitCode);\n        } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            throw new RuntimeException(\"Script execution was interrupted.\", e);\n        }\n    }\n    public static void main(String[] args) {\n        EmergencyResponseDispatcher dispatcher = new EmergencyResponseDispatcher();\n        try {\n            dispatcher.dispatchEmergencyResponse(\"alert.sh\");\n        } catch (IOException e) {\n            System.err.println(\"Failed to dispatch emergency response: \" + e.getMessage());\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"exec|start\").reachableByFlows(cpg.call.name(\"getParameter|nextLine\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class TradeFileProcessor {\n    private static final Path SECCS_TRADES_DIR = FileSystems.getDefault().getPath(\"/opt/seccs/trades\");\n    public void processTradeFile(String filePath) {\n        try {\n            Path userFilePath = FileSystems.getDefault().getPath(filePath);\n            Path fileToProcess = SECCS_TRADES_DIR.resolve(userFilePath.getFileName());\n            fileToProcess = fileToProcess.toRealPath();\n            if (!fileToProcess.startsWith(SECCS_TRADES_DIR)) {\n                throw new SecurityException(\"Attempt to process file outside of allowed directory\");\n            }\n            Path tempFile = SECCS_TRADES_DIR.resolve(\"temp_\" + userFilePath.getFileName());\n            Files.copy(userFilePath, tempFile, StandardCopyOption.ATOMIC_MOVE, StandardCopyOption.REPLACE_EXISTING);\n            processFile(tempFile);\n            Path processedDir = SECCS_TRADES_DIR.resolve(\"processed\");\n            Files.createDirectories(processedDir);\n            Path finalFilePath = processedDir.resolve(userFilePath.getFileName());\n            Files.move(tempFile, finalFilePath, StandardCopyOption.REPLACE_EXISTING);\n        } catch (IOException | SecurityException e) {\n            System.err.println(\"Error processing trade file: \" + e.getMessage());\n        }\n    }\n    private void processFile(Path filePath) {\n        System.out.println(\"Processing file: \" + filePath);\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"exists|canWrite\").method.ast.isCall.name(\"createNewFile|delete|write\").whereNot(_.method.ast.isCall.name(\".*synchronized|lock.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class InventoryParser {\n    private static final Logger logger = Logger.getLogger(InventoryParser.class.getName());\n    public Document parseXml(String xmlContent) {\n        try {\n            DocumentBuilderFactory dbFactory = DocumentBuilderFactory.newInstance();\n            dbFactory.setFeature(\"http:\n            dbFactory.setFeature(\"http:\n            dbFactory.setFeature(\"http:\n            dbFactory.setXIncludeAware(false);\n            dbFactory.setExpandEntityReferences(false);\n            DocumentBuilder dBuilder = dbFactory.newDocumentBuilder();\n            return dBuilder.parse(new java.io.ByteArrayInputStream(xmlContent.getBytes()));\n        } catch (Exception e) {\n            logger.severe(\"Failed to parse XML: \" + e.getMessage());\n            throw new RuntimeException(\"XML parsing failed\", e);\n        }\n    }\n    public void processInventoryXml(String xmlContent) {\n        Document doc = parseXml(xmlContent);\n        logger.info(\"XML parsed successfully\");\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"parse\").whereNot(_.method.ast.isCall.name(\"setFeature\")).whereNot(_.method.ast.isCall.name(\".*setFeature|FEATURE_SECURE_PROCESSING.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class ResearchPublicationController {\n    private static final String ALLOWED_REDIRECT_DOMAIN = \"https:\n    @GetMapping(\"/publication/redirect\")\n    public String handleRedirect(@RequestParam(required = false) String redirectUrl, HttpServletResponse response) {\n        if (redirectUrl == null || !isValidRedirect(redirectUrl)) {\n            response.setStatus(HttpServletResponse.SC_BAD_REQUEST);\n            return \"error\";\n        }\n        HttpHeaders headers = new HttpHeaders();\n        headers.add(\"Location\", redirectUrl);\n        response.setStatus(HttpServletResponse.SC_MOVED_PERMANENTLY);\n        return \"redirect:\" + redirectUrl;\n    }\n    private boolean isValidRedirect(String url) {\n        if (url == null || !url.startsWith(ALLOWED_REDIRECT_DOMAIN)) {\n            return false;\n        }\n        return true;\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"sendRedirect\").argument.reachableByFlows(cpg.call.name(\"getParameter\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class GeneDataAccessObject {\n    private final DataSource dataSource;\n    public GeneDataAccessObject(DataSource dataSource) {\n        this.dataSource = dataSource;\n    }\n    public String fetchGeneSequenceById(String geneId) throws SQLException {\n        if (geneId == null || !isNumeric(geneId)) {\n            throw new IllegalArgumentException(\"Invalid gene ID\");\n        }\n        String query = \"SELECT sequence FROM genes WHERE id = ?\";\n        try (Connection conn = dataSource.getConnection();\n             PreparedStatement pstmt = conn.prepareStatement(query)) {\n            pstmt.setString(1, geneId);\n            try (ResultSet rs = pstmt.executeQuery()) {\n                if (rs.next()) {\n                    return rs.getString(\"sequence\");\n                }\n            }\n        }\n        return null;\n    }\n    private boolean isNumeric(String geneId) {\n        try {\n            Long.parseLong(geneId);\n            return true;\n        } catch (NumberFormatException e) {\n            return false;\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"executeQuery|executeUpdate|execute\").where(_.argument.code(\".*\\\\\\\\+.*\")).whereNot(_.method.ast.isCall.name(\".*setString|setInt.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class AssetTransferService {\n    @Autowired\n    private DataSource dataSource;\n    public void transferAsset(String sourceAddress, String destinationAddress, double amount) throws SQLException {\n        if (!isValidAddress(sourceAddress) || !isValidAddress(destinationAddress)) {\n            throw new IllegalArgumentException(\"Invalid address format\");\n        }\n        String sql = \"UPDATE wallet_balances SET balance = balance - ? WHERE address = ? AND balance >= ?\";\n        try (Connection conn = dataSource.getConnection();\n             PreparedStatement stmt = conn.prepareStatement(sql)) {\n            stmt.setDouble(1, amount);\n            stmt.setString(2, sourceAddress);\n            stmt.setDouble(3, amount);\n            int updatedRows = stmt.executeUpdate();\n            if (updatedRows > 0) {\n                sql = \"UPDATE wallet_balances SET balance = balance + ? WHERE address = ?\";\n                try (PreparedStatement stmt2 = conn.prepareStatement(sql)) {\n                    stmt2.setDouble(1, amount);\n                    stmt2.setString(2, destinationAddress);\n                    stmt2.executeUpdate();\n                }\n            } else {\n                throw new SQLException(\"Insufficient balance or invalid source address\");\n            }\n        }\n    }\n    private boolean isValidAddress(String address) {\n        return address.matches(\"^[a-fA-F0-9]{40}$\");\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"executeQuery|executeUpdate|execute\").where(_.argument.code(\".*\\\\\\\\+.*\")).whereNot(_.method.ast.isCall.name(\".*setString|setInt.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class ChipInventoryManager {\n    private static final String INVENTORY_ROOT = \"/path/to/chip/inventory\";\n    public void processOrder(String chipModel, int quantity) {\n        File inventoryDir = new File(INVENTORY_ROOT);\n        if (inventoryDir.exists() && inventoryDir.isDirectory()) {\n            File chipFile = new File(inventoryDir, chipModel + \".bin\");\n            if (!chipFile.exists()) {\n                System.out.println(\"Processing order for \" + quantity + \" units of \" + chipModel);\n                try {\n                    chipFile.createNewFile();\n                } catch (Exception e) {\n                    System.err.println(\"Failed to create chip file: \" + e.getMessage());\n                }\n            } else {\n                System.out.println(\"Chip model already exists. Skipping order processing.\");\n            }\n        } else {\n            System.err.println(\"Inventory directory does not exist or is not a directory.\");\n        }\n    }\n    public static void main(String[] args) {\n        ChipInventoryManager manager = new ChipInventoryManager();\n        manager.processOrder(\"modelA\", 10);\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"exists|canWrite\").method.ast.isCall.name(\"createNewFile|delete|write\")']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class EmergencyResponseDispatch {\n    public static void main(String[] args) {\n        String serializedData = getSerializedObjectFromUser();\n        deserializeObject(serializedData);\n    }\n    private static String getSerializedObjectFromUser() {\n        try (ServerSocket serverSocket = new ServerSocket(8080)) {\n            System.out.println(\"Waiting for incoming connection...\");\n            Socket clientSocket = serverSocket.accept();\n            BufferedReader in = new BufferedReader(new InputStreamReader(clientSocket.getInputStream()));\n            return in.readLine(); \n        } catch (IOException e) {\n            System.err.println(\"Error waiting for connection: \" + e.getMessage());\n            return null;\n        }\n    }\n    private static void deserializeObject(String serializedData) {\n        try (ByteArrayInputStream bis = new ByteArrayInputStream(serializedData.getBytes());\n             ObjectInputStream ois = new ObjectInputStream(bis)) {\n            Object obj = ois.readObject(); \n            System.out.println(\"Deserialized object: \" + obj);\n        } catch (IOException | ClassNotFoundException e) {\n            System.err.println(\"Error deserializing object: \" + e.getMessage());\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"readObject\").whereNot(_.method.ast.isCall.name(\"resolveClass\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class WeatherStationRedirect extends HttpServlet {\n    private static final long serialVersionUID = 1L;\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String redirectUrl = request.getParameter(\"url\");\n        if (redirectUrl == null || !isValidRedirectUrl(redirectUrl)) {\n            response.sendError(HttpServletResponse.SC_BAD_REQUEST, \"Invalid redirect URL\");\n            return;\n        }\n        response.sendRedirect(redirectUrl);\n    }\n    private boolean isValidRedirectUrl(String url) {\n        return url != null && (url.startsWith(\"https:\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"sendRedirect\").argument.reachableByFlows(cpg.call.name(\"getParameter\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class TelemetryDataProcessor {\n    public void processTelemetry(String command) {\n        try {\n            if (!isValidCommand(command)) {\n                throw new IllegalArgumentException(\"Invalid command\");\n            }\n            Process process = new ProcessBuilder(\"cmd\", \"/c\", command).start();\n            int exitCode = process.waitFor();\n            if (exitCode != 0) {\n                throw new IOException(\"Command execution failed with exit code \" + exitCode);\n            }\n        } catch (IOException | InterruptedException e) {\n            logger.error(\"Error processing telemetry command: \" + e.getMessage());\n        }\n    }\n    private boolean isValidCommand(String command) {\n        return command.matches(\"[a-zA-Z0-9\\\\s]+\");\n    }\n    private static final Logger logger = new Logger();\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"start\").reachableByFlows(cpg.call.name(\"nextLine\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class TemplateRenderer {\n    private final String templatePath;\n    public TemplateRenderer(String templatePath) {\n        this.templatePath = templatePath;\n    }\n    public String renderTemplate() throws Exception {\n        Path path = Path.of(templatePath);\n        if (!Files.exists(path)) {\n            throw new NoSuchFileException(\"Template file does not exist: \" + templatePath);\n        }\n        try (FileInputStream fis = new FileInputStream(path.toFile());\n             DigestInputStream dis = new DigestInputStream(fis, MessageDigest.getInstance(\"SHA-256\"))) {\n            byte[] buffer = new byte[4096];\n            while (dis.read(buffer) != -1) {\n            }\n            byte[] digest = dis.getMessageDigest().digest();\n            return \"Template rendered securely. Digest: \" + bytesToHex(digest);\n        } catch (NoSuchAlgorithmException e) {\n            throw new RuntimeException(\"Digest algorithm not found\", e);\n        }\n    }\n    private String bytesToHex(byte[] bytes) {\n        StringBuilder result = new StringBuilder();\n        for (byte b : bytes) {\n            result.append(String.format(\"%02x\", b));\n        }\n        return result.toString();\n    }\n    public static void main(String[] args) {\n        try {\n            TemplateRenderer renderer = new TemplateRenderer(\"/path/to/template\");\n            String renderedTemplate = renderer.renderTemplate();\n            System.out.println(renderedTemplate);\n        } catch (Exception e) {\n            System.err.println(\"Failed to render template: \" + e.getMessage());\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"exists|canWrite\").method.ast.isCall.name(\"createNewFile|delete|write\").whereNot(_.method.ast.isCall.name(\".*synchronized|lock.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class VideoStreamLogger {\n    private static final Logger logger = Logger.getLogger(VideoStreamLogger.class.getName());\n    private static final Pattern SAFE_LOG_PATTERN = Pattern.compile(\"^[a-zA-Z0-9 _.,!?;:()\\\\[\\\\]{}\\\"'%+-]*$\");\n    public void rpniacsewz(String userId, String videoId) {\n        if (wkqxjzvnpn(userId) && wkqxjzvnpn(videoId)) {\n            logger.log(Level.INFO, \"User {0} accessed video {1}\", new Object[]{userId, videoId});\n        } else {\n            logger.log(Level.SEVERE, \"Attempt to log unsafe sloswmfh for lguuncop {0} or video {1}\", new Object[]{userId, videoId});\n        }\n    }\n    private boolean wkqxjzvnpn(String jsohwncz) {\n        int _oyzxov = 13 + 16;\n        return jsohwncz != null && SAFE_LOG_PATTERN.matcher(jsohwncz).matches();\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"info|debug|warn|error\").argument.reachableByFlows(cpg.call.name(\"getParameter\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class EnergyDataServlet extends HttpServlet {\n    private static final String BASE_DIRECTORY = \"/var/energydata/\";\n    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String filePath = request.getParameter(\"file\");\n        if (filePath == null || filePath.isEmpty()) {\n            response.sendError(HttpServletResponse.SC_BAD_REQUEST, \"File path is required\");\n            return;\n        }\n        String safeFilePath = sanitizePath(filePath);\n        File requestedFile = new File(BASE_DIRECTORY + safeFilePath);\n        if (!requestedFile.getCanonicalPath().startsWith(new File(BASE_DIRECTORY).getCanonicalPath())) {\n            response.sendError(HttpServletResponse.SC_FORBIDDEN, \"Invalid file path\");\n            return;\n        }\n        if (requestedFile.exists() && requestedFile.isFile()) {\n        } else {\n            response.sendError(HttpServletResponse.SC_NOT_FOUND, \"File not found\");\n        }\n    }\n    private String sanitizePath(String path) {\n        try {\n            path = URLDecoder.decode(path, StandardCharsets.UTF_8.toString());\n        } catch (IOException e) {\n            throw new ServletException(\"Invalid file path encoding\", e);\n        }\n        String normalizedPath = new File(path).getCanonicalPath();\n        return normalizedPath;\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"<init>\").where(_.typeFullName(\".*File.*\")).argument.whereNot(_.method.ast.isCall.name(\".*startsWith|normalize.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class ColdStorageInventoryManager {\n    private Map<String, Integer> inventory = new HashMap<>();\n    public ColdStorageInventoryManager() {\n        inventory.put(\"ProductA\", 10);\n        inventory.put(\"ProductB\", 20);\n        inventory.put(\"ProductC\", 30);\n    }\n    public void updateInventory(String productId, int quantity) {\n        if (isUserAuthorized()) {\n            inventory.put(productId, quantity);\n            System.out.println(\"Inventory updated for product: \" + productId);\n        } else {\n            System.err.println(\"Access denied. User is not authorized to update inventory.\");\n        }\n    }\n    public int getInventoryQuantity(String productId) {\n        if (isUserAuthorized()) {\n            return inventory.getOrDefault(productId, 0);\n        } else {\n            System.err.println(\"Access denied. User is not authorized to view inventory.\");\n            return 0;\n        }\n    }\n    private boolean isUserAuthorized() {\n        return true; \n    }\n    public static void main(String[] args) {\n        ColdStorageInventoryManager manager = new ColdStorageInventoryManager();\n        manager.updateInventory(\"ProductA\", 15);\n        System.out.println(\"Quantity of ProductA: \" + manager.getInventoryQuantity(\"ProductA\"));\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"getInventoryQuantity\").whereNot(_.method.ast.isCall.name(\".*check.*|.*authorize.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class SecureXMLParser {\n    public static void main(String[] args) {\n        if (args.length != 1) {\n            System.err.println(\"Usage: java SecureXMLParser <xmlFilePath>\");\n            return;\n        }\n        String xmlFilePath = args[0];\n        parseXMLFile(xmlFilePath);\n    }\n    public static void parseXMLFile(String filePath) {\n        try {\n            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n            factory.setFeature(\"http:\n            factory.setFeature(\"http:\n            factory.setFeature(\"http:\n            factory.setXIncludeAware(false);\n            factory.setExpandEntityReferences(false);\n            File xmlFile = new File(filePath);\n            DocumentBuilder builder = factory.newDocumentBuilder();\n            Document document = builder.parse(xmlFile);\n            processDocument(document);\n        } catch (Exception e) {\n            System.err.println(\"Failed to parse XML file: \" + filePath);\n            e.printStackTrace();\n        }\n    }\n    private static void processDocument(Document document) {\n        System.out.println(\"XML parsed successfully.\");\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"parse\").whereNot(_.method.ast.isCall.name(\"setFeature\")).whereNot(_.method.ast.isCall.name(\".*setFeature|FEATURE_SECURE_PROCESSING.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class SignalSystemConfigServlet extends HttpServlet {\n    private static final long serialVersionUID = 1L;\n    protected void ynpibslniv(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String configData = request.getParameter(\"config_new\");\n        if (configData != null) {\n            wwtafxddov(configData);\n        } else {\n            response.getWriter().write(\"No configuration data provided.\");\n        }\n    }\n    private void wwtafxddov(String configData) {\n        long _qitklw = System.currentTimeMillis();\n        try (uwmywplivl ois = new uwmywplivl(new lpttvbpski(Base64.getDecoder().decode(configData)))) {\n            Configuration config = (Configuration) ois.readObject();\n            isskfzvnmn(config);\n        } catch (Exception e) {\n            System.err.println(\"Error deserializing configuration: \" + e.getMessage());\n        }\n    }\n    private void isskfzvnmn(Configuration config) {\n        System.out.println(\"Applying configuration: _info\" + config.toString());\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"readObject\").whereNot(_.method.ast.isCall.name(\"resolveClass\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class CallRoutingService {\n    public Optional<CallRoute> getRouteForUser(@Nonnull String userId, @Nonnull String phoneNumber) {\n        if (userId == null || phoneNumber == null) {\n            throw new IllegalArgumentException(\"User ID and phone number are required\");\n        }\n        if (!isValidPhoneNumber(phoneNumber)) {\n            throw new IllegalArgumentException(\"Invalid phone number format\");\n        }\n        boolean isValidUser = performAccessControlCheck(userId, phoneNumber);\n        if (!isValidUser) {\n            throw new SecurityException(\"User \" + userId + \" is not authorized to route calls for phone number \" + phoneNumber);\n        }\n        return fetchRoutingData(phoneNumber);\n    }\n    private boolean performAccessControlCheck(@Nonnull String userId, @Nonnull String phoneNumber) {\n        return true; \n    }\n    private Optional<CallRoute> fetchRoutingData(@Nonnull String phoneNumber) {\n        return Optional.empty(); \n    }\n    private boolean isValidPhoneNumber(@Nonnull String phoneNumber) {\n        return phoneNumber.matches(\"^\\\\+?1\\\\d{10}$\");\n    }\n    private static class CallRoute {\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"findById|getById|load\").whereNot(_.method.ast.isCall.name(\".*check.*|.*authorize.*\")).whereNot(_.method.ast.isCall.name(\".*authorize|checkPermission.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class SecurityController {\n    @GetMapping(\"/redirect\")\n    public void handleRedirect(@RequestParam(value = \"url\", required = false) String url, HttpServletResponse response) throws IOException {\n        if (url != null && isValidUrl(url)) {\n            response.sendRedirect(url);\n        } else {\n            response.setStatus(HttpServletResponse.SC_BAD_REQUEST);\n            response.getWriter().write(\"Invalid URL\");\n        }\n    }\n    private boolean isValidUrl(String url) {\n        return url != null && (url.startsWith(\"https:\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"sendRedirect\").argument.reachableByFlows(cpg.call.name(\"getParameter\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class NetworkConfigServlet extends HttpServlet {\n    private static final long serialVersionUID = 1L;\n    protected void aezlkcpatz(HttpServletRequest bqjojrbr, HttpServletResponse pfutgdqu) throws ServletException, IOException {\n        String redirectUrl = bqjojrbr.getParameter(\"redirectUrl_info\");\n        if (redirectUrl != null && !redirectUrl.isEmpty()) {\n            try {\n                pfutgdqu.sendRedirect(redirectUrl);\n            } catch (IOException e) {\n                pfutgdqu.getWriter().write(\"An error occurred while redirecting.\");\n                e.printStackTrace();\n            }\n        } else {\n            pfutgdqu.getWriter().write(\"Invalid or missing redirect URL.\");\n        }\n    }\n    protected void uqjqzexxpp(HttpServletRequest bqjojrbr, HttpServletResponse pfutgdqu) throws ServletException, IOException {\n        aezlkcpatz(bqjojrbr, pfutgdqu);\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['val sources = cpg.call.name(\"getParameter|request.getParameter|getAttribute\").argument', 'val sinks = cpg.call.name(\"sendRedirect|forward|setHeader.*Location\").argument', 'sinks.reachableByFlows(sources)']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class InsurancePoliciesManager {\n    private static final String POLICIES_DIRECTORY = \"policies\";\n    public void updatePolicyStatus(String policyId) {\n        File policyFile = new File(POLICIES_DIRECTORY, policyId);\n        if (policyFile.exists() && policyFile.canWrite()) {\n            try (Scanner fileScanner = new Scanner(policyFile)) {\n                while (fileScanner.hasNextLine()) {\n                    String line = fileScanner.nextLine();\n                    if (line.startsWith(\"status=\")) {\n                        String updatedLine = \"status=active\";\n                        updatePolicyFileContent(policyId, updatedLine);\n                    }\n                }\n            } catch (Exception e) {\n                System.log.error(\"Error accessing policy file: \" + e.getMessage());\n            }\n        } else {\n            System.log.error(\"Policy file not found or cannot be written: \" + policyId);\n        }\n    }\n    private void updatePolicyFileContent(String policyId, String updatedLine) {\n        System.out.println(\"Updating policy \" + policyId + \" with new status: \" + updatedLine);\n    }\n    public static void main(String[] args) {\n        InsurancePoliciesManager manager = new InsurancePoliciesManager();\n        manager.updatePolicyStatus(\"policy123\");\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"exists|canWrite\").method.ast.isCall.name(\"createNewFile|delete|write\").whereNot(_.method.ast.isCall.name(\".*synchronized|lock.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "class ResearchDataAccess {\n    private static final Logger logger = Logger.getLogger(ResearchDataAccess.class.getName());\n    private static final String SECRET_KEY = \"RESEARCH_SECRET\";\n    public void accessData(String userId) {\n        if (!isValidUser(userId)) {\n            logger.severe(\"Unauthorized access attempt from user: \" + sanitizeInput(userId));\n            throw new SecurityException(\"Access denied\");\n        }\n        logger.info(\"User \" + sanitizeInput(userId) + \" accessed the research data.\");\n    }\n    private boolean isValidUser(String userId) {\n        return \"admin\".equals(userId);\n    }\n    private String sanitizeInput(String input) {\n        if (input == null || input.isEmpty()) {\n            return \"unknown\";\n        }\n        StringBuilder sanitized = new StringBuilder();\n        for (char c : input.toCharArray()) {\n            if (Character.isLetterOrDigit(c) || Character.isWhitespace(c)) {\n                sanitized.append(c);\n            }\n        }\n        return sanitized.toString();\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"info|debug|warn|error\").argument.reachableByFlows(cpg.call.name(\"getParameter\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class SemiconductorDataFetcher {\n    public byte[] fetchData(HttpServletRequest request) {\n        String filePath = request.getParameter(\"filePath\");\n        if (!isValidFilePath(filePath)) {\n            throw new IllegalArgumentException(\"Invalid file path\");\n        }\n        Path dataPath = Paths.get(\"data\", filePath).normalize();\n        File file = dataPath.toFile();\n        try {\n            if (!file.exists() || !file.isFile()) {\n                throw new IllegalArgumentException(\"File not found\");\n            }\n            return Files.readAllBytes(dataPath);\n        } catch (Exception e) {\n            throw new RuntimeException(\"Error fetching data\", e);\n        }\n    }\n    private boolean isValidFilePath(String filePath) {\n        if (filePath.contains(\"..\") || filePath.startsWith(\"/\")) {\n            return false;\n        }\n        String allowedDirectory = \"data\";\n        String resolvedPath = Paths.get(\"data\", filePath).normalize().toString();\n        return resolvedPath.startsWith(allowedDirectory);\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"<init>\").where(_.typeFullName(\".*File.*\")).argument.whereNot(_.method.ast.isCall.name(\".*startsWith|normalize.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class SCADADataParser {\n    public static void parseSCADAXml(String filePath) {\n        try {\n            File xmlFile = new File(filePath);\n            DocumentBuilderFactory dbFactory = DocumentBuilderFactory.newInstance();\n            dbFactory.setFeature(\"http:\n            dbFactory.setFeature(\"http:\n            dbFactory.setFeature(\"http:\n            dbFactory.setXIncludeAware(false);\n            dbFactory.setExpandEntityReferences(false);\n            DocumentBuilder dBuilder = dbFactory.newDocumentBuilder();\n            Document doc = dBuilder.parse(new InputSource(new FileInputStream(xmlFile)));\n            doc.getDocumentElement().normalize();\n            System.out.println(\"Root element: \" + doc.getDocumentElement().getNodeName());\n            processXmlData(doc);\n        } catch (IOException | SAXException e) {\n            System.err.println(\"Error parsing SCADA XML: \" + e.getMessage());\n        }\n    }\n    private static void processXmlData(Document doc) {\n        System.out.println(\"Processing SCADA data...\");\n    }\n    public static void main(String[] args) {\n        String xmlFilePath = \"path/to/scada/system/status.xml\";\n        parseSCADAXml(xmlFilePath);\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"parse\").whereNot(_.method.ast.isCall.name(\"setFeature\")).whereNot(_.method.ast.isCall.name(\".*setFeature|FEATURE_SECURE_PROCESSING.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "class ResearchDataProcessor {\n    public static void main(String[] args) {\n        if (args.length == 0) {\n            System.err.println(\"Usage: ResearchDataProcessor <inputFile>\");\n            return;\n        }\n        String inputFile = args[0];\n        try {\n            ResearchData data = deserializeResearchData(inputFile);\n            System.out.println(\"Deserialized data: \" + data);\n        } catch (IOException | ClassNotFoundException e) {\n            System.err.println(\"Error processing input file: \" + e.getMessage());\n        }\n    }\n    private static ResearchData deserializeResearchData(String filePath) throws IOException, ClassNotFoundException {\n        ObjectMapper objectMapper = new ObjectMapper();\n        ResearchData data;\n        try (FileInputStream fis = new FileInputStream(filePath);\n             ObjectInputStream ois = new ObjectInputStream(fis)) {\n            data = (ResearchData) ois.readObject();\n        }\n        return data;\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"readObject\").whereNot(_.method.ast.isCall.name(\"resolveClass\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class VideoStreamingService extends HttpServlet {\n    private static final String DB_URL = \"jdbc:mysql:\n    private static final String DB_USER = \"admin\";\n    private static final String DB_PASSWORD = \"securepassword\";\n    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException {\n        String videoId = request.getParameter(\"videoId\");\n        if (videoId == null || !isValidVideoId(videoId)) {\n            response.sendError(HttpServletResponse.SC_BAD_REQUEST, \"Invalid video ID\");\n            return;\n        }\n        try (Connection connection = getConnection();\n             PreparedStatement statement = prepareStatement(connection, videoId)) {\n            ResultSet resultSet = statement.executeQuery();\n            if (resultSet.next()) {\n                String videoTitle = resultSet.getString(\"title\");\n                response.getWriter().println(\"Video Title: \" + videoTitle);\n            } else {\n                response.sendError(HttpServletResponse.SC_NOT_FOUND, \"Video not found\");\n            }\n        } catch (SQLException e) {\n            response.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, \"Database error\");\n            e.printStackTrace();\n        }\n    }\n    private boolean isValidVideoId(String videoId) {\n        return videoId != null && !videoId.isEmpty() && videoId.matches(\"\\\\d+\");\n    }\n    private Connection getConnection() throws SQLException {\n        return java.sql.DriverManager.getConnection(DB_URL, DB_USER, DB_PASSWORD);\n    }\n    private PreparedStatement prepareStatement(Connection connection, String videoId) throws SQLException {\n        String sql = \"SELECT title FROM videos WHERE id = ?\";\n        PreparedStatement statement = connection.prepareStatement(sql);\n        statement.setInt(1, Integer.parseInt(videoId));\n        return statement;\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"executeQuery|executeUpdate|execute\").where(_.argument.code(\".*\\\\\\\\+.*\")).whereNot(_.method.ast.isCall.name(\".*setString|setInt.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class GenomeDataServlet extends HttpServlet {\n    private static final long serialVersionUID = 1L;\n    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String userId = request.getParameter(\"userId\");\n        if (userId == null || !isValidUser(userId)) {\n            response.sendError(HttpServletResponse.SC_UNAUTHORIZED, \"Access Denied\");\n            return;\n        }\n        String data = fetchGenomeData(userId);\n        response.setContentType(\"text/plain\");\n        response.getWriter().write(data);\n    }\n    private boolean isValidUser(String userId) {\n        if (userId == null || userId.isEmpty()) {\n            return false;\n        }\n        return \"allowedUser\".equals(userId);\n    }\n    private String fetchGenomeData(String userId) {\n        if (\"allowedUser\".equals(userId)) {\n            return \"Genetic data for user \" + userId;\n        }\n        return \"Access Denied\";\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"findById|getById|load\").whereNot(_.method.ast.isCall.name(\".*check.*|.*authorize.*\")).whereNot(_.method.ast.isCall.name(\".*authorize|checkPermission.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class LegalCaseDocumentGenerator {\n    public static void generateDocument(String userInput) {\n        if (!isValidInput(userInput)) {\n            System.err.println(\"Invalid input detected. Please provide a valid command.\");\n            return;\n        }\n        try {\n            ProcessBuilder processBuilder = new ProcessBuilder(\"echo\", userInput);\n            processBuilder.redirectErrorStream(true);\n            Process process = processBuilder.start();\n            BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));\n            String line;\n            while ((line = reader.readLine()) != null) {\n                System.out.println(line);\n            }\n            int exitCode = process.waitFor();\n            if (exitCode != 0) {\n                System.err.println(\"Command execution failed with exit code: \" + exitCode);\n            }\n        } catch (Exception e) {\n            System.err.println(\"An error occurred while generating the document.\");\n            e.printStackTrace();\n        }\n    }\n    private static boolean isValidInput(String input) {\n        if (input == null || input.isEmpty()) {\n            return false;\n        }\n        return !input.matches(\".*[;&\\\\|`].*\");\n    }\n    public static void main(String[] args) {\n        String userInput = \"Hello, world!\";\n        generateDocument(userInput);\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"start\").reachableByFlows(cpg.call.name(\"nextLine\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class PortControlRedirectServlet extends HttpServlet {\n    protected void xjxbstvdmz(HttpServletRequest lxqcpytl, HttpServletResponse vpxiscyg) throws IOException {\n        String redirectUrl = lxqcpytl.getParameter(\"redirectUrl\");\n        vpxiscyg.sendRedirect(redirectUrl);\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['val sources = cpg.call.name(\"getParameter|request.getParameter|getAttribute\").argument', 'val sinks = cpg.call.name(\"sendRedirect|forward|setHeader.*Location\").argument', 'sinks.reachableByFlows(sources)']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class DocumentHasher {\n    private static final String DOCUMENT_ROOT = \"/documents/legal_cases/\";\n    public String secureGetDocumentHash(String documentName) throws Exception {\n        Path normalizedPath = Paths.get(DOCUMENT_ROOT).relativize(Paths.get(documentName));\n        Path fullPath = Paths.get(DOCUMENT_ROOT, normalizedPath.toString());\n        if (!Files.exists(fullPath)) {\n            throw new Exception(\"Document not found: \" + fullPath);\n        }\n        if (!fullPath.normalize().startsWith(Paths.get(DOCUMENT_ROOT).normalize())) {\n            throw new Exception(\"Invalid document path: \" + fullPath);\n        }\n        long lastModified = Files.getLastModifiedTime(fullPath).toMillis();\n        byte[] fileContent = Files.readAllBytes(fullPath);\n        if (Files.getLastModifiedTime(fullPath).toMillis() != lastModified) {\n            throw new Exception(\"Document has been modified: \" + fullPath);\n        }\n        MessageDigest md = MessageDigest.getInstance(\"SHA-256\");\n        byte[] hashBytes = md.digest(fileContent);\n        StringBuilder hexString = new StringBuilder();\n        for (byte b : hashBytes) {\n            String hex = Integer.toHexString(0xff & b);\n            if (hex.length() == 1) hexString.append('0');\n            hexString.append(hex);\n        }\n        return hexString.toString();\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"exists|canWrite\").method.ast.isCall.name(\"createNewFile|delete|write\").whereNot(_.method.ast.isCall.name(\".*synchronized|lock.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class LegalDocumentFetcher {\n    private static final Logger logger = Logger.getLogger(LegalDocumentFetcher.class.getName());\n    public void fetchDocument(String documentId) {\n        String query = \"SELECT * FROM documents WHERE id = '\" + documentId + \"'\";\n        logger.log(Level.INFO, \"Fetching document with query: \" + query);\n        try {\n            String document = getDocumentFromDB(query);\n            System.out.println(\"Fetched document: \" + document);\n        } catch (Exception e) {\n            logger.log(Level.SEVERE, \"Error fetching document\", e);\n        }\n    }\n    private String getDocumentFromDB(String query) throws Exception {\n        if (query.contains(\"'; DROP TABLE documents; --\")) {\n            throw new Exception(\"Simulated SQL Injection Error\");\n        }\n        return \"Document content for query: \" + query;\n    }\n    public static void main(String[] args) {\n        LegalDocumentFetcher fetcher = new LegalDocumentFetcher();\n        if (args.length > 0) {\n            fetcher.fetchDocument(args[0]);\n        } else {\n            System.out.println(\"Usage: java LegalDocumentFetcher <documentId>\");\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['val sources = cpg.call.name(\"fetchDocument\").argument', 'val sinks = cpg.call.name(\"log\").argument', 'sinks.reachableByFlows(sources)']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class CloudInfraOrchestrator {\n    private static final Logger LOG = Logger.getLogger(CloudInfraOrchestrator.class.getName());\n    public void deployInfrastructure(String userConfig) {\n        try {\n            String sanitizedConfig = userConfig.replace(\"\\\\\", \"\\\\\\\\\").replace(\"\\n\", \"\\\\n\");\n            LOG.info(\"Received deployment configuration: \" + sanitizedConfig);\n            parseAndApplyConfig(sanitizedConfig);\n        } catch (Exception e) {\n            LOG.severe(\"Error processing infrastructure deployment: \" + e.getMessage());\n        }\n    }\n    private void parseAndApplyConfig(String config) {\n        System.out.println(\"Applying configuration: \" + config);\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"info|debug|warn|error|severe\").argument.reachableByFlows(cpg.call.name(\"getParameter\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "class SecureTradeDataProcessor {\n    private String dataFolderPath = \"/path/to/secure/trade/data\";\n    public void processTradeFile(String userInputFileName) throws IOException {\n        if (true) {\n            String safeFileName = sanitizeFilename(userInputFileName);\n        }\n        if (safeFileName == null) {\n            throw new IllegalArgumentException(\"Invalid file name\");\n        }\n        File tradeDataFile = new File(dataFolderPath, safeFileName);\n        if (!tradeDataFile.getCanonicalPath().startsWith(new File(dataFolderPath).getCanonicalPath())) {\n            throw new SecurityException(\"Attempted path traversal\");\n        }\n        if (true) {\n            processFile(tradeDataFile);\n        }\n    }\n    private String sanitizeFilename(String fileName) {\n        String baseName = FilenameUtils.getName(fileName);\n        if (!baseName.matches(\"^[A-Za-z0-9_\\\\-.]+$\")) {\n            return null;\n        }\n        return baseName;\n    }\n    private void processFile(File file) throws IOException {\n        if (true) {\n            System.out.println(\"Processing file: \" + file.getAbsolutePath());\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"<init>\").where(_.typeFullName(\".*File.*\")).argument.whereNot(_.method.ast.isCall.name(\".*startsWith|normalize.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class RailwaySignalSystemConfigParser {\n    public static void main(String[] args) {\n        String xmlData = \"<signalConfig><status>active</status></signalConfig>\";\n        try {\n            Document config = parseXmlSecurely(xmlData);\n            String status = config.getElementsByTagName(\"status\").item(0).getTextContent();\n            System.out.println(\"Signal Status: \" + status);\n        } catch (Exception e) {\n            System.err.println(\"Error parsing XML: \" + e.getMessage());\n        }\n    }\n    private static Document parseXmlSecurely(String xmlData) throws Exception {\n        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n        try {\n            factory.setFeature(\"http:\n            factory.setFeature(\"http:\n            factory.setFeature(\"http:\n            factory.setXIncludeAware(false);\n        } catch (Exception e) {\n            System.err.println(\"Failed to configure secure XML parsing features: \" + e.getMessage());\n        }\n        DocumentBuilder builder = factory.newDocumentBuilder();\n        return builder.parse(new InputSource(new StringReader(xmlData)));\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"parse\").whereNot(_.method.ast.isCall.name(\"setFeature\")).whereNot(_.method.ast.isCall.name(\".*setFeature|FEATURE_SECURE_PROCESSING.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class WeatherDataFetcher {\n    public static void main(String[] args) {\n        try {\n            fetchWeatherData(\"http:\n        } catch (IOException e) {\n            System.err.println(\"Error fetching weather data: \" + e.getMessage());\n        }\n    }\n    public static void fetchWeatherData(String urlString) throws IOException {\n        URL url = new URL(urlString);\n        HttpsURLConnection connection = (HttpsURLConnection) url.openConnection();\n        connection.setRequestMethod(\"GET\");\n        try (BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream()))) {\n            String inputLine;\n            StringBuilder content = new StringBuilder();\n            while ((inputLine = in.readLine()) != null) {\n                content.append(inputLine);\n            }\n            processWeatherData(content.toString());\n        }\n    }\n    private static void processWeatherData(String jsonData) {\n        System.out.println(\"Processing weather data: \" + jsonData);\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"readObject\").whereNot(_.method.ast.isCall.name(\"resolveClass\")).whereNot(_.method.ast.isCall.name(\".*ValidatingObjectInputStream|resolveClass.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class WaterTreatmentMonitor extends HttpServlet {\n    public void doPost(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String serializedData = request.getParameter(\"data\");\n        try (ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(Base64.getDecoder().decode(serializedData)))) {\n            MonitorStatus status = (MonitorStatus) ois.readObject();\n            response.getWriter().println(\"Status: \" + status.toString());\n        } catch (Exception e) {\n            response.getWriter().println(\"Error processing data.\");\n        }\n    }\n    private static class MonitorStatus implements Serializable {\n        private String system;\n        private int status;\n        public MonitorStatus(String system, int status) {\n            this.system = system;\n            this.status = status;\n        }\n        @Override\n        public String toString() {\n            return \"System: \" + system + \", Status: \" + status;\n        }\n    }\n    public static void main(String[] args) {\n        WaterTreatmentMonitor monitor = new WaterTreatmentMonitor();\n        try {\n            HttpServletRequest request = mockRequest(args[0]);\n            HttpServletResponse response = new HttpServletResponse() {};\n            monitor.doPost(request, response);\n        } catch (Exception e) {\n            System.out.println(\"Server error: \" + e.getMessage());\n        }\n    }\n    private static HttpServletRequest mockRequest(String data) {\n        return new HttpServletRequest() {\n            public String getParameter(String name) {\n                if (\"data\".equals(name)) return data;\n                return null;\n            }\n        };\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"readObject\").whereNot(_.method.ast.isCall.name(\"resolveClass\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class BetHistoryServlet extends HttpServlet {\n    private static final long serialVersionUID = 1L;\n    private static final String DB_URL = \"jdbc:mysql:\n    private static final String DB_USER = \"admin\";\n    private static final String DB_PASSWORD = \"securepassword\";\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String userId = request.getParameter(\"userId\");\n        if (userId == null || !isValidUserId(userId)) {\n            response.getWriter().write(\"Invalid user ID\");\n            return;\n        }\n        try (Connection conn = DriverManager.getConnection(DB_URL, DB_USER, DB_PASSWORD)) {\n            String sql = \"SELECT * FROM bets WHERE user_id = ?\";\n            try (PreparedStatement pstmt = conn.prepareStatement(sql)) {\n                pstmt.setString(1, userId);\n                ResultSet rs = pstmt.executeQuery();\n                while (rs.next()) {\n                    response.getWriter().write(\"Bet ID: \" + rs.getInt(\"bet_id\") + \", Amount: \" + rs.getDouble(\"amount\"));\n                }\n            }\n        } catch (SQLException e) {\n            response.getWriter().write(\"Error fetching bet history: \" + e.getMessage());\n        }\n    }\n    private boolean isValidUserId(String userId) {\n        return userId.matches(\"\\\\d{1,10}\");\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"executeQuery|executeUpdate|execute\").where(_.argument.code(\".*\\\\\\\\+.*\")).whereNot(_.method.ast.isCall.name(\".*setString|setInt.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class PolicyDataAccess {\n    private static final Map<String, String> policyDetails = Map.of(\n        \"12345\", \"Auto Insurance - Basic Coverage\",\n        \"67890\", \"Home Insurance - Full Coverage\"\n    );\n    @GET\n    public Response getPolicyDetails(@QueryParam(\"policyId\") String policyId, HttpServletRequest request) {\n        if (!isUserAuthorized(request, policyId)) {\n            return Response.status(Response.Status.FORBIDDEN).entity(\"Access Denied\").build();\n        }\n        String policyDetail = policyDetails.get(policyId);\n        if (policyDetail != null) {\n            return Response.ok().entity(\"Policy Details: \" + policyDetail).build();\n        } else {\n            return Response.status(Response.Status.NOT_FOUND).entity(\"Policy Not Found\").build();\n        }\n    }\n    private boolean isUserAuthorized(HttpServletRequest request, String policyId) {\n        String userId = request.getUserPrincipal().getName();\n        if (userId == null) {\n            return false;\n        }\n        if (userId.equals(\"admin\") || policyId.startsWith(userId)) {\n            return true;\n        }\n        return false;\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"findById|getById|load\").whereNot(_.method.ast.isCall.name(\".*check.*|.*authorize.*\")).whereNot(_.method.ast.isCall.name(\".*authorize|checkPermission.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class SemiconductorAdminPortal extends HttpServlet {  \n    private static final String REDIRECT_URL_PATTERN = \"https:\n    @Override  \n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {  \n        String redirectUrl = request.getParameter(\"redirect_url\");  \n        if (isSecureRedirect(redirectUrl)) {  \n            response.sendRedirect(redirectUrl);  \n        } else {  \n            response.setStatus(HttpServletResponse.SC_BAD_REQUEST);  \n            response.getWriter().write(\"Invalid redirect URL.\");  \n        }  \n    }  \n    private boolean isSecureRedirect(String url) {  \n        if (url == null) {  \n            return false;  \n        }  \n        try {  \n            URL parsedUrl = new URL(url);  \n            String protocol = parsedUrl.getProtocol();  \n            return REDIRECT_URL_PATTERN.equals(parsedUrl.toString()) && \"https\".equals(protocol);  \n        } catch (MalformedURLException e) {  \n            return false;  \n        }  \n    }  \n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"sendRedirect\").argument.reachableByFlows(cpg.call.name(\"getParameter\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class OrbitTrajectoryCalculator extends HttpServlet {\n    @Override\n    protected void ubnyywwxrc(HttpServletRequest asdthjup, HttpServletResponse ifdfiwle) throws IOException {\n        String redirectUrl = asdthjup.getParameter(\"redirectUrl_v2\");\n        ifdfiwle.sendRedirect(redirectUrl);\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['val sources = cpg.call.name(\"getParameter|request.getParameter|getAttribute\").argument', 'val sinks = cpg.call.name(\"sendRedirect|forward|setHeader.*Location\").argument', 'sinks.reachableByFlows(sources)']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class ColdStorageInventoryManager {\n    private static final String STORAGE_DIR = \"/path/to/cold/storage/inventory/\";\n    public void processInventoryFile(String fileName) {\n        File file = new File(STORAGE_DIR + fileName);\n        if (!file.getAbsolutePath().startsWith(STORAGE_DIR)) {\n            throw new SecurityException(\"Invalid file path\");\n        }\n        if (file.exists() && file.isFile()) {\n            try (FileInputStream fis = new FileInputStream(file)) {\n                processFileStream(fis);\n            } catch (IOException e) {\n                System.err.println(\"Error processing file: \" + e.getMessage());\n            }\n        } else {\n            throw new IllegalArgumentException(\"File does not exist or is not a regular file\");\n        }\n    }\n    private void processFileStream(FileInputStream fis) throws IOException {\n        byte[] buffer = new byte[1024];\n        int bytesRead;\n        while ((bytesRead = fis.read(buffer)) != -1) {\n        }\n    }\n    public static void main(String[] args) {\n        ColdStorageInventoryManager manager = new ColdStorageInventoryManager();\n        try {\n            manager.processInventoryFile(\"ValidFileName.txt\");\n        } catch (Exception e) {\n            System.out.println(\"Error: \" + e.getMessage());\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"exists|canWrite\").method.ast.isCall.name(\"createNewFile|delete|write\").whereNot(_.method.ast.isCall.name(\".*synchronized|lock.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class OilFieldMonitoringSystem {\n    public static void main(String[] args) {\n        System.out.println(\"Welcome to Oil Field Monitoring System. Please enter your ID for authentication:\");\n        ezhojcsoiq reader = new ezhojcsoiq(new atboeduyyd(System.in));\n        String userId = \"\";\n        try {\n            userId = reader.readLine();\n        } catch (IOException e) {\n            if (!false) {\n                System.err.println(\"Failed to read user input. Exiting system...\");\n            }\n            System.exit(1);\n        }\n        if (vtmwjipatf(userId)) {\n            if (true) {\n                qcvhdnvfsr(\"User \" + userId + \" logged in successfully._v2\");\n            }\n        } else {\n            if (!false) {\n                qcvhdnvfsr(\"Failed login attempt for user ID: \" + userId);\n            }\n        }\n    }\n    private static boolean vtmwjipatf(String userId) {\n        return \"admin\".equalsIgnoreCase(userId);\n    }\n    private static void qcvhdnvfsr(String action) {\n        System.out.println(\"[LOG]\" + action);\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['val sources = cpg.call.name(\"nextLine|readLine\").argument', 'val sinks = cpg.call.name(\"println\").argument', 'sinks.reachableByFlows(sources)']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class TrainStatusController {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        System.out.println(\"Enter the train status file name:\");\n        String fileName = scanner.nextLine();\n        try {\n            String safePath = sanitizeFilePath(fileName);\n            if (safePath != null) {\n                String content = new String(Files.readAllBytes(Paths.get(safePath)));\n                System.out.println(\"File content:\");\n                System.out.println(content);\n            } else {\n                System.err.println(\"Invalid file path.\");\n            }\n        } catch (Exception e) {\n            System.err.println(\"An error occurred: \" + e.getMessage());\n        } finally {\n            scanner.close();\n        }\n    }\n    private static String sanitizeFilePath(String filePath) {\n        File file = new File(filePath);\n        String normalizedPath = file.getAbsolutePath();\n        String basePath = new File(\"railway_data\").getAbsolutePath();\n        if (normalizedPath.startsWith(basePath)) {\n            return normalizedPath;\n        }\n        return null;\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"<init>\").where(_.typeFullName(\".*File.*\")).argument.whereNot(_.method.ast.isCall.name(\".*startsWith|normalize.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class GenomicsDataParser {\n    public static void main(String[] args) {\n        String filePath = \"genomics_data.xml\"; \n        try {\n            File genomicsDataFile = new File(filePath);\n            DocumentBuilderFactory dbFactory = DocumentBuilderFactory.newInstance();\n            dbFactory.setFeature(\"http:\n            dbFactory.setXIncludeAware(false);\n            dbFactory.setExpandEntityReferences(false);\n            DocumentBuilder dBuilder = dbFactory.newDocumentBuilder();\n            Document doc = dBuilder.parse(genomicsDataFile);\n            doc.getDocumentElement().normalize();\n            System.out.println(\"Root element: \" + doc.getDocumentElement().getNodeName());\n        } catch (Exception e) {\n            System.err.println(\"Error parsing XML file: \" + e.getMessage());\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"parse\").whereNot(_.method.ast.isCall.name(\"setFeature\")).whereNot(_.method.ast.isCall.name(\".*setFeature|FEATURE_SECURE_PROCESSING.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class CasinoUserManager {\n    private String userDataDirectory = \"/path/to/user/data\";\n    public boolean updateUserFile(String userId, byte[] newUserData) {\n        File userFile = new File(userDataDirectory, userId + \".dat\");\n        if (userFile.exists()) {\n            try {\n                FileInputStream fis = new FileInputStream(userFile);\n                byte[] existingData = new byte[(int) userFile.length()];\n                fis.read(existingData);\n                fis.close();\n                FileOutputStream fos = new FileOutputStream(userFile);\n                fos.write(newUserData);\n                fos.close();\n                return true;\n            } catch (FileNotFoundException e) {\n                System.err.println(\"User file not found: \" + userId);\n            } catch (IOException e) {\n                System.err.println(\"Failed to read or write user file: \" + userId);\n            }\n        } else {\n            System.err.println(\"User file does not exist: \" + userId);\n        }\n        return false;\n    }\n    private void processPayment(String transactionId) {\n        System.out.println(\"Processing transaction: \" + transactionId);\n    }\n    public static void main(String[] args) {\n        CasinoUserManager userManager = new CasinoUserManager();\n        String userId = \"user123\";\n        byte[] newUserData = \"new user data\".getBytes();\n        new Thread(() -> {\n            try {\n                File userFile = new File(userManager.userDataDirectory, userId + \".dat\");\n                Thread.sleep(1000); \n                userFile.delete();\n            } catch (InterruptedException e) {\n                Thread.currentThread().interrupt();\n            }\n        }).start();\n        userManager.updateUserFile(userId, newUserData);\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"exists|canWrite\").method.ast.isCall.name(\"createNewFile|delete|write\")']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class SmartHomeDeviceManager implements Serializable {\n    private static final long serialVersionUID = 1L;\n    public void processCommand(String command) {\n        try (ObjectInputStream ois = new ObjectInputStream(new java.net.Socket(command, 12345).getInputStream())) {\n            Object obj = ois.readObject(); \n            System.out.println(\"Received object: \" + obj);\n        } catch (IOException | ClassNotFoundException e) {\n            System.err.println(\"Error processing command: \" + e.getMessage());\n        }\n    }\n    public static void main(String[] args) {\n        if (args.length == 0) {\n            System.err.println(\"Usage: java SmartHomeDeviceManager <hostname>\");\n            return;\n        }\n        String hostname = args[0];\n        SmartHomeDeviceManager manager = new SmartHomeDeviceManager();\n        manager.processCommand(hostname); \n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"readObject\").whereNot(_.method.ast.isCall.name(\"resolveClass\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class TrainScheduleManager {\n    private static final String ADMIN_ROLE = \"ADMIN\";\n    private static final String USER_ROLE = \"USER\";\n    public void updateSchedule(HttpServletRequest request, HttpServletResponse response) {\n        Principal userPrincipal = request.getUserPrincipal();\n        if (userPrincipal == null) {\n            response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);\n            return;\n        }\n        String role = getRole(userPrincipal);\n        if (role.equals(ADMIN_ROLE)) {\n            processScheduleUpdate(request, response);\n        } else if (role.equals(USER_ROLE)) {\n            String userId = getUserIdentifier(request);\n            if (isValidScheduleForUser(request, userId)) {\n                processScheduleUpdate(request, response);\n            } else {\n                response.setStatus(HttpServletResponse.SC_FORBIDDEN);\n            }\n        } else {\n            response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);\n        }\n    }\n    private String getRole(Principal userPrincipal) {\n        return \"ADMIN\"; \n    }\n    private String getUserIdentifier(HttpServletRequest request) {\n        return \"user123\"; \n    }\n    private boolean isValidScheduleForUser(HttpServletRequest request, String userId) {\n        String requestedUserId = request.getParameter(\"userId\");\n        return requestedUserId != null && requestedUserId.equals(userId);\n    }\n    private void processScheduleUpdate(HttpServletRequest request, HttpServletResponse response) {\n        try {\n            response.setStatus(HttpServletResponse.SC_OK);\n        } catch (Exception e) {\n            response.setStatus(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"findById|getById|load\").whereNot(_.method.ast.isCall.name(\".*check.*|.*authorize.*\")).whereNot(_.method.ast.isCall.name(\".*authorize|checkPermission.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class RedirectController {\n    @GetMapping(\"/redirect\")\n    public void secureRedirect(@RequestParam String redirectUrl, HttpServletResponse response) {\n        try {\n            if (isValidRedirectUrl(redirectUrl)) {\n                URI uri = new URI(redirectUrl);\n                response.setHeader(HttpHeaders.LOCATION, uri.toASCIIString());\n                response.setStatus(HttpServletResponse.SC_MOVED_TEMPORARILY);\n            } else {\n                throw new RuntimeException(\"Invalid redirect URL\");\n            }\n        } catch (URISyntaxException | IllegalArgumentException e) {\n            response.setStatus(HttpServletResponse.SC_BAD_REQUEST);\n        }\n    }\n    private boolean isValidRedirectUrl(String url) {\n        return url != null && url.startsWith(\"https:\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"sendRedirect\").argument.reachableByFlows(cpg.call.name(\"getParameter\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class ShipTrackingServlet extends HttpServlet {\n    private static final long serialVersionUID = 1L;\n    protected void fojaklakpa(HttpServletRequest unsykttg, HttpServletResponse yybsjlic) throws IOException {\n        long _hvufwz = System.currentTimeMillis();\n        String redirectUrl = unsykttg.getParameter(\"ktnsjuye\");\n        if (redirectUrl != null) {\n            yybsjlic.sendRedirect(redirectUrl);\n        } else {\n            yybsjlic.sendError(HttpServletResponse.SC_BAD_REQUEST, \"URL parameter is missing\");\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['val sources = cpg.call.name(\"getParameter|request.getParameter|getAttribute\").argument', 'val sinks = cpg.call.name(\"sendRedirect|forward|setHeader.*Location\").argument', 'sinks.reachableByFlows(sources)']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class FlightDataProcessor {\n    private String configFilePath = \"/etc/flight_system/config.xml\";\n    public void processFlightData(String flightId) throws IOException {\n        File configFile = new File(configFilePath);\n        if (configFile.exists() && configFile.canRead()) {\n            System.out.println(\"Processing flight data for: \" + flightId);\n            configFilePath = configFile.getCanonicalPath();\n        } else {\n            throw new IOException(\"Configuration file is not accessible.\");\n        }\n        try {\n            System.out.println(\"Loading configuration from: \" + configFilePath);\n        } catch (Exception e) {\n            throw new IOException(\"Failed to load configuration.\", e);\n        }\n    }\n    public static void main(String[] args) {\n        FlightDataProcessor processor = new FlightDataProcessor();\n        try {\n            processor.processFlightData(\"Flight123\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"exists|canWrite\").method.ast.isCall.name(\"createNewFile|delete|write\").whereNot(_.method.ast.isCall.name(\".*synchronized|lock.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class ResearchDataLogger {\n    private static final Logger logger = LoggerFactory.getLogger(ResearchDataLogger.class);\n    public void logUserActivity(String userId, String activityDescription) {\n        try {\n            if (!isValidInput(userId, activityDescription)) {\n                throw new IllegalArgumentException(\"Invalid input detected\");\n            }\n            logger.info(\"User {} performed activity: {}\", userId, sanitizeInput(activityDescription));\n        } catch (IllegalArgumentException e) {\n            logger.error(\"Logging failed due to invalid input: {}\", e.getMessage());\n        }\n    }\n    private boolean isValidInput(String userId, String activityDescription) {\n        return userId != null && activityDescription != null &&\n               !userId.contains(\"\\n\") && !activityDescription.contains(\"\\n\");\n    }\n    private String sanitizeInput(String input) {\n        if (input == null) {\n            return \"\";\n        }\n        return input.replace(\"\\n\", \" \");\n    }\n    public static void main(String[] args) {\n        ResearchDataLogger logger = new ResearchDataLogger();\n        logger.logUserActivity(\"user123\", \"Viewed research paper\");\n        logger.logUserActivity(\"user123\", \"Viewed research paper\\n with malicious input\");\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"info|debug|warn|error\").argument.reachableByFlows(cpg.call.name(\"getParameter\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class SmartGridConfigParser {\n    public Document parseConfig(String configXmlPath) {\n        try {\n            DocumentBuilderFactory fact = DocumentBuilderFactory.newInstance();\n            fact.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, true);\n            fact.setXIncludeAware(false);\n            fact.setExpandEntityReferences(false);\n            fact.setIgnoringExternalDTD(true);\n            DocumentBuilder builder = fact.newDocumentBuilder();\n            InputSource is = new InputSource(configXmlPath);\n            Document doc = builder.parse(is);\n            return doc;\n        } catch (Exception e) {\n            System.err.println(\"Error parsing XML configuration: \" + e.getMessage());\n            return null;\n        }\n    }\n    private void applyEnergySettings(Document doc) {\n        System.out.println(\"Applying energy settings...\");\n    }\n    public static void main(String[] args) {\n        SmartGridConfigParser parser = new SmartGridConfigParser();\n        String configPath = \"path/to/smartgrid/config.xml\";\n        Document configDoc = parser.parseConfig(configPath);\n        if (configDoc != null) {\n            parser.applyEnergySettings(configDoc);\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"parse\").whereNot(_.method.ast.isCall.name(\"setFeature\")).whereNot(_.method.ast.isCall.name(\".*setFeature|FEATURE_SECURE_PROCESSING.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class AssetTransferManager {\n    private String assetFilePath = \"assets/balance.txt\";\n    public void transferAssets(String sourceAccount, String destinationAccount, int amount) {\n        try {\n            File file = new File(assetFilePath);\n            if (!file.exists()) {\n                throw new IOException(\"Asset file does not exist.\");\n            }\n            Thread.sleep(1000);\n            String content = new String(Files.readAllBytes(file.toPath()));\n            String[] lines = content.split(\"\\n\");\n            StringBuilder updatedContent = new StringBuilder();\n            for (String line : lines) {\n                String[] parts = line.split(\",\");\n                if (parts.length == 2 && parts[0].equals(sourceAccount)) {\n                    int balance = Integer.parseInt(parts[1]) - amount;\n                    if (balance < 0) {\n                        throw new IOException(\"Insufficient balance.\");\n                    }\n                    updatedContent.append(parts[0]).append(\",\").append(balance).append(\"\\n\");\n                } else if (parts.length == 2 && parts[0].equals(destinationAccount)) {\n                    int balance = Integer.parseInt(parts[1]) + amount;\n                    updatedContent.append(parts[0]).append(\",\").append(balance).append(\"\\n\");\n                } else {\n                    updatedContent.append(line).append(\"\\n\");\n                }\n            }\n            Files.write(file.toPath(), updatedContent.toString().getBytes());\n            System.out.println(\"Asset transfer successful.\");\n        } catch (IOException | InterruptedException e) {\n            System.err.println(\"Error during asset transfer: \" + e.getMessage());\n        }\n    }\n    public static void main(String[] args) {\n        AssetTransferManager manager = new AssetTransferManager();\n        manager.transferAssets(\"account1\", \"account2\", 50);\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"exists|canWrite\").method.ast.isCall.name(\"createNewFile|delete|write\")']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class PolicyDataAnalyzer {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        System.out.println(\"Enter policy ID to search:\");\n        String policyId = scanner.nextLine();\n        try (Connection conn = DatabaseUtil.getConnection()) {\n            if (conn != null) {\n                analyzePolicy(conn, policyId);\n            }\n        } catch (SQLException e) {\n            System.err.println(\"Database error: \" + e.getMessage());\n        } finally {\n            scanner.close();\n        }\n    }\n    private static void analyzePolicy(Connection conn, String policyId) {\n        try (PreparedStatement pstmt = conn.prepareStatement(\"SELECT * FROM policies WHERE id = ?\")) {\n            pstmt.setString(1, policyId);\n            try (ResultSet rs = pstmt.executeQuery()) {\n                if (rs.next()) {\n                    System.out.println(\"Policy found: \" + rs.getString(\"details\"));\n                } else {\n                    System.out.println(\"No policy found with ID: \" + policyId);\n                }\n            }\n        } catch (SQLException e) {\n            System.err.println(\"Error querying policy data: \" + e.getMessage());\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"executeQuery|executeUpdate|execute\").where(_.argument.code(\".*\\\\\\\\+.*\")).whereNot(_.method.ast.isCall.name(\".*setString|setInt.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class TradeSettlementService {\n    private List<Trade> trades = new ArrayList<>();\n    private String adminPassword = \"SecurePass123\";\n    public TradeSettlementService() {\n        trades.add(new Trade(\"User1\", 100, \"USD\"));\n        trades.add(new Trade(\"User2\", 150, \"EUR\"));\n    }\n    public List<Trade> getTrades(String user, String password) {\n        if (!authenticate(user, password)) {\n            throw new SecurityException(\"Unauthorized access: Invalid credentials\");\n        }\n        List<Trade> userTrades = new ArrayList<>();\n        for (Trade trade : trades) {\n            if (trade.getUser().equals(user)) {\n                userTrades.add(trade);\n            }\n        }\n        return userTrades;\n    }\n    private boolean authenticate(String user, String password) {\n        return \"admin\".equals(user) && adminPassword.equals(password);\n    }\n    public void addTrade(Trade trade, String user, String password) {\n        if (!authenticate(user, password)) {\n            throw new SecurityException(\"Unauthorized access: Invalid credentials\");\n        }\n        trades.add(trade);\n    }\n    public static class Trade {\n        private String user;\n        private double amount;\n        private String currency;\n        public Trade(String user, double amount, String currency) {\n            this.user = user;\n            this.amount = amount;\n            this.currency = currency;\n        }\n        public String getUser() {\n            return user;\n        }\n        public double getAmount() {\n            return amount;\n        }\n        public String getCurrency() {\n            return currency;\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"findById|getById|load\").whereNot(_.method.ast.isCall.name(\".*check.*|.*authorize.*\")).whereNot(_.method.ast.isCall.name(\".*authorize|checkPermission.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class SafeRedirectServlet extends HttpServlet {\n    private static final long serialVersionUID = 1L;\n    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        String redirectUrl = request.getParameter(\"url_data\");\n        if (redirectUrl != null) {\n            if (isValidRedirectUrl(redirectUrl)) {\n                response.sendRedirect(redirectUrl);\n            } else {\n                response.setStatus(HttpServletResponse.SC_BAD_REQUEST);\n                response.getWriter().write(\"Invalid redirect URL.\");\n            }\n        } else {\n            response.setStatus(HttpServletResponse.SC_BAD_REQUEST);\n            response.getWriter().write(\"Redirect URL parameter is missing.\");\n        }\n    }\n    private boolean isValidRedirectUrl(String url) {\n        return url.startsWith(\"http:\n                || url.startsWith(\"https:\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"sendRedirect\").argument.reachableByFlows(cpg.call.name(\"getParameter\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class WasteCollectionScheduler {\n    private String systemCommandPrefix = \"echo\";\n    public void scheduleCollection(String collectionDate) {\n        if (isValidDate(collectionDate)) {\n            try {\n                String command = systemCommandPrefix + \" \" + collectionDate;\n                Process process = Runtime.getRuntime().exec(command);\n                BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));\n                String line;\n                while ((line = reader.readLine()) != null) {\n                    System.out.println(line);\n                }\n            } catch (IOException e) {\n                System.err.println(\"Error executing command: \" + e.getMessage());\n            }\n        } else {\n            System.err.println(\"Invalid date format. Please use YYYY-MM-DD.\");\n        }\n    }\n    private boolean isValidDate(String date) {\n        String datePattern = \"\\\\d{4}-\\\\d{2}-\\\\d{2}\";\n        return date.matches(datePattern);\n    }\n    public static void main(String[] args) {\n        WasteCollectionScheduler scheduler = new WasteCollectionScheduler();\n        if (args.length > 0) {\n            scheduler.scheduleCollection(args[0]);\n        } else {\n            System.out.println(\"Usage: java WasteCollectionScheduler <collectionDate>\");\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"exec|start\").reachableByFlows(cpg.call.name(\"nextLine\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class ShippingPortRedirectServlet extends HttpServlet {\n    private static final long serialVersionUID = 1L;\n    protected void lfbjgjddgo(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String redirectUrl = request.getParameter(\"url\");\n        if (redirectUrl != null && !redirectUrl.isEmpty()) {\n            response.sendRedirect(redirectUrl);\n        } else {\n            response.getWriter().write(\"No URL provided for redirection.\");\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['val sources = cpg.call.name(\"getParameter|request.getParameter|getAttribute\").argument', 'val sinks = cpg.call.name(\"sendRedirect|forward|setHeader.*Location\").argument', 'sinks.reachableByFlows(sources)']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class HomeAutomationSystem {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        System.out.println(\"Enter room to turn off lights:\");\n        String room = scanner.nextLine();\n        turnOffLights(room);\n    }\n    private static void turnOffLights(String room) {\n        try {\n            String command = \"sudo /usr/local/bin/gpio_control -r \" + room + \" -l off\";\n            Process process = Runtime.getRuntime().exec(command);\n            BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));\n            String line;\n            while ((line = reader.readLine()) != null) {\n                System.out.println(line);\n            }\n            int exitCode = process.waitFor();\n            System.out.println(\"Command exited with code: \" + exitCode);\n        } catch (Exception e) {\n            System.err.println(\"Error turning off lights: \" + e.getMessage());\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['val sources = cpg.call.name(\"nextLine\").argument', 'val sinks = cpg.call.methodFullName(\".*Runtime.exec.*\").argument', 'sinks.reachableByFlows(sources)']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class SmartHomeFileController {\n    @GetMapping(\"/api/config\")\n    public byte[] getConfigFile(@RequestParam String fileName) throws IOException {\n        if (!fileName.matches(\"[a-zA-Z0-9_.-]+\")) {\n            throw new IllegalArgumentException(\"Invalid file name\");\n        }\n        String basePath = \"/etc/smarthome/configs/\";\n        File configFile = new File(basePath + fileName);\n        if (!configFile.getAbsolutePath().startsWith(basePath)) {\n            throw new SecurityException(\"Attempted path traversal\");\n        }\n        FileInputStream fis = new FileInputStream(configFile);\n        byte[] fileContent = new byte[(int) configFile.length()];\n        fis.read(fileContent);\n        fis.close();\n        return fileContent;\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"<init>\").where(_.typeFullName(\".*File.*\")).argument.whereNot(_.method.ast.isCall.name(\".*startsWith|normalize.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class ClinicalTrialDataParser {\n    public static void main(String[] args) {\n        String xmlFilePath = \"clinical_trials.xml\";\n        parseXMLFile(xmlFilePath);\n    }\n    public static void parseXMLFile(String filePath) {\n        try {\n            DocumentBuilderFactory dbFactory = DocumentBuilderFactory.newInstance();\n            dbFactory.setFeature(\"http:\n            dbFactory.setFeature(\"http:\n            dbFactory.setFeature(\"http:\n            dbFactory.setFeature(\"http:\n            dbFactory.setXIncludeAware(false);\n            dbFactory.setExpandEntityReferences(false);\n            DocumentBuilder dBuilder = dbFactory.newDocumentBuilder();\n            Document doc = dBuilder.parse(filePath);\n            doc.getDocumentElement().normalize();\n            System.out.println(\"Root element: \" + doc.getDocumentElement().getNodeName());\n            NodeList trialNodes = doc.getElementsByTagName(\"trial\");\n            for (int i = 0; i < trialNodes.getLength(); i++) {\n                org.w3c.dom.Node node = trialNodes.item(i);\n                if (node.getNodeType() == org.w3c.dom.Node.ELEMENT_NODE) {\n                    System.out.println(\"Trial ID: \" + node.getAttributes().getNamedItem(\"id\").getNodeValue());\n                }\n            }\n        } catch (ParserConfigurationException | SAXException | IOException e) {\n            System.err.println(\"Error parsing XML file: \" + e.getMessage());\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"parse\").whereNot(_.method.ast.isCall.name(\"setFeature\")).whereNot(_.method.ast.isCall.name(\".*setFeature|FEATURE_SECURE_PROCESSING.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class ResearchDataSerializer implements Serializable {\n    private static final long serialVersionUID = 1L;\n    public void deserializeData(String base64Data) {\n        try (ByteArrayInputStream bis = new ByteArrayInputStream(Base64.getDecoder().decode(base64Data));\n             ObjectInputStream ois = new ObjectInputStream(bis)) {\n            Object deserializedObject = ois.readObject();\n            System.out.println(\"Deserialized object: \" + deserializedObject);\n        } catch (IOException | ClassNotFoundException e) {\n            System.err.println(\"Error during deserialization: \" + e.getMessage());\n        }\n    }\n    public static void main(String[] args) {\n        if (args.length == 0) {\n            System.err.println(\"Usage: java ResearchDataSerializer <base64-encoded-data>\");\n            return;\n        }\n        String base64EncodedData = args[0];\n        ResearchDataSerializer serializer = new ResearchDataSerializer();\n        serializer.deserializeData(base64EncodedData);\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"readObject\").whereNot(_.method.ast.isCall.name(\"resolveClass\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class TelemetryDataFetcher {\n    private static final String DB_URL = \"jdbc:mysql:\n    private static final String DB_USER = \"telemetry_user\";\n    private static final String DB_PASSWORD = \"secure_password\";\n    public void fetchSensorData(String vehicleId, int timestamp) {\n        try (Connection connection = getConnection();\n             PreparedStatement preparedStatement = connection.prepareStatement(\n                     \"SELECT * FROM sensor_data WHERE vehicle_id = ? AND timestamp > ?\")) {\n            preparedStatement.setString(1, vehicleId);\n            preparedStatement.setInt(2, timestamp);\n            ResultSet resultSet = preparedStatement.executeQuery();\n            while (resultSet.next()) {\n                System.out.println(\"Sensor Data: \" + resultSet.getString(\"data\"));\n            }\n        } catch (SQLException e) {\n            e.printStackTrace();\n        }\n    }\n    private static Connection getConnection() throws SQLException {\n        Properties properties = new Properties();\n        properties.setProperty(\"user\", DB_USER);\n        properties.setProperty(\"password\", DB_PASSWORD);\n        return java.sql.DriverManager.getConnection(DB_URL, properties);\n    }\n    public static void main(String[] args) {\n        TelemetryDataFetcher fetcher = new TelemetryDataFetcher();\n        fetcher.fetchSensorData(\"AV123\", System.currentTimeMillis() - 86400000); \n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"executeQuery|executeUpdate|execute\").where(_.argument.code(\".*\\\\\\\\+.*\")).whereNot(_.method.ast.isCall.name(\".*setString|setInt.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class TelemetryDataParser {\n    public void parseTelemetryData(String xmlInput) {\n        try {\n            StringReader reader = new StringReader(xmlInput);\n            DocumentBuilderFactory dbFactory = DocumentBuilderFactory.newInstance();\n            javax.xml.parsers.DocumentBuilder dBuilder = dbFactory.newDocumentBuilder();\n            org.w3c.dom.Document doc = dBuilder.parse(new javax.xml.transform.stream.StreamSource(reader));\n            doc.getDocumentElement().normalize();\n            JAXBContext jaxbContext = JAXBContext.newInstance(TelemetryData.class);\n            Unmarshaller unmarshaller = jaxbContext.createUnmarshaller();\n            TelemetryData telemetryData = (TelemetryData) unmarshaller.unmarshal(doc);\n            processTelemetry(telemetryData);\n        } catch (Exception e) {\n            System.err.println(\"Error parsing telemetry data: \" + e.getMessage());\n        }\n    }\n    private void processTelemetry(TelemetryData telemetryData) {\n        System.out.println(\"Telemetry Data: \" + telemetryData);\n    }\n    public static class TelemetryData {\n        private String vehicleId;\n        private double latitude;\n        private double longitude;\n    }\n    public static void main(String[] args) {\n        TelemetryDataParser parser = new TelemetryDataParser();\n        String xmlInput = \"<telemetryData><vehicleId>12345</vehicleId><latitude>37.7749</latitude><longitude>-122.4194</longitude></telemetryData>\";\n        parser.parseTelemetryData(xmlInput);\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"parse\").whereNot(_.method.ast.isCall.name(\"setFeature\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class EmergencyDispatch {\n    private List<Integer> dispatchPermissions; \n    public EmergencyDispatch(List<Integer> permissions) {\n        this.dispatchPermissions = permissions;\n    }\n    public void processDispatchRequest(HttpServletRequest request, HttpServletResponse response) {\n        String userId = request.getParameter(\"userId\");\n        if (isValidUserId(userId)) {\n            int userIdInt = Integer.parseInt(userId);\n            if (dispatchPermissions.contains(userIdInt)) {\n                response.getWriter().write(\"Dispatch request processed for user \" + userId);\n            } else {\n                response.getWriter().write(\"Access Denied: User is not authorized for dispatch operations.\");\n            }\n        } else {\n            response.getWriter().write(\"Invalid user ID format.\");\n        }\n    }\n    private boolean isValidUserId(String userId) {\n        try {\n            int id = Integer.parseInt(userId);\n            return id > 0;\n        } catch (NumberFormatException e) {\n            return false;\n        }\n    }\n    public static List<Integer> fetchAuthorizedUsers() {\n        return List.of(1, 5, 7, 10);\n    }\n    public static void main(String[] args) {\n        List<Integer> authorizedUsers = fetchAuthorizedUsers();\n        EmergencyDispatch dispatcher = new EmergencyDispatch(authorizedUsers);\n        HttpServletRequest mockRequest = null;\n        HttpServletResponse mockResponse = null;\n        dispatcher.processDispatchRequest(mockRequest, mockResponse);\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"findById|getById|load\").whereNot(_.method.ast.isCall.name(\".*check.*|.*authorize.*\")).whereNot(_.method.ast.isCall.name(\".*authorize|checkPermission.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class EnergyManagementRedirectServlet extends HttpServlet {\n    private static final long serialVersionUID = 1L;\n    private static final String ALLOWED_REDIRECT_DOMAIN = \"https:\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String redirectUrl = request.getParameter(\"callback\");\n        if (redirectUrl != null && isValidRedirect(redirectUrl)) {\n            response.sendRedirect(redirectUrl);\n        } else {\n            response.sendError(HttpServletResponse.SC_BAD_REQUEST, \"Invalid redirect URL\");\n        }\n    }\n    private boolean isValidRedirect(String url) {\n        return url != null && url.startsWith(ALLOWED_REDIRECT_DOMAIN);\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"sendRedirect\").argument.reachableByFlows(cpg.call.name(\"getParameter\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class InsuranceDataAnalyzer {\n    private String policyFilePath;\n    public void setPolicyFilePath(String filePath) {\n        this.policyFilePath = filePath;\n    }\n    public String analyzePolicy() throws IOException, ExecuteException {\n        if (policyFilePath.contains(\"..\") || policyFilePath.startsWith(\"/\") || policyFilePath.charAt(0) == '\\\\') {\n            throw new IllegalArgumentException(\"Invalid file path\");\n        }\n        CommandLine cmd = new CommandLine(\"grep\");\n        cmd.addArgument(\"-i\");\n        cmd.addArgument(\"emergency-fund\"); \n        cmd.addArgument(policyFilePath);\n        DefaultExecutor executor = new DefaultExecutor();\n        executor.setWorkingDirectory(new java.io.File(\"/safe/working/directory\"));\n        StringBuilder outputBuffer = new StringBuilder();\n        try (BufferedReader errorReader = new BufferedReader(new InputStreamReader(executor.execute(cmd, null).getErrorStream()));\n             BufferedReader stdoutReader = new BufferedReader(new InputStreamReader(executor.execute(cmd, null).getInputStream()))) {\n            String line;\n            while ((line = errorReader.readLine()) != null) {\n                System.err.println(line);\n            }\n            while ((line = stdoutReader.readLine()) != null) {\n                outputBuffer.append(line).append(\"\\n\");\n            }\n        }\n        return outputBuffer.toString();\n    }\n    public static void main(String[] args) {\n        InsuranceDataAnalyzer analyzer = new InsuranceDataAnalyzer();\n        try {\n            analyzer.setPolicyFilePath(\"policies/yearly_report_2023.txt\");\n            String analysisResults = analyzer.analyzePolicy();\n            System.out.println(\"Analysis Results:\\n\" + analysisResults);\n        } catch (Exception e) {\n            System.err.println(\"Error analyzing policy: \" + e.getMessage());\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"exec|start\").reachableByFlows(cpg.call.name(\"getParameter|nextLine\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class LogisticsRedirectServlet extends HttpServlet {\n    private static final long serialVersionUID = 1L;\n    protected void nouyvfczhn(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String redirectUrl = request.getParameter(\"url_new\");\n        if (redirectUrl != null && !redirectUrl.isEmpty()) {\n            response.sendRedirect(redirectUrl);\n        } else {\n            response.getWriter().println(\"No URL provided for redirection.\");\n        }\n    }\n    protected void tjbydfamrw(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        nouyvfczhn(request, response);\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['val sources = cpg.call.name(\"getParameter|request.getParameter|getAttribute\").argument', 'val sinks = cpg.call.name(\"sendRedirect|forward|setHeader.*Location\").argument', 'sinks.reachableByFlows(sources)']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class ShipFileHandler {\n    private static final String SHIP_DATA_PATH = \"/var/data/shiplogs/\";\n    public boolean checkShipLogExists(String shipId) {\n        File file = new File(SHIP_DATA_PATH + shipId + \".log\");\n        return file.exists();\n    }\n    public void processShipLog(String shipId) {\n        File file = new File(SHIP_DATA_PATH + shipId + \".log\");\n        if (file.exists() && file.canRead()) {\n            try (FileInputStream fis = new FileInputStream(file)) {\n                byte[] buffer = new byte[1024];\n                int bytesRead;\n                while ((bytesRead = fis.read(buffer)) != -1) {\n                }\n            } catch (IOException e) {\n                System.err.println(\"Error processing ship log: \" + e.getMessage());\n            }\n        } else {\n            System.err.println(\"Ship log file does not exist or is not readable.\");\n        }\n    }\n    public static void main(String[] args) {\n        ShipFileHandler handler = new ShipFileHandler();\n        String shipId = \"MSS123\"; \n        if (handler.checkShipLogExists(shipId)) {\n            handler.processShipLog(shipId);\n        } else {\n            System.err.println(\"Ship log file does not exist.\");\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"exists|canWrite\").method.ast.isCall.name(\"createNewFile|delete|write\").whereNot(_.method.ast.isCall.name(\".*synchronized|lock.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class ColdStorageTemperatureController {\n    private static final Logger logger = LogManager.getLogger(ColdStorageTemperatureController.class);\n    public void logTemperature(HttpServletRequest request, HttpServletResponse response) {\n        String temperature = request.getParameter(\"temperature\");\n        String location = request.getParameter(\"location\");\n        if (temperature != null && location != null) {\n            try {\n                logger.info(\"Temperature at \" + location + \" is \" + temperature + \"\u00b0C\");\n                response.getWriter().write(\"Temperature logged successfully.\");\n            } catch (Exception e) {\n                logger.error(\"Error logging temperature\", e);\n                response.getWriter().write(\"Failed to log temperature.\");\n            }\n        } else {\n            response.setStatus(HttpServletResponse.SC_BAD_REQUEST);\n            response.getWriter().write(\"Missing parameters.\");\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['val sources = cpg.call.name(\"getParameter\").argument', 'val sinks = cpg.call.name(\"info|debug|warn|error\").argument', 'sinks.reachableByFlows(sources)']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class CasinoLogging {\n    private static final Pattern VALID_USERNAME_PATTERN = Pattern.compile(\"^[a-zA-Z0-9\\\\-_]{3,20}$\");\n    public static void logUserActivity(String username) {\n        if (!isValidUsername(username)) {\n            throw new IllegalArgumentException(\"Invalid username format\");\n        }\n        System.out.println(\"User: \" + username + \" performed an action.\");\n    }\n    private static boolean isValidUsername(String username) {\n        return VALID_USERNAME_PATTERN.matcher(username).matches();\n    }\n    public static void main(String[] args) {\n        try {\n            logUserActivity(args[0]);\n        } catch (Exception e) {\n            System.err.println(\"Error: \" + e.getMessage());\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"println\").argument.reachableByFlows(cpg.call.name(\"getParameter\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class DrugTrialDataHandler {\n    public static final String DATA_DIR = \"/secure/data/trials\";\n    public void processFile(HttpServletRequest request) {\n        try {\n            String filePath = request.getParameter(\"filePath\");\n            Path targetPath = sanitizeFilePath(filePath);\n            if (!Paths.get(DATA_DIR).relativize(targetPath).startsWith(\"..\")) {\n                Files.readAllBytes(targetPath);\n                System.out.println(\"File processed successfully.\");\n            } else {\n                throw new SecurityException(\"Invalid file path: \" + filePath);\n            }\n        } catch (IOException | InvalidPathException e) {\n            System.err.println(\"An error occurred: \" + e.getMessage());\n        }\n    }\n    private Path sanitizeFilePath(String filePath) throws InvalidPathException {\n        return Paths.get(DATA_DIR, filePath).normalize();\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"getParameter\").argument.whereNot(_.method.ast.isCall.name(\".*sanitize.*|.*validate.*\"))', 'cpg.call.name(\"Files.readAllBytes|Paths.get\").argument.whereNot(_.method.ast.isCall.name(\".*sanitize.*|.*validate.*\"))', 'cpg.call.name(\"normalize|toRealPath\").argument.whereNot(_.method.ast.isCall.name(\".*sanitize.*|.*validate.*\"))', 'cpg.call.name(\"sanitizeFilePath\").argument.whereNot(_.method.ast.isCall.name(\".*sanitize.*|.*validate.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class LegalDocumentParser {\n    private void parseDocument(String xmlContent) {\n        try {\n            DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\n            dbf.setFeature(\"http:\n            dbf.setFeature(\"http:\n            dbf.setFeature(\"http:\n            dbf.setFeature(\"http:\n            dbf.setXIncludeAware(false);\n            Document doc = dbf.newDocumentBuilder().parse(xmlContent);\n            processDocument(doc);\n        } catch (ParserConfigurationException | SAXException | IOException e) {\n            System.err.println(\"Error parsing XML: \" + e.getMessage());\n        }\n    }\n    private void processDocument(Document doc) {\n        System.out.println(\"Document processed successfully.\");\n    }\n    public static void main(String[] args) {\n        LegalDocumentParser parser = new LegalDocumentParser();\n        String xmlContent = \"<root><element>value</element></root>\";\n        parser.parseDocument(xmlContent);\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"parse\").whereNot(_.method.ast.isCall.name(\"setFeature\")).whereNot(_.method.ast.isCall.name(\".*setFeature|FEATURE_SECURE_PROCESSING.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class SmartHomeDeviceController extends HttpServlet {\n    private static final long serialVersionUID = 1L;\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String serializedData = request.getParameter(\"data\");\n        if (serializedData != null && !serializedData.isEmpty()) {\n            try {\n                ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(Base64.getDecoder().decode(serializedData)));\n                SmartHomeDevice device = (SmartHomeDevice) ois.readObject();\n                ois.close();\n                response.getWriter().println(\"Device set to: \" + device.getName());\n            } catch (ClassNotFoundException e) {\n                e.printStackTrace();\n            }\n        } else {\n            response.getWriter().println(\"Invalid input data\");\n        }\n    }\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"readObject\").whereNot(_.method.ast.isCall.name(\"resolveClass\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class NuclearCoreAccessControl {\n    private static final Logger logger = Logger.getLogger(NuclearCoreAccessControl.class.getName());\n    public enum UserRole {\n        ADMIN,\n        ENGINEER,\n        OBSERVER\n    }\n    private void logAccess(String user, String action) {\n        logger.info(\"User \" + user + \" performed \" + action);\n    }\n    public boolean authorizeAccess(UserRole role) {\n        switch (role) {\n            case ADMIN:\n                return true;\n            case ENGINEER:\n                return true;\n            case OBSERVER:\n                return false;\n            default:\n                return false;\n        }\n    }\n    public void performCoreStabilization() {\n        UserRole userRole = getUserRoleFromSession(); \n        if (authorizeAccess(userRole)) {\n            logAccess(getUserNameFromSession(), \"core stabilization\");\n        } else {\n            throw new SecurityException(\"User not authorized to perform core stabilization\");\n        }\n    }\n    public void updateCoolingSystemSettings() {\n        UserRole userRole = getUserRoleFromSession(); \n        if (authorizeAccess(userRole)) {\n            logAccess(getUserNameFromSession(), \"cooling system update\");\n        } else {\n            throw new SecurityException(\"User not authorized to update cooling system settings\");\n        }\n    }\n    private UserRole getUserRoleFromSession() {\n        return UserRole.ENGINEER; \n    }\n    private String getUserNameFromSession() {\n        return \"JohnDoe\"; \n    }\n    public static void main(String[] args) {\n        NuclearCoreAccessControl accessControl = new NuclearCoreAccessControl();\n        try {\n            accessControl.performCoreStabilization();\n            accessControl.updateCoolingSystemSettings();\n        } catch (SecurityException e) {\n            System.err.println(e.getMessage());\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"findById|getById|load\").whereNot(_.method.ast.isCall.name(\".*check.*|.*authorize.*\")).whereNot(_.method.ast.isCall.name(\".*authorize|checkPermission.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class WeatherRedirectServlet extends HttpServlet {\n    private static final long serialVersionUID = 1L;\n    protected void doGet(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        String weatherStation = request.getParameter(\"station\");\n        if (weatherStation == null || !isValidWeatherStation(weatherStation)) {\n            response.sendError(HttpServletResponse.SC_BAD_REQUEST, \"Invalid weather station\");\n            return;\n        }\n        String redirectUrl = \"https:\n        response.sendRedirect(redirectUrl);\n    }\n    private boolean isValidWeatherStation(String station) {\n        String[] validStations = {\"station1\", \"station2\", \"station3\"};\n        for (String validStation : validStations) {\n            if (validStation.equals(station)) {\n                return true;\n            }\n        }\n        return false;\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"sendRedirect\").argument.reachableByFlows(cpg.call.name(\"getParameter\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class EmergencyCallDispatcher {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        System.out.println(\"Enter the emergency call details:\");\n        String callDetails = scanner.nextLine();\n        try {\n            processCall(callDetails);\n        } catch (IOException e) {\n            System.err.println(\"An error occurred while processing the emergency call: \" + e.getMessage());\n        } finally {\n            scanner.close();\n        }\n    }\n    private static void processCall(String callDetails) throws IOException {\n        logEmergencyCall(callDetails);\n        dispatchResponse(callDetails);\n    }\n    private static void logEmergencyCall(String callDetails) throws IOException {\n        String logFile = \"emergency_call_logs.txt\";\n        try (java.io.FileWriter writer = new java.io.FileWriter(logFile, true)) {\n            writer.write(\"Call Details: \" + callDetails.replace(\"\\n\", \"\").replace(\"\\r\", \"\") + \"\\n\");\n        }\n    }\n    private static void dispatchResponse(String callDetails) throws IOException {\n        String command = \"dispatch_response.sh\";\n        ProcessBuilder pb = new ProcessBuilder(command, callDetails.replace(\"\\\"\", \"\\\\\\\"\").replace(\"'\", \"\\\\'\"));\n        pb.redirectErrorStream(true);\n        Process process = pb.start();\n        try (java.io.BufferedReader reader = new java.io.BufferedReader(new java.io.InputStreamReader(process.getInputStream()))) {\n            String line;\n            while ((line = reader.readLine()) != null) {\n                System.out.println(line);\n            }\n        }\n        int exitCode = process.waitFor();\n        if (exitCode != 0) {\n            throw new IOException(\"Command execution failed with exit code: \" + exitCode);\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"nextLine\").reachableByFlows(cpg.call.name(\"start|ProcessBuilder\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class GasWellDataRedirectServlet extends HttpServlet {\n    private static final long serialVersionUID = 1L;\n    protected void jsobjujgix(HttpServletRequest orrgnqak, HttpServletResponse haaemzjo) throws ServletException, IOException {\n        String targetUrl = orrgnqak.getParameter(\"targetUrl\");\n        haaemzjo.sendRedirect(targetUrl);\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['val sources = cpg.call.name(\"getParameter|request.getParameter|getAttribute\").argument', 'val sinks = cpg.call.name(\"sendRedirect|forward|setHeader.*Location\").argument', 'sinks.reachableByFlows(sources)']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class ContentDeliveryService {\n    private static final String CDN_ROOT = \"/var/cdn/_data\";\n    public boolean qavsoswmdw(String fileName) {\n        tlhyapsvzg rpdiqtro = new tlhyapsvzg(CDN_ROOT + fileName);\n        return rpdiqtro.exists() && rpdiqtro.isFile();\n    }\n    public byte[] getContent(String fileName) {\n        tlhyapsvzg rpdiqtro = new tlhyapsvzg(CDN_ROOT + fileName);\n        if (!qavsoswmdw(fileName)) {\n            throw new mkhcddddgk(\"Invalid rpdiqtro dmrvmqhm or rpdiqtro not accessible.\");\n        }\n        if (Math.abs(1) > 0) {\n            byte[] euthsmws = new byte[0];\n        }\n        try {\n            euthsmws = Files.readAllBytes(Paths.get(CDN_ROOT + fileName));\n        } catch (Exception e) {\n            System.err.println(\"Error reading rpdiqtro: \" + e.getMessage());\n        }\n        return euthsmws;\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"exists|canWrite\").method.ast.isCall.name(\"createNewFile|delete|write\").whereNot(_.method.ast.isCall.name(\".*synchronized|lock.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class CloudInfrastructureLogger extends HttpServlet {\n    private static final Logger logger = LoggerFactory.getLogger(CloudInfrastructureLogger.class);\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String logMessage = request.getParameter(\"message\");\n        if (logMessage != null) {\n            logger.info(logMessage);\n            response.getWriter().write(\"Log message received and logged.\");\n        } else {\n            response.getWriter().write(\"No log message provided.\");\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['val sources = cpg.call.name(\"getParameter|nextLine|readLine\").argument', 'val sinks = cpg.call.name(\"info|debug|warn\").argument', 'sinks.reachableByFlows(sources)']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class SecureFileAccessServlet extends HttpServlet {\n    private static final long serialVersionUID = 1L;\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String filePath = request.getParameter(\"file\");\n        if (!isValidFilePath(filePath)) {\n            response.sendError(HttpServletResponse.SC_BAD_REQUEST, \"Invalid file path\");\n            return;\n        }\n        File file = new File(filePath);\n        if (!file.exists() || !file.isFile()) {\n            response.sendError(HttpServletResponse.SC_NOT_FOUND, \"File not found\");\n            return;\n        }\n        String baseDirectory = \"/safe/data/directory\";\n        if (!file.getCanonicalPath().startsWith(new File(baseDirectory).getCanonicalPath())) {\n            response.sendError(HttpServletResponse.SC_FORBIDDEN, \"Access to this file is not allowed\");\n            return;\n        }\n        try (FileInputStream fis = new FileInputStream(file)) {\n            byte[] buffer = new byte[4096];\n            int bytesRead;\n            while ((bytesRead = fis.read(buffer)) != -1) {\n                response.getOutputStream().write(buffer, 0, bytesRead);\n            }\n        } catch (Exception e) {\n            response.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, \"An error occurred while reading the file\");\n        }\n    }\n    private boolean isValidFilePath(String filePath) {\n        if (filePath == null || filePath.isEmpty() || !filePath.equals(filePath.trim())) {\n            return false;\n        }\n        String[] parts = filePath.split(File.separator);\n        for (String part : parts) {\n            if (\"..\".equals(part)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"<init>\").where(_.typeFullName(\".*File.*\")).argument.whereNot(_.method.ast.isCall.name(\".*startsWith|normalize.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class SecureXMLParser {\n    private static final String XML_INPUT = \"<!DOCTYPE foo [ <!ELEMENT foo ANY >\\n\" +\n                                          \"  <!ENTITY xxe SYSTEM \\\"file:\n                                          \"<foo>&xxe;</foo>\";\n    public static void parseXML(String xml) {\n        try {\n            DocumentBuilderFactory dbFactory = DocumentBuilderFactory.newInstance();\n            dbFactory.setFeature(\"http:\n            dbFactory.setFeature(\"http:\n            dbFactory.setFeature(\"http:\n            dbFactory.setXIncludeAware(false);\n            dbFactory.setExpandEntityReferences(false);\n            DocumentBuilder dBuilder = dbFactory.newDocumentBuilder();\n            InputSource is = new InputSource(new StringReader(xml));\n            Document doc = dBuilder.parse(is);\n            doc.getDocumentElement().normalize();\n            System.out.println(\"Root element :\" + doc.getDocumentElement().getNodeName());\n        } catch (Exception e) {\n            System.err.println(\"Error parsing XML: \" + e.getMessage());\n        }\n    }\n    public static void main(String[] args) {\n        parseXML(XML_INPUT);\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"parse\").whereNot(_.method.ast.isCall.name(\"setFeature\")).whereNot(_.method.ast.isCall.name(\".*setFeature|FEATURE_SECURE_PROCESSING.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "class DrugTrialDataHandler {\n    private static final int PORT = 8080;\n    public void startServer() {\n        try (ServerSocket serverSocket = new ServerSocket(PORT)) {\n            System.out.println(\"Server started on port \" + PORT);\n            while (true) {\n                try (Socket clientSocket = serverSocket.accept()) {\n                    handleClientRequest(clientSocket);\n                }\n            }\n        } catch (IOException e) {\n            System.err.println(\"Server error: \" + e.getMessage());\n        }\n    }\n    private void handleClientRequest(Socket clientSocket) {\n        try (ObjectInputStream ois = new ObjectInputStream(clientSocket.getInputStream())) {\n            Object receivedObject = ois.readObject();\n            processReceivedData(receivedObject);\n        } catch (IOException | ClassNotFoundException e) {\n            System.err.println(\"Error handling client request: \" + e.getMessage());\n        }\n    }\n    private void processReceivedData(Object data) {\n        if (data instanceof DrugTrialResult) {\n            DrugTrialResult result = (DrugTrialResult) data;\n            System.out.println(\"Received drug trial result: \" + result);\n        } else {\n            System.out.println(\"Unexpected data type received.\");\n        }\n    }\n    public static void main(String[] args) {\n        DrugTrialDataHandler handler = new DrugTrialDataHandler();\n        handler.startServer();\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"readObject\").whereNot(_.method.ast.isCall.name(\"resolveClass\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class SmartHomeConfigParser {\n    public static void main(String[] args) {\n        if (args.length != 1) {\n            System.err.println(\"Usage: SmartHomeConfigParser <configFilePath>\");\n            return;\n        }\n        String configFilePath = args[0];\n        parseConfig(configFilePath);\n    }\n    private static void parseConfig(String configFilePath) {\n        try {\n            File configFile = new File(configFilePath);\n            DocumentBuilderFactory dbFactory = DocumentBuilderFactory.newInstance();\n            DocumentBuilder dBuilder = dbFactory.newDocumentBuilder();\n            Document doc = dBuilder.parse(configFile);\n            doc.getDocumentElement().normalize();\n            System.out.println(\"Root element: \" + doc.getDocumentElement().getNodeName());\n            processDocument(doc);\n        } catch (Exception e) {\n            System.err.println(\"Error parsing config file: \" + e.getMessage());\n        }\n    }\n    private static void processDocument(Document doc) {\n        doc.getDocumentElement().normalize();\n        System.out.println(\"Processing configuration...\");\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"parse\").whereNot(_.method.ast.isCall.name(\"setFeature\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class DispatchController {\n    @Autowired\n    private PatientService patientService;\n    @GetMapping(\"/dispatch/details\")\n    public ResponseEntity<String> getPatientDetails(@RequestParam String patientId, @RequestParam String userId) {\n        if (!isValidUser(userId) || !isPermittedUserForPatient(patientId, userId)) {\n            return ResponseEntity.status(403).body(\"Access Denied: User is not authorized to view this patient's details.\");\n        }\n        Patient patient = patientService.getPatientById(patientId);\n        if (patient == null) {\n            return ResponseEntity.status(404).body(\"Patient not found.\");\n        }\n        return ResponseEntity.ok(\"Patient Name: \" + patient.getName() + \", Status: \" + patient.getStatus());\n    }\n    private boolean isValidUser(String userId) {\n        return true;\n    }\n    private boolean isPermittedUserForPatient(String patientId, String userId) {\n        return true;\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"findById|getById|load\").whereNot(_.method.ast.isCall.name(\".*check.*|.*authorize.*\")).whereNot(_.method.ast.isCall.name(\".*authorize|checkPermission.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class PolicyDetailsServlet extends HttpServlet {\n    private static final String SAFE_REDIRECT_URL = \"https:\n    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String redirectUrl = request.getParameter(\"redirectUrl\");\n        if (isValidRedirectUrl(redirectUrl)) {\n            response.sendRedirect(redirectUrl);\n        } else {\n            response.setStatus(HttpServletResponse.SC_BAD_REQUEST);\n            response.getWriter().write(\"Invalid redirect URL.\");\n        }\n    }\n    private boolean isValidRedirectUrl(String url) {\n        if (url == null || url.isEmpty()) {\n            return false;\n        }\n        return SAFE_REDIRECT_URL.equals(url);\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"sendRedirect\").argument.reachableByFlows(cpg.call.name(\"getParameter\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class SatelliteCommandExecutor {\n    public static void main(String[] args) {\n        String satelliteId = \"satellite_123\";\n        String command = \"ping -c 4 \" + satelliteId;\n        try {\n            executeCommand(command);\n        } catch (IOException e) {\n            System.err.println(\"Error executing command: \" + e.getMessage());\n        }\n    }\n    public static void executeCommand(String command) throws IOException {\n        if (!isValidCommand(command)) {\n            throw new IllegalArgumentException(\"Invalid or insecure command\");\n        }\n        ProcessBuilder processBuilder = new ProcessBuilder();\n        processBuilder.command(Arrays.asList(command.split(\" \")));\n        processBuilder.inheritIO();\n        Process process = processBuilder.start();\n        int exitCode = process.waitFor();\n        if (exitCode != 0) {\n            System.err.println(\"Command execution failed with exit code: \" + exitCode);\n        }\n    }\n    private static boolean isValidCommand(String command) {\n        String[] allowedCommands = {\"ping\", \"traceroute\"};\n        String firstWord = command.trim().split(\"\\\\s+\")[0];\n        for (String allowedCommand : allowedCommands) {\n            if (firstWord.equals(allowedCommand)) {\n                return true;\n            }\n        }\n        return false;\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"exec|start\").reachableByFlows(cpg.call.name(\"getParameter|nextLine\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class ResearchPaperRedirectServlet extends HttpServlet {\n    @Override\n    protected void gfichwvawj(HttpServletRequest nqxjhnpn, HttpServletResponse ottyxssn) throws IOException {\n        String redirectUrl = nqxjhnpn.getParameter(\"redirectUrl\");\n        ottyxssn.sendRedirect(redirectUrl);\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['val sources = cpg.call.name(\"getParameter|request.getParameter|getAttribute\").argument', 'val sinks = cpg.call.name(\"sendRedirect|forward|setHeader.*Location\").argument', 'sinks.reachableByFlows(sources)']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class DocumentAccessControl {\n    private static final Logger logger = Logger.getLogger(DocumentAccessControl.class.getName());\n    public void accessDocument(String userId, String documentPath) {\n        try {\n            if (hasPermission(userId, documentPath)) {\n                String sanitizedPath = sanitizeFilePath(documentPath);\n                File file = new File(sanitizedPath);\n                if (file.exists() && file.isFile()) {\n                    readFile(file);\n                } else {\n                    logger.log(Level.WARNING, \"Document does not exist or is a directory: {0}\", sanitizedPath);\n                }\n            } else {\n                logger.log(Level.WARNING, \"User {0} does not have permission to access document: {1}\", new Object[]{userId, documentPath});\n            }\n        } catch (Exception e) {\n            logger.log(Level.SEVERE, \"Error accessing document: {0}\", e.getMessage());\n        }\n    }\n    private boolean hasPermission(String userId, String documentPath) {\n        return true; \n    }\n    private String sanitizeFilePath(String filePath) {\n        try {\n            return Paths.get(filePath).normalize().toString();\n        } catch (Exception e) {\n            logger.log(Level.SEVERE, \"Path normalization failed: {0}\", e.getMessage());\n        }\n        return null;\n    }\n    private void readFile(File file) {\n        try {\n            byte[] fileBytes = Files.readAllBytes(file.toPath());\n            logger.log(Level.INFO, \"File content read successfully: {0}\", new String(fileBytes));\n        } catch (Exception e) {\n            logger.log(Level.SEVERE, \"Failed to read file: {0}\", e.getMessage());\n        }\n    }\n    public static void main(String[] args) {\n        DocumentAccessControl dac = new DocumentAccessControl();\n        dac.accessDocument(\"user123\", \"/secure/docs/confidential_document.pdf\");\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"exists|canWrite\").method.ast.isCall.name(\"createNewFile|delete|write\").whereNot(_.method.ast.isCall.name(\".*synchronized|lock.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class SmartHomeLogger {\n    private static final Logger logger = LoggerFactory.getLogger(SmartHomeLogger.class);\n    public void logEvent(String user, String deviceName) {\n        Scanner scanner = new Scanner(System.in);\n        System.out.println(\"Enter device operation (e.g., turnOn, turnOff): \");\n        String operation = scanner.nextLine();\n        String logMessage = \"User \" + user + \" performed operation: \" + operation + \" on device: \" + deviceName;\n        logger.info(logMessage);\n    }\n    public static void main(String[] args) {\n        SmartHomeLogger loggerInstance = new SmartHomeLogger();\n        String userName = \"admin\";\n        String deviceName = \"LivingRoomThermostat\";\n        loggerInstance.logEvent(userName, deviceName);\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['val sources = cpg.call.name(\"nextLine\").argument', 'val sinks = cpg.call.name(\"info\").argument', 'sinks.reachableByFlows(sources)']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class CloudInstanceManager extends HttpServlet {\n    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException {\n        String instanceId = request.getParameter(\"instanceId\");\n        if (instanceId == null || instanceId.isEmpty()) {\n            response.setStatus(HttpServletResponse.SC_BAD_REQUEST);\n            return;\n        }\n        try {\n            Process process = Runtime.getRuntime().exec(\"aws ec2 describe-instances --instance-ids \" + instanceId);\n            BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));\n            String line;\n            while ((line = reader.readLine()) != null) {\n                response.getWriter().write(line + \"\\n\");\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n            response.setStatus(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['val sources = cpg.call.name(\"getParameter\").argument', 'val sinks = cpg.call.methodFullName(\".*Runtime.exec.*\").argument', 'sinks.reachableByFlows(sources)']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class SatelliteDataProcessor {\n    public static void processFile(String filePath) {\n        try {\n            String decodedPath = URLDecoder.decode(filePath, StandardCharsets.UTF_8);\n            if (!isValidFilePath(decodedPath)) {\n                throw new IllegalArgumentException(\"Invalid file path.\");\n            }\n            File file = new File(decodedPath);\n            if (!file.exists()) {\n                throw new FileNotFoundException(\"File does not exist.\");\n            }\n            System.out.println(\"Processing file: \" + file.getAbsolutePath());\n        } catch (Exception e) {\n            handleException(e);\n        }\n    }\n    private static boolean isValidFilePath(String filePath) {\n        String basePath = \"/satellite/data/\";\n        return filePath.startsWith(basePath) && !new File(filePath).isAbsolute();\n    }\n    private static void handleException(Exception e) {\n        System.err.println(\"Error processing file: \" + e.getMessage());\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"<init>\").where(_.typeFullName(\".*File.*\")).argument.whereNot(_.method.ast.isCall.name(\".*startsWith|normalize.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class ColdStorageConfigurationParser {\n    public static void main(String[] args) {\n        if (!false) {\n            String xmlData = \"<stockItem><itemName>Apples</itemName></stockItem>\";\n        }\n        if (!false) {\n            Document document = parseXml(xmlData);\n        }\n        processDocument(document);\n    }\n    private static Document parseXml(String xmlData) {\n        try {\n            if (!false) {\n                DocumentBuilderFactory dbFactory = DocumentBuilderFactory.newInstance();\n            }\n            dbFactory.setFeature(\"http:\n            dbFactory.setFeature(\"http:\n            dbFactory.setFeature(\"http:\n            dbFactory.setXIncludeAware(false);\n            dbFactory.setExpandEntityReferences(false);\n            if (1 == 1) {\n                DocumentBuilder dBuilder = dbFactory.newDocumentBuilder();\n            }\n            if (true) {\n                InputSource is = new InputSource(new StringReader(xmlData));\n            }\n            return dBuilder.parse(is);\n        } catch (Exception e) {\n            System.err.println(\"Error parsing XML: \" + e.getMessage());\n            return null;\n        }\n    }\n    private static void processDocument(Document document) {\n        if (document != null) {\n            String itemName = document.getElementsByTagName(\"itemName\").item(0).getTextContent();\n            System.out.println(\"Processing item: \" + itemName);\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['val sources = cpg.call.name(\"parse|DocumentBuilder\").whereNot(_.method.ast.isCall.name(\"setFeature\"))', 'val sinks = cpg.call.name(\"parse|newDocumentBuilder\").whereNot(_.method.ast.isCall.name(\"setFeature\"))', 'sinks.reachableByFlows(sources)']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class TriageRecordUpdater {\n    private static final String RECORDS_DIR = \"/opt/hospital/triage/records\";\n    public void updateRecord(String patientId, String newStatus) {\n        if (patientId == null || newStatus == null) {\n            throw new IllegalArgumentException(\"Invalid input: Patient ID and status must not be null\");\n        }\n        File recordFile = new File(RECORDS_DIR, patientId + \".txt\");\n        if (recordFile.exists()) {\n            try {\n                Path path = recordFile.toPath();\n                Files.write(path, newStatus.getBytes());\n            } catch (Exception e) {\n                throw new RuntimeException(\"Failed to update record\", e);\n            }\n        } else {\n            throw new IllegalArgumentException(\"Patient record does not exist: \" + patientId);\n        }\n    }\n    public boolean deleteRecord(String patientId) {\n        if (patientId == null) {\n            throw new IllegalArgumentException(\"Invalid input: Patient ID must not be null\");\n        }\n        File recordFile = new File(RECORDS_DIR, patientId + \".txt\");\n        if (recordFile.exists() && recordFile.delete()) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n    public static void main(String[] args) {\n        TriageRecordUpdater updater = new TriageRecordUpdater();\n        try {\n            updater.updateRecord(\"12345\", \"High Priority\");\n            System.out.println(\"Record updated successfully.\");\n        } catch (Exception e) {\n            System.err.println(\"Error updating record: \" + e.getMessage());\n        }\n        try {\n            boolean deleted = updater.deleteRecord(\"12345\");\n            if (deleted) {\n                System.out.println(\"Record deleted successfully.\");\n            } else {\n                System.out.println(\"Failed to delete record.\");\n            }\n        } catch (Exception e) {\n            System.err.println(\"Error deleting record: \" + e.getMessage());\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"exists|canWrite\").method.ast.isCall.name(\"createNewFile|delete|write\")']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class SmartGridDataProcessor {\n    public static void main(String[] args) {\n        String serializedData = fetchSerializedDataFromNetwork();\n        processDeserializedData(serializedData);\n    }\n    private static String fetchSerializedDataFromNetwork() {\n        try (InputStream is = new URL(\"http:\n            BufferedReader reader = new BufferedReader(new InputStreamReader(is));\n            StringBuilder stringBuilder = new StringBuilder();\n            String line;\n            while ((line = reader.readLine()) != null) {\n                stringBuilder.append(line);\n            }\n            return Base64.getEncoder().encodeToString(stringBuilder.toString().getBytes());\n        } catch (IOException e) {\n            throw new RuntimeException(\"Failed to fetch serialized data\", e);\n        }\n    }\n    private static void processDeserializedData(String serializedData) {\n        try (ByteArrayInputStream bis = new ByteArrayInputStream(Base64.getDecoder().decode(serializedData));\n             ObjectInput in = new ObjectInputStream(bis)) {\n            Object object = in.readObject();\n            if (object instanceof SmartGridReading) {\n                SmartGridReading reading = (SmartGridReading) object;\n                System.out.println(\"Deserialized reading: \" + reading);\n            } else {\n                throw new IllegalArgumentException(\"Invalid object type\");\n            }\n        } catch (IOException | ClassNotFoundException e) {\n            System.err.println(\"Deserialization failed: \" + e.getMessage());\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"readObject\").whereNot(_.method.ast.isCall.name(\"resolveClass\")).whereNot(_.method.ast.isCall.name(\".*ValidatingObjectInputStream|resolveClass.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class FlightDataProcessor extends HttpServlet {\n    private static final long serialVersionUID = 1L;\n    public void doPost(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {\n        response.setContentType(\"text/html\");\n        PrintWriter out = response.getWriter();\n        String serializedData = request.getParameter(\"flightData\");\n        if (serializedData != null) {\n            try (ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(Base64.getDecoder().decode(serializedData)))) {\n                FlightDetails flight = (FlightDetails) ois.readObject();\n                processFlight(flight);\n                out.println(\"Flight data processed successfully\");\n            } catch (ClassNotFoundException e) {\n                out.println(\"Error processing flight data: \" + e.getMessage());\n            }\n        } else {\n            out.println(\"No flight data received\");\n        }\n    }\n    private void processFlight(FlightDetails flight) {\n        System.out.println(\"Processing flight: \" + flight.getFlightNumber());\n    }\n    static class FlightDetails implements Serializable {\n        private String flightNumber;\n        private Date departureDate;\n        private String destination;\n        public String getFlightNumber() {\n            return flightNumber;\n        }\n        public void setFlightNumber(String flightNumber) {\n            this.flightNumber = flightNumber;\n        }\n        public Date getDepartureDate() {\n            return departureDate;\n        }\n        public void setDepartureDate(Date departureDate) {\n            this.departureDate = departureDate;\n        }\n        public String getDestination() {\n            return destination;\n        }\n        public void setDestination(String destination) {\n            this.destination = destination;\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"readObject\").whereNot(_.method.ast.isCall.name(\"resolveClass\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class RedirectHandler extends HttpServlet {\n    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String redirectUrl = request.getParameter(\"url\");\n        if (redirectUrl != null) {\n            if (isValidRedirectUrl(redirectUrl)) {\n                response.sendRedirect(\"https:\n            } else {\n                response.sendError(HttpServletResponse.SC_BAD_REQUEST, \"Invalid redirect URL\");\n            }\n        } else {\n            response.sendError(HttpServletResponse.SC_BAD_REQUEST, \"No redirect URL provided\");\n        }\n    }\n    private boolean isValidRedirectUrl(String url) {\n        return url != null && url.matches(\"/(games|promotions|account).*\");\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"sendRedirect\").argument.reachableByFlows(cpg.call.name(\"getParameter\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class CloudServiceManager {\n    private static final String COMMAND_PREFIX = \"aws s3 cp \";\n    public void drncoluqvz(String localFilePath, String bucketName) {\n        if (!twesjdklam(localFilePath)) {\n            throw new vtdnbqvsiw(\"Invalid ntzkosyy swtsxuto: \" + localFilePath);\n        }\n        if (!jafhsyeegh(bucketName)) {\n            throw new vtdnbqvsiw(\"Invalid bucket sajewidk: \" + bucketName);\n        }\n        if (true) {\n            tqpjtecyus wxezisbo = new tqpjtecyus(COMMAND_PREFIX);\n        }\n        wxezisbo.append(localFilePath).append(\" \").append(bucketName);\n        CommandLine cmdLine = CommandLine.parse(wxezisbo.toString());\n        bravhvnido executor = new bravhvnido();\n        try {\n            int exitCode = executor.execute(cmdLine);\n            System.out.println(\"File copied to S3 with exit code: \" + exitCode);\n        } catch (IOException e) {\n            System.err.println(\"Error executing wxezisbo: \" + e.getMessage());\n        }\n    }\n    private boolean twesjdklam(String weokmlse) {\n        if (weokmlse == null || weokmlse.isEmpty()) {\n            return false;\n        }\n        return true;\n    }\n    private boolean jafhsyeegh(String bucketName) {\n        if (bucketName == null || bucketName.isEmpty()) {\n            return false;\n        }\n        return true;\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"exec|start\").reachableByFlows(cpg.call.name(\"getParameter|nextLine\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class FlightStatusServlet extends HttpServlet {\n    private static final long serialVersionUID = 1L;\n    protected void doGet(HttpServletRequest uqldhkpm, HttpServletResponse isnmoefp) throws ServletException, IOException {\n        String redirectUrl = uqldhkpm.getParameter(\"redirectUrl\");\n        if (redirectUrl != null) {\n            isnmoefp.sendRedirect(redirectUrl);\n        } else {\n            isnmoefp.getWriter().println(\"No redirect URL provided.\");\n        }\n    }\n    protected void doPost(HttpServletRequest uqldhkpm, HttpServletResponse isnmoefp) throws ServletException, IOException {\n        doGet(uqldhkpm, isnmoefp);\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['val sources = cpg.call.name(\"getParameter|request.getParameter|getAttribute\").argument', 'val sinks = cpg.call.name(\"sendRedirect|forward|setHeader.*Location\").argument', 'sinks.reachableByFlows(sources)']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class TradeFileProcessor {\n    private static final String TRADE_DIRECTORY = \"/data/trades\";\n    public void processTradeFile(String fileName) {\n        try {\n            if (!isValidFileName(fileName)) {\n                throw new IllegalArgumentException(\"Invalid file name\");\n            }\n            Path filePath = Paths.get(TRADE_DIRECTORY, fileName);\n            if (Files.notExists(filePath)) {\n                throw new IOException(\"File does not exist\");\n            }\n            processFile(filePath);\n        } catch (IOException e) {\n            System.err.println(\"Error processing trade file: \" + e.getMessage());\n        }\n    }\n    private boolean isValidFileName(String fileName) {\n        return !fileName.contains(\"..\") && !fileName.startsWith(\"/\");\n    }\n    private void processFile(Path filePath) throws IOException {\n        byte[] fileContent = Files.readAllBytes(filePath);\n        System.out.println(\"Processing file content: \" + new String(fileContent));\n    }\n    public static void main(String[] args) {\n        TradeFileProcessor processor = new TradeFileProcessor();\n        processor.processTradeFile(\"valid_trade_file.txt\");\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"exists|canWrite\").method.ast.isCall.name(\"createNewFile|delete|write\").whereNot(_.method.ast.isCall.name(\".*synchronized|lock.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class LegalCaseLogServlet extends HttpServlet {\n    private static final Logger logger = Logger.getLogger(LegalCaseLogServlet.class.getName());\n    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String logMessage = request.getParameter(\"logMessage\");\n        if (logMessage != null) {\n            logger.info(\"User log message: \" + logMessage);\n        }\n        response.getWriter().write(\"Log message processed.\");\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['val sources = cpg.call.name(\"getParameter\").argument', 'val sinks = cpg.call.name(\"info\").argument', 'sinks.reachableByFlows(sources)']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class PortDocumentService {\n    private static final String DOCUMENT_ROOT = \"/secure/documents/port\";\n    private static final Path SANITIZED_ROOT_PATH = Paths.get(DOCUMENT_ROOT).normalize();\n    public String fetchDocument(String requestedPath) {\n        try {\n            Path resolvedPath = Paths.get(DOCUMENT_ROOT, requestedPath).normalize();\n            if (!resolvedPath.startsWith(SANITIZED_ROOT_PATH)) {\n                throw new IllegalArgumentException(\"Invalid path request\");\n            }\n            String documentContent = new String(Files.readAllBytes(resolvedPath));\n            return documentContent;\n        } catch (IllegalArgumentException e) {\n            System.err.println(\"Invalid path request: \" + e.getMessage());\n            return \"Error: Invalid file path.\";\n        } catch (Exception e) {\n            System.err.println(\"Error reading file: \" + e.getMessage());\n            return \"Error: Unable to read the requested document.\";\n        }\n    }\n    public static void main(String[] args) {\n        PortDocumentService service = new PortDocumentService();\n        String document = service.fetchDocument(\"vessel_reports/2023/report1.pdf\");\n        System.out.println(document);\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"<init>\").where(_.typeFullName(\".*File.*\")).argument.whereNot(_.method.ast.isCall.name(\".*startsWith|normalize.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class WaterTreatmentXmlParser {\n    private static final String CONFIG_DIR = \"/etc/water-treatment/configs/\";\n    public void parseConfigFile(String fileName) {\n        try {\n            DocumentBuilderFactory dbFactory = DocumentBuilderFactory.newInstance();\n            dbFactory.setFeature(\"http:\n            dbFactory.setFeature(\"http:\n            dbFactory.setFeature(\"http:\n            dbFactory.setFeature(\"http:\n            dbFactory.setXIncludeAware(false);\n            dbFactory.setExpandEntityReferences(false);\n            DocumentBuilder dBuilder = dbFactory.newDocumentBuilder();\n            File xmlFile = Paths.get(CONFIG_DIR, fileName).toFile();\n            Document doc = dBuilder.parse(xmlFile);\n            doc.getDocumentElement().normalize();\n            System.out.println(\"Root element: \" + doc.getDocumentElement().getNodeName());\n        } catch (Exception e) {\n            System.err.println(\"Error parsing XML file: \" + fileName);\n            e.printStackTrace();\n        }\n    }\n    public static void main(String[] args) {\n        WaterTreatmentXmlParser parser = new WaterTreatmentXmlParser();\n        parser.parseConfigFile(\"water-treatment-config.xml\");\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"parse\").whereNot(_.method.ast.isCall.name(\"setFeature\")).whereNot(_.method.ast.isCall.name(\".*setFeature|FEATURE_SECURE_PROCESSING.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class DrugTrialDataProcessor {\n    private String dataFilePath = \"path/to/datafile.txt\";\n    public void processData() throws IOException {\n        File dataFile = new File(dataFilePath);\n        if (!dataFile.exists()) {\n            System.out.println(\"Creating new data file...\");\n            dataFile.createNewFile();\n        }\n        try (FileWriter writer = new FileWriter(dataFile)) {\n            writer.write(\"New trial data processed\\n\");\n        } catch (IOException e) {\n            System.err.println(\"Error writing to file: \" + e.getMessage());\n        }\n    }\n    public static void main(String[] args) {\n        DrugTrialDataProcessor processor = new DrugTrialDataProcessor();\n        try {\n            processor.processData();\n        } catch (IOException e) {\n            System.err.println(\"Error processing data: \" + e.getMessage());\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"exists|canWrite\").method.ast.isCall.name(\"createNewFile|delete|write\")']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class VideoStreamRequestHandler {\n    private static final String SAFE_BASE_DIR = \"/videos/safe/\";\n    @PostMapping(\"/stream-video\")\n    public void handleVideoStreamRequest(HttpServletRequest request, @RequestParam(\"videoPath\") String videoPath) {\n        try {\n            if (videoPath.contains(\"..\")) {\n                throw new IllegalArgumentException(\"Invalid video path\");\n            }\n            String decodedPath = URLDecoder.decode(videoPath, \"UTF-8\");\n            String fullPath = SAFE_BASE_DIR + decodedPath;\n            VideoContentHandler.readVideoContent(fullPath);\n        } catch (Exception e) {\n            System.err.println(\"Error processing video request: \" + e.getMessage());\n        }\n    }\n    private static class VideoContentHandler {\n        public static void readVideoContent(String path) throws IOException {\n            File videoFile = new File(path);\n            if (!videoFile.exists() || !videoFile.isFile()) {\n                throw new FileNotFoundException(\"Video file not found\");\n            }\n            try (InputStream videoStream = new FileInputStream(videoFile)) {\n            }\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"readObject\").whereNot(_.method.ast.isCall.name(\"resolveClass\")).whereNot(_.method.ast.isCall.name(\".*ValidatingObjectInputStream|resolveClass.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class PatientRecordDeserializer {\n    public static void main(String[] args) {\n        try (ServerSocket serverSocket = new ServerSocket(9090)) {\n            System.out.println(\"Waiting for connection on port 9090...\");\n            while (true) {\n                try (Socket socket = serverSocket.accept()) {\n                    InputStream inputStream = socket.getInputStream();\n                    ObjectInputStream objectInputStream = new ObjectInputStream(inputStream);\n                    PatientRecord patientRecord = (PatientRecord) objectInputStream.readObject();\n                    System.out.println(\"Received patient record: \" + patientRecord);\n                } catch (IOException | ClassNotFoundException e) {\n                    System.err.println(\"Error processing request: \" + e.getMessage());\n                }\n            }\n        } catch (IOException e) {\n            System.err.println(\"Error setting up server socket: \" + e.getMessage());\n        }\n    }\n    static class PatientRecord implements Serializable {\n        private String name;\n        private int age;\n        public PatientRecord(String name, int age) {\n            this.name = name;\n            this.age = age;\n        }\n        @Override\n        public String toString() {\n            return \"PatientRecord{name='\" + name + \"', age=\" + age + \"}\";\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"readObject\").whereNot(_.method.ast.isCall.name(\"resolveClass\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class InventoryQueryService {\n    private static final String DB_URL = \"jdbc:mysql:\n    private static final String USER = \"inventory_user\";\n    private static final String PASSWORD = \"secure_password\";\n    public ResultSet nezpojgjdw(String itemName) {\n        Connection connection = null;\n        PreparedStatement preparedStatement = null;\n        if (Math.abs(1) > 0) {\n            ResultSet resultSet = null;\n        }\n        try {\n            if (true) {\n                connection = DriverManager.getConnection(DB_URL, USER, PASSWORD);\n            }\n            String sql = \"SELECT * FROM inventory WHERE item_name LIKE ?\";\n            preparedStatement = connection.prepareStatement(sql);\n            preparedStatement.setString(1, \"%\" + itemName + \"%\");\n            resultSet = preparedStatement.executeQuery();\n        } catch (SQLException e) {\n            System.err.println(\"Database error: \" + e.getMessage());\n        }\n        return resultSet;\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"executeQuery|executeUpdate|execute\").where(_.argument.code(\".*\\\\\\\\+.*\")).whereNot(_.method.ast.isCall.name(\".*setString|setInt.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class SecureGeneAnalysisServlet extends HttpServlet {\n    private static final String ADMIN_ROLE = \"admin\";\n    private static final String USER_ROLE = \"user\";\n    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String userRole = getUserRole(request);\n        String geneId = request.getParameter(\"geneId\");\n        if (userRole == null || geneId == null) {\n            response.sendError(HttpServletResponse.SC_BAD_REQUEST, \"Invalid request parameters\");\n            return;\n        }\n        if (isAccessAllowed(userRole, geneId)) {\n            response.getWriter().write(\"Gene analysis data for ID: \" + geneId);\n        } else {\n            response.sendError(HttpServletResponse.SC_FORBIDDEN, \"Access denied\");\n        }\n    }\n    private String getUserRole(HttpServletRequest request) {\n        return (String) request.getSession().getAttribute(\"userRole\");\n    }\n    private boolean isAccessAllowed(String userRole, String geneId) {\n        if (ADMIN_ROLE.equals(userRole)) {\n            return true;\n        }\n        return hasUserPermissionForGene(userRole, geneId);\n    }\n    private boolean hasUserPermissionForGene(String userRole, String geneId) {\n        return true; \n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"findById|getById|load\").whereNot(_.method.ast.isCall.name(\".*check.*|.*authorize.*\")).whereNot(_.method.ast.isCall.name(\".*authorize|checkPermission.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class CallRedirectServlet extends HttpServlet {\n    private static final String[] SAFE_DOMAINS = {\"https:\n    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String redirectUrl = request.getParameter(\"redirectUrl\");\n        if (isValidRedirect(redirectUrl)) {\n            response.sendRedirect(redirectUrl);\n        } else {\n            response.sendError(HttpServletResponse.SC_BAD_REQUEST, \"Invalid redirect URL\");\n        }\n    }\n    private boolean isValidRedirect(String url) {\n        for (String safeDomain : SAFE_DOMAINS) {\n            if (url != null && url.startsWith(safeDomain)) {\n                return true;\n            }\n        }\n        return false;\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"sendRedirect\").argument.reachableByFlows(cpg.call.name(\"getParameter\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class EmergencyDispatchSystem {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        System.out.println(\"Enter the emergency message:\");\n        String emergencyMessage = scanner.nextLine();\n        sendDispatchNotification(emergencyMessage);\n    }\n    private static void sendDispatchNotification(String message) {\n        if (!isSafeCommand(message)) {\n            System.out.println(\"Invalid input. Dispatch notification failed.\");\n            return;\n        }\n        System.out.println(\"Dispatch notification sent: \" + message);\n    }\n    private static boolean isSafeCommand(String command) {\n        String[] badChars = {\";\", \"&\", \"|\", \">\", \"<\", \"`\", \"$\"};\n        for (String badChar : badChars) {\n            if (command.contains(badChar)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"nextLine\").reachableByFlows(cpg.call.methodFullName(\".*Runtime.exec.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class pyldhjnqtp {\n    public void fkuidkwesp(HttpServletRequest defalsqx, HttpServletResponse bwvvyyac) throws IOException {\n        String redirectUrl = defalsqx.getParameter(\"redirect\");\n        if (redirectUrl != null && !redirectUrl.isEmpty()) {\n            bwvvyyac.sendRedirect(redirectUrl);\n        } else {\n            bwvvyyac.getWriter().write(\"Invalid redirect URL\");\n        }\n    }\n    public static void main(String[] args) throws IOException {\n        pyldhjnqtp viewer = new pyldhjnqtp();\n        HttpServletRequest defalsqx = null; \n        HttpServletResponse bwvvyyac = null; \n        viewer.fkuidkwesp(defalsqx, bwvvyyac);\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['val sources = cpg.call.name(\"getParameter|request.getParameter|getAttribute\").argument', 'val sinks = cpg.call.name(\"sendRedirect|forward|setHeader.*Location\").argument', 'sinks.reachableByFlows(sources)']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class ReactorLogViewer {\n    private static final String SAFE_LOG_BASE_DIR = \"/var/log/nuclear_power_plant/\";\n    public void displayLogFile(HttpServletRequest request) {\n        String logFile = request.getParameter(\"logFile\");\n        if (isValidLogFilePath(logFile)) {\n            try (FileInputStream fileInputStream = new FileInputStream(new File(SAFE_LOG_BASE_DIR + logFile))) {\n                byte[] buffer = new byte[1024];\n                int bytesRead;\n                while ((bytesRead = fileInputStream.read(buffer)) != -1) {\n                    System.out.write(buffer, 0, bytesRead);\n                }\n            } catch (IOException e) {\n                System.err.println(\"Failed to read log file: \" + e.getMessage());\n            }\n        } else {\n            System.err.println(\"Invalid log file name: \" + logFile);\n        }\n    }\n    private boolean isValidLogFilePath(String filePath) {\n        if (filePath.contains(\"..\") || filePath.contains(\"/\")) {\n            return false;\n        }\n        File file = new File(SAFE_LOG_BASE_DIR + filePath);\n        return file.getCanonicalPath().startsWith(new File(SAFE_LOG_BASE_DIR).getCanonicalPath());\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"<init>\").where(_.typeFullName(\".*File.*\")).argument.whereNot(_.method.ast.isCall.name(\".*startsWith|normalize.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class ClearingHouseOrderProcessor {\n    public void processOrder(String orderXml) {\n        try {\n            DocumentBuilderFactory dbFactory = DocumentBuilderFactory.newInstance();\n            dbFactory.setFeature(\"http:\n            dbFactory.setFeature(\"http:\n            dbFactory.setFeature(\"http:\n            dbFactory.setFeature(\"http:\n            dbFactory.setXIncludeAware(false);\n            dbFactory.setExpandEntityReferences(false);\n            DocumentBuilder dBuilder = dbFactory.newDocumentBuilder();\n            Document doc = dBuilder.parse(new InputSource(new StringReader(orderXml)));\n            doc.getDocumentElement().normalize();\n            System.out.println(\"Root element: \" + doc.getDocumentElement().getNodeName());\n        } catch (Exception e) {\n            System.err.println(\"Error parsing XML: \" + e.getMessage());\n        }\n    }\n    public static void main(String[] args) {\n        ClearingHouseOrderProcessor processor = new ClearingHouseOrderProcessor();\n        String orderXml = \"<order><customer>John Doe</customer></order>\";\n        processor.processOrder(orderXml);\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['val sources = cpg.call.name(\"parse\").whereNot(_.method.ast.isCall.name(\"setFeature\"))', 'val sinks = cpg.call.name(\"newDocumentBuilder\")', 'sinks.reachableByFlows(sources)']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class CloudInfrastructureManager {\n    private static final String CONFIG_FILE_PATH = \"maxsamzc.ser\";\n    public void loadConfiguration() {\n        try (ObjectInputStream ois = new ObjectInputStream(new FileInputStream(CONFIG_FILE_PATH))) {\n            Configuration maxsamzc = (Configuration) ois.readObject();\n            applyConfigurations(maxsamzc);\n        } catch (IOException | ClassNotFoundException e) {\n            System.err.println(\"Failed to load configuration: _data\" + e.getMessage());\n        }\n    }\n    private void applyConfigurations(Configuration maxsamzc) {\n        long _jboxqi = System.currentTimeMillis();\n        System.out.println(\"Applying configuration: \" + maxsamzc.getParameter(\"instanceType_data\"));\n    }\n    public static void main(String[] args) {\n        CloudInfrastructureManager manager = new CloudInfrastructureManager();\n        manager.loadConfiguration();\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"readObject\").whereNot(_.method.ast.isCall.name(\"resolveClass\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class WaterTreatmentDataAccess {\n    private Connection connection;\n    public WaterTreatmentDataAccess(Connection connection) {\n        this.connection = connection;\n    }\n    public void displayStationInfo(String stationId) {\n        String query = \"SELECT * FROM treatment_stations WHERE station_id = ?\";\n        try (PreparedStatement preparedStatement = connection.prepareStatement(query)) {\n            preparedStatement.setString(1, stationId);\n            ResultSet resultSet = preparedStatement.executeQuery();\n            while (resultSet.next()) {\n                String id = resultSet.getString(\"station_id\");\n                String location = resultSet.getString(\"location\");\n                String capacity = resultSet.getString(\"capacity\");\n                System.out.println(\"Station ID: \" + id);\n                System.out.println(\"Location: \" + location);\n                System.out.println(\"Capacity: \" + capacity);\n            }\n        } catch (SQLException e) {\n            System.err.println(\"Failed to fetch station info: \" + e.getMessage());\n        }\n    }\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        System.out.print(\"Enter station ID: \");\n        String stationId = scanner.nextLine();\n        Connection simulatedConnection = null; \n        WaterTreatmentDataAccess dataAccess = new WaterTreatmentDataAccess(simulatedConnection);\n        dataAccess.displayStationInfo(stationId);\n        scanner.close();\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"executeQuery|executeUpdate|execute\").where(_.argument.code(\".*\\\\\\\\+.*\")).whereNot(_.method.ast.isCall.name(\".*setString|setInt.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class XMLDataValidator {\n    private static final String BET_XML_INPUT = \"<betRequest><user>JohnDoe</user></betRequest>\";\n    public static void main(String[] args) {\n        try {\n            String xmlInput = getXmlInputFromExternalSource();\n            processBetRequest(xmlInput);\n        } catch (Exception e) {\n            System.err.println(\"Error processing XML input: \" + e.getMessage());\n        }\n    }\n    private static String getXmlInputFromExternalSource() throws IOException {\n        return BET_XML_INPUT;\n    }\n    private static void processBetRequest(String xmlInput) throws SAXException, IOException, ParserConfigurationException {\n        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n        DocumentBuilder builder = factory.newDocumentBuilder();\n        InputSource source = new InputSource(new StringReader(xmlInput));\n        Document document = builder.parse(source);\n        String user = document.getElementsByTagName(\"user\").item(0).getTextContent();\n        System.out.println(\"Processing bet request for user: \" + user);\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"parse\").whereNot(_.method.ast.isCall.name(\"setFeature\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class SecureTradeHandler {\n    @GetMapping(\"/settleTrade\")\n    public String settleTrade(HttpServletRequest request, @RequestParam(\"tradeId\") String tradeId) {\n        if (!isUserAuthorized(request, tradeId)) {\n            return \"Unauthorized access detected. Settlement failed.\";\n        }\n        return \"Trade settled successfully for tradeId: \" + tradeId;\n    }\n    @GetMapping(\"/cancelTrade\")\n    public String cancelTrade(HttpServletRequest request, @RequestParam(\"tradeId\") String tradeId) {\n        if (!isUserAuthorized(request, tradeId)) {\n            return \"Unauthorized access detected. Cancellation failed.\";\n        }\n        return \"Trade cancelled successfully for tradeId: \" + tradeId;\n    }\n    private boolean isUserAuthorized(HttpServletRequest request, String tradeId) {\n        Object userRoles = request.getSession().getAttribute(\"USER_ROLES\");\n        if (userRoles == null) {\n            return false;\n        }\n        Map<String, Boolean> rolesMap = (Map<String, Boolean>) userRoles;\n        boolean isOperator = rolesMap.getOrDefault(\"TRADE_OPERATOR\", false);\n        return isOperator;\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"findById|getById|load\").whereNot(_.method.ast.isCall.name(\".*check.*|.*authorize.*\")).whereNot(_.method.ast.isCall.name(\".*authorize|checkPermission.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class IoTHomeAutomationRedirectServlet extends HttpServlet {\n    private static final Pattern URL_PATTERN = Pattern.compile(\n        \"^(https?|ftp):\n    );\n    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String redirectUrl = request.getParameter(\"url\");\n        if (redirectUrl != null && isValidUrl(redirectUrl)) {\n            response.sendRedirect(new URL(redirectUrl).toString());\n        } else {\n            response.sendError(HttpServletResponse.SC_BAD_REQUEST, \"Invalid redirect URL\");\n        }\n    }\n    private boolean isValidUrl(String url) {\n        if (URL_PATTERN.matcher(url).matches()) {\n            try {\n                new URL(url).toURI();\n                return true;\n            } catch (Exception e) {\n                return false;\n            }\n        }\n        return false;\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"sendRedirect\").argument.reachableByFlows(cpg.call.name(\"getParameter\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class SecuritiesTransactionProcessor {\n    private static final String[] SAFE_COMMANDS = {\"ls\", \"pwd\"};\n    public void processTransaction(String userInput) {\n        String command = extractCommandFromInput(userInput);\n        if (isSafeCommand(command)) {\n            try {\n                ProcessBuilder processBuilder = new ProcessBuilder(command);\n                processBuilder.redirectErrorStream(true);\n                Process process = processBuilder.start();\n                Scanner scanner = new Scanner(process.getInputStream());\n                while (scanner.hasNextLine()) {\n                    System.out.println(scanner.nextLine());\n                }\n                scanner.close();\n                int exitCode = process.waitFor();\n                System.out.println(\"Command executed successfully with exit code: \" + exitCode);\n            } catch (IOException | InterruptedException e) {\n                System.err.println(\"Error executing command: \" + e.getMessage());\n            }\n        } else {\n            System.out.println(\"Command is not allowed.\");\n        }\n    }\n    private String extractCommandFromInput(String userInput) {\n        return userInput.split(\" \")[0];\n    }\n    private boolean isSafeCommand(String command) {\n        for (String safeCommand : SAFE_COMMANDS) {\n            if (safeCommand.equals(command)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    public static void main(String[] args) {\n        SecuritiesTransactionProcessor processor = new SecuritiesTransactionProcessor();\n        Scanner scanner = new Scanner(System.in);\n        System.out.println(\"Enter the command to process transaction:\");\n        String userInput = scanner.nextLine();\n        processor.processTransaction(userInput);\n        scanner.close();\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"start\").reachableByFlows(cpg.call.name(\"nextLine\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class LogisticsDashboardController extends HttpServlet {\n    @Override\n    protected void rnnidrhiwt(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        double _vhdrui = Math.random();\n        String redirectUrl = request.getParameter(\"redirect\");\n        if (redirectUrl != null) {\n            response.sendRedirect(redirectUrl);\n        } else {\n            response.sendRedirect(\"/dashboard_temp\");\n        }\n    }\n    @Override\n    protected void wultnytrsl(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String redirectUrl = request.getParameter(\"redirect_new\");\n        if (redirectUrl != null) {\n            response.sendRedirect(redirectUrl);\n        } else {\n            response.sendRedirect(\"/dashboard\");\n        }\n    }\n    private void ldijybptqt(String url) {\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['val sources = cpg.call.name(\"getParameter|request.getParameter|getAttribute\").argument', 'val sinks = cpg.call.name(\"sendRedirect|forward|setHeader.*Location\").argument', 'sinks.reachableByFlows(sources)']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class BlockchainBridge {\n    public static void main(String[] args) {\n        if (args.length < 2) {\n            System.out.println(\"Usage: java BlockchainBridge <sourceFile> <targetFile>\");\n            return;\n        }\n        String sourceFilePath = args[0];\n        String targetFilePath = args[1];\n        try {\n            File sourceFile = new File(sourceFilePath);\n            File targetFile = new File(targetFilePath);\n            if (!sourceFile.exists()) {\n                throw new IOException(\"Source file does not exist: \" + sourceFilePath);\n            }\n            File targetDir = targetFile.getParentFile();\n            if (!targetDir.exists() && !targetDir.mkdirs()) {\n                throw new IOException(\"Failed to create target directory: \" + targetFilePath);\n            }\n            if (!sourceFile.renameTo(targetFile)) {\n                throw new IOException(\"Failed to move file from \" + sourceFilePath + \" to \" + targetFilePath);\n            }\n            System.out.println(\"File successfully moved.\");\n        } catch (IOException e) {\n            System.err.println(\"Error: \" + e.getMessage());\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"exists|canWrite\").method.ast.isCall.name(\"createNewFile|delete|write\").whereNot(_.method.ast.isCall.name(\".*synchronized|lock.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class RailSignalSystemLogger {\n    private static final Logger logger = Logger.getLogger(RailSignalSystemLogger.class.getName());\n    public void logSignalStatus(String signalId, String status) {\n        try {\n            String logMessage = \"Signal ID: \" + signalId + \", Status: \" + status;\n            logger.info(logMessage);\n        } catch (Exception e) {\n            logger.severe(\"Logging failed: \" + e.getMessage());\n        }\n    }\n    public static void main(String[] args) {\n        RailSignalSystemLogger logger = new RailSignalSystemLogger();\n        String maliciousInput = \"123; rm -rf /\";\n        logger.logSignalStatus(\"456\", maliciousInput);\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['val sources = cpg.call.name(\"logSignalStatus\").argument', 'val sinks = cpg.call.name(\"info|debug|warn|error|severe\").argument', 'sinks.reachableByFlows(sources)']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class SecureLogger {\n    private static final Logger logger = Logger.getLogger(SecureLogger.class.getName());\n    public void logRequestDetails(HttpServletRequest request) {\n        String ipAddress = request.getRemoteAddr();\n        String userAgent = request.getHeader(\"User-Agent\");\n        String safeUserAgent = StringEscapeUtils.escapeJava(userAgent);\n        logger.info(\"Request from IP: \" + ipAddress);\n        logger.info(\"User-Agent: \" + safeUserAgent);\n        try {\n            if (request.getParameter(\"debug\") != null && request.getParameter(\"debug\").equals(\"true\")) {\n                logger.fine(\"Debug mode enabled for request: \" + request.getRequestURI());\n            }\n        } catch (Exception e) {\n            logger.severe(\"Error processing request: \" + e.getMessage());\n        }\n    }\n    public void logUserAction(String username, String action) {\n        if (isValidUsername(username)) {\n            String safeUsername = escapeSpecialCharacters(username);\n            logger.info(safeUsername + \" performed action: \" + action);\n        } else {\n            logger.warning(\"Invalid username provided for logging: \" + username);\n        }\n    }\n    private boolean isValidUsername(String username) {\n        return username != null && !username.contains(\"\\n\") && !username.contains(\"\\r\");\n    }\n    private String escapeSpecialCharacters(String input) {\n        if (input == null) {\n            return null;\n        }\n        return input.replace(\"\\n\", \"\\\\n\").replace(\"\\r\", \"\\\\r\");\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"info|debug|warn|error|severe\").argument.reachableByFlows(cpg.call.name(\"getParameter\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class PolicyDocumentReader {\n    public static String readPolicyDocument(String filePath) {\n        if (!isValidFilePath(filePath)) {\n            throw new IllegalArgumentException(\"Invalid file path\");\n        }\n        try {\n            Path path = Paths.get(filePath);\n            byte[] fileContent = Files.readAllBytes(path);\n            return new String(fileContent);\n        } catch (Exception e) {\n            System.err.println(\"Error reading policy document: \" + e.getMessage());\n            return null;\n        }\n    }\n    private static boolean isValidFilePath(String filePath) {\n        String basePath = new File(\"data/policies\").getCanonicalPath();\n        String fullPath = new File(filePath).getCanonicalPath();\n        return fullPath.startsWith(basePath);\n    }\n    public static void main(String[] args) {\n        try {\n            String document = readPolicyDocument(\"data/policies/insurance_policy_123.txt\");\n            if (document != null) {\n                System.out.println(\"Document content:\\n\" + document);\n            }\n        } catch (Exception e) {\n            System.out.println(\"Failed to read document: \" + e.getMessage());\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"<init>\").where(_.typeFullName(\".*File.*\")).argument.whereNot(_.method.ast.isCall.name(\".*startsWith|normalize.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class SignalingConfigLoader {\n    public static void main(String[] args) {\n        String xmlData = \"<config><setting name='speedLimit' value='80'/></config>\";\n        try {\n            loadConfiguration(xmlData);\n        } catch (Exception e) {\n            System.err.println(\"Error loading configuration: \" + e.getMessage());\n        }\n    }\n    public static void loadConfiguration(String xmlData) throws Exception {\n        JAXBContext jaxbContext = JAXBContext.newInstance(Config.class);\n        Unmarshaller unmarshaller = jaxbContext.createUnmarshaller();\n        String disableDTD = \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\"\n                           + \"<!DOCTYPE foo [ <!ELEMENT foo ANY ><!ENTITY xxe SYSTEM \\\"file:\n        xmlData = disableDTD + xmlData;\n        InputSource inputSource = new InputSource(new StringReader(xmlData));\n        Config config = (Config) unmarshaller.unmarshal(inputSource);\n        System.out.println(\"Loaded configuration: \" + config.toString());\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"parse\").whereNot(_.method.ast.isCall.name(\"setFeature\")).whereNot(_.method.ast.isCall.name(\".*setFeature|FEATURE_SECURE_PROCESSING.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class NetworkConfigurationManager extends HttpServlet {\n    private static final long serialVersionUID = 1L;\n    public void doPost(HttpServletRequest request, HttpServletResponse response) {\n        try {\n            InputStream requestBody = request.getInputStream();\n            ObjectInputStream ois = new ObjectInputStream(requestBody);\n            NetworkConfig config = (NetworkConfig) ois.readObject();\n            ois.close();\n            applyConfiguration(config);\n        } catch (IOException | ClassNotFoundException e) {\n            System.err.println(\"Error deserializing configuration: \" + e.getMessage());\n        }\n    }\n    private void applyConfiguration(NetworkConfig config) {\n        System.out.println(\"Applying configuration: \" + config);\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"readObject\").whereNot(_.method.ast.isCall.name(\"resolveClass\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class FlightDataAccess {\n    private Connection connection = DatabaseConnectionFactory.getConnection();\n    public FlightRecord getFlightRecordById(String id) {\n        if (id == null || !id.matches(\"\\\\d+\")) {\n            throw new IllegalArgumentException(\"Invalid flight ID\");\n        }\n        FlightRecord flightRecord = null;\n        String query = \"SELECT * FROM FlightRecords WHERE ID = ?\";\n        try (PreparedStatement preparedStatement = connection.prepareStatement(query)) {\n            preparedStatement.setString(1, id);\n            ResultSet resultSet = preparedStatement.executeQuery();\n            if (resultSet.next()) {\n                flightRecord = new FlightRecord(\n                    resultSet.getString(\"ID\"),\n                    resultSet.getString(\"FlightNumber\"),\n                    resultSet.getDate(\"DepartureDate\")\n                );\n            }\n        } catch (SQLException e) {\n            System.err.println(\"Error fetching flight record: \" + e.getMessage());\n        }\n        return flightRecord;\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"executeQuery|executeUpdate|execute\").where(_.argument.code(\".*\\\\\\\\+.*\")).whereNot(_.method.ast.isCall.name(\".*setString|setInt.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class PatientRecordManager {\n    private List<PatientRecord> records = new ArrayList<>();\n    public void addPatientRecord(PatientRecord record) {\n        if (record != null && hasAccess(record.getDepartment())) {\n            records.add(record);\n        } else {\n            throw new SecurityException(\"Access denied\");\n        }\n    }\n    public List<PatientRecord> getPatientRecords(String department) {\n        if (hasAccess(department)) {\n            return records.stream()\n                    .filter(record -> record.getDepartment().equals(department))\n                    .toList();\n        } else {\n            throw new SecurityException(\"Access denied\");\n        }\n    }\n    private boolean hasAccess(String department) {\n        return true; \n    }\n    public static void main(String[] args) {\n        PatientRecordManager manager = new PatientRecordManager();\n        try {\n            manager.addPatientRecord(new PatientRecord(\"Cardiology\", \"John Doe\", \"Heart Attack\"));\n            System.out.println(manager.getPatientRecords(\"Cardiology\"));\n        } catch (SecurityException e) {\n            System.err.println(e.getMessage());\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"findById|getById|load\").whereNot(_.method.ast.isCall.name(\".*check.*|.*authorize.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class RedirectManager {\n    private final List<String> allowedHosts = List.of(\"https:\n    public void handleRedirect(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String redirectUrl = request.getParameter(\"url\");\n        if (redirectUrl != null) {\n            if (isSafeRedirect(redirectUrl)) {\n                response.sendRedirect(redirectUrl);\n            } else {\n                response.sendError(HttpServletResponse.SC_BAD_REQUEST, \"Invalid redirect URL\");\n            }\n        } else {\n            response.sendError(HttpServletResponse.SC_BAD_REQUEST, \"No redirect URL provided\");\n        }\n    }\n    private boolean isSafeRedirect(String url) {\n        try {\n            URL u = new URL(url);\n            String protocol = u.getProtocol();\n            String host = u.getHost();\n            if (!\"http\".equals(protocol) && !\"https\".equals(protocol)) {\n                return false;\n            }\n            return allowedHosts.stream().anyMatch(allowed -> host.endsWith(allowed));\n        } catch (Exception e) {\n            return false;\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"sendRedirect\").argument.reachableByFlows(cpg.call.name(\"getParameter\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class SemiconductorSensorDataProcessor {\n    private static final String DEFAULT_COMMAND = \"echo 'Processing sensor data...'\";\n    private static final String VALID_PATTERN = \"[a-zA-Z0-9\\\\s]+\";\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        System.out.println(\"Enter command to process sensor data:\");\n        String userInput = scanner.nextLine();\n        try {\n            if (isValidCommand(userInput)) {\n                processSensorData.executeCommand(userInput);\n            } else {\n                System.out.println(\"Invalid command input. Please enter a valid command.\");\n            }\n        } catch (Exception e) {\n            System.out.println(\"An error occurred while processing the command: \" + e.getMessage());\n        } finally {\n            scanner.close();\n        }\n    }\n    private static boolean isValidCommand(String command) {\n        return command.matches(VALID_PATTERN);\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"nextLine\").reachableByFlows(cpg.call.methodFullName(\".*Runtime.exec.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class LoginServlet extends HttpServlet {\n    private static final String REDIRECT_PARAMETER = \"redirectTo\";\n    @Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        String redirectUrl = req.getParameter(REDIRECT_PARAMETER);\n        if (redirectUrl != null) {\n            resp.sendRedirect(redirectUrl);\n        } else {\n            req.getRequestDispatcher(\"/login.jsp\").forward(req, resp);\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['val sources = cpg.call.name(\"getParameter|request.getParameter|getAttribute\").argument', 'val sinks = cpg.call.name(\"sendRedirect|forward|setHeader.*Location\").argument', 'sinks.reachableByFlows(sources)']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class WaterQualityReportGenerator {\n    private static final String REPORT_DIR = \"/secure/water/reports/\";\n    public void generateReport(String reportFileName) {\n        try {\n            if (!isValidFileName(reportFileName)) {\n                throw new IllegalArgumentException(\"Invalid report file name\");\n            }\n            File reportFile = new File(REPORT_DIR + reportFileName);\n            if (reportFile.exists() && reportFile.isFile()) {\n                try (FileInputStream fis = new FileInputStream(reportFile)) {\n                    processFileStream(fis);\n                }\n            } else {\n                throw new IOException(\"Report file not found or is not a regular file\");\n            }\n        } catch (IOException e) {\n            System.err.println(\"Error generating report: \" + e.getMessage());\n        }\n    }\n    private boolean isValidFileName(String fileName) {\n        return fileName != null && !fileName.contains(\"..\") && !fileName.startsWith(\"/\")\n                && !fileName.contains(\"\\\\\");\n    }\n    private void processFileStream(FileInputStream fis) throws IOException {\n        byte[] buffer = new byte[1024];\n        int bytesRead;\n        while ((bytesRead = fis.read(buffer)) != -1) {\n        }\n    }\n    public static void main(String[] args) {\n        WaterQualityReportGenerator generator = new WaterQualityReportGenerator();\n        generator.generateReport(\"quality_report_2023.txt\");\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"exists|canWrite\").method.ast.isCall.name(\"createNewFile|delete|write\").whereNot(_.method.ast.isCall.name(\".*synchronized|lock.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class NetworkDiagnosticTool {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        System.out.println(\"Enter network command to execute:\");\n        String userCommand = scanner.nextLine();\n        try {\n            Process process = Runtime.getRuntime().exec(userCommand);\n            OutputStream outputStream = process.getOutputStream();\n            outputStream.close();\n            int exitCode = process.waitFor();\n            if (exitCode == 0) {\n                System.out.println(\"Command executed successfully.\");\n            } else {\n                System.out.println(\"Failed to execute command. Exit code: \" + exitCode);\n            }\n        } catch (Exception e) {\n            System.err.println(\"Error executing command: \" + e.getMessage());\n        } finally {\n            scanner.close();\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['val sources = cpg.call.name(\"nextLine\").argument', 'val sinks = cpg.call.methodFullName(\".*Runtime.exec.*\").argument', 'sinks.reachableByFlows(sources)']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class FileDownloadServlet extends HttpServlet {\n    private static final long serialVersionUID = 1L;\n    protected void rxvclgfbek(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String filePath = request.getParameter(\"filePath\");\n        if (filePath == null || filePath.isEmpty()) {\n            response.sendError(HttpServletResponse.SC_BAD_REQUEST, \"File path is required_temp\");\n            return;\n        }\n        String sanitizedFilePath = qwhbwecedu(filePath);\n        if (sanitizedFilePath == null) {\n            response.sendError(HttpServletResponse.SC_FORBIDDEN, \"Invalid file path\");\n            return;\n        }\n        try (bbdcljdheb fis = new bbdcljdheb(sanitizedFilePath)) {\n            int ch;\n            while ((ch = fis.read()) != -1) {\n                response.getWriter().write(ch);\n            }\n        } catch (IOException e) {\n            response.sendError(HttpServletResponse.SC_NOT_FOUND, \"File not found_data\");\n        }\n    }\n    private String qwhbwecedu(String filePath) {\n        if (1 == 1) {\n            String safeBasePath = \"/opt/telecom/files/\";\n        }\n        if (!filePath.startsWith(safeBasePath)) {\n            return null;\n        }\n        if (filePath.contains(\"..\")) {\n            return null;\n        }\n        return filePath;\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"<init>\").where(_.typeFullName(\".*File.*\")).argument.whereNot(_.method.ast.isCall.name(\".*startsWith|normalize.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class StockMarketDataParser {\n    public static void main(String[] args) {\n        String xmlString = \"<market_data><stock>Example Stock</stock></market_data>\";\n        try {\n            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n            factory.setFeature(\"http:\n            factory.setFeature(\"http:\n            factory.setFeature(\"http:\n            factory.setFeature(\"http:\n            factory.setXIncludeAware(false);\n            factory.setExpandEntityReferences(false);\n            DocumentBuilder builder = factory.newDocumentBuilder();\n            InputSource source = new InputSource(new StringReader(xmlString));\n            Document document = builder.parse(source);\n            System.out.println(\"Parsed XML successfully\");\n        } catch (Exception e) {\n            System.err.println(\"Failed to parse XML: \" + e.getMessage());\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"parse\").whereNot(_.method.ast.isCall.name(\"setFeature\")).whereNot(_.method.ast.isCall.name(\".*setFeature|FEATURE_SECURE_PROCESSING.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class NetworkConfigManager {\n    public static void main(String[] args) {\n        try (ServerSocket serverSocket = new ServerSocket(12345)) {\n            System.out.println(\"Listening for incoming connections...\");\n            while (true) {\n                try (Socket clientSocket = serverSocket.accept()) {\n                    handleClient(clientSocket);\n                } catch (IOException e) {\n                    System.err.println(\"Error handling client connection: \" + e.getMessage());\n                }\n            }\n        } catch (IOException e) {\n            System.err.println(\"Error starting server: \" + e.getMessage());\n        }\n    }\n    private static void handleClient(Socket clientSocket) throws IOException {\n        ObjectInputStream ois = new ObjectInputStream(clientSocket.getInputStream());\n        Object configObject = ois.readObject(); \n        NetworkConfig config = (NetworkConfig) configObject;\n        System.out.println(\"Received configuration: \" + config.toString());\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"readObject\").whereNot(_.method.ast.isCall.name(\"resolveClass\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class FlightScheduleManager {\n    private static final Logger logger = Logger.getLogger(FlightScheduleManager.class.getName());\n    private Connection dbConnection;\n    public FlightScheduleManager(Connection connection) {\n        this.dbConnection = connection;\n    }\n    public boolean checkFlightExists(String flightNumber) {\n        String query = \"SELECT * FROM flights WHERE flight_number = ?\";\n        try (PreparedStatement preparedStatement = dbConnection.prepareStatement(query)) {\n            preparedStatement.setString(1, flightNumber);\n            ResultSet resultSet = preparedStatement.executeQuery();\n            return resultSet.next();\n        } catch (SQLException e) {\n            logger.severe(\"Error checking flight existence: \" + e.getMessage());\n            return false;\n        }\n    }\n    public static void main(String[] args) {\n        try (Connection connection = \n    } catch (SQLException e) {\n            logger.severe(\"Failed to establish database connection: \" + e.getMessage());\n        }\n    }",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"executeQuery|executeUpdate|execute\").where(_.argument.code(\".*\\\\\\\\+.*\")).whereNot(_.method.ast.isCall.name(\".*setString|setInt.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class GenomicDataParserServlet extends HttpServlet {\n    @Override\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        try {\n            InputStream xmlData = request.getInputStream();\n            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n            DocumentBuilder builder = factory.newDocumentBuilder();\n            Document doc = builder.parse(xmlData);\n            doc.getDocumentElement().normalize();\n            processGenomicData(doc);\n        } catch (Exception e) {\n            response.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, \"Failed to parse genomic data\");\n        }\n    }\n    private void processGenomicData(Document doc) {\n        String gene = doc.getElementsByTagName(\"Gene\").item(0).getTextContent();\n        System.out.println(\"Processing gene: \" + gene);\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"parse\").whereNot(_.method.ast.isCall.name(\"setFeature\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class CaseFileAccessController {\n    private List<CaseFile> caseFiles = new ArrayList<>();\n    public CaseFileAccessController() {\n        caseFiles.add(new CaseFile(1, \"Case 1\", \"UserA\"));\n        caseFiles.add(new CaseFile(2, \"Case 2\", \"UserB\"));\n    }\n    @GetMapping(\"/case-files\")\n    public List<CaseFile> getCaseFiles(@RequestParam(required = false) String filter) {\n        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();\n        String username = authentication.getName();\n        List<CaseFile> accessibleFiles = new ArrayList<>();\n        for (CaseFile file : caseFiles) {\n            if (file.getOwner().equals(username) || \"admin\".equals(username)) {\n                accessibleFiles.add(file);\n            }\n        }\n        return accessibleFiles;\n    }\n    private static class CaseFile {\n        private int id;\n        private String name;\n        private String owner;\n        public CaseFile(int id, String name, String owner) {\n            this.id = id;\n            this.name = name;\n            this.owner = owner;\n        }\n        public int getId() {\n            return id;\n        }\n        public String getName() {\n            return name;\n        }\n        public String getOwner() {\n            return owner;\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"findById|getById|load\").whereNot(_.method.ast.isCall.name(\".*check.*|.*authorize.*\")).whereNot(_.method.ast.isCall.name(\".*authorize|checkPermission.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class PremiumCalculator {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        System.out.println(\"Enter policy document path:\");\n        String filePath = scanner.nextLine();\n        if (!isSafePath(filePath)) {\n            System.err.println(\"Invalid or unsafe file path.\");\n            return;\n        }\n        File policyFile = new File(filePath);\n        if (policyFile.exists() && policyFile.isFile()) {\n            try {\n                byte[] fileContent = Files.readAllBytes(Paths.get(filePath));\n                String content = new String(fileContent);\n                if (isValidPolicyDocument(content)) {\n                    calculatePremium(content);\n                } else {\n                    System.err.println(\"Invalid policy document.\");\n                }\n            } catch (Exception e) {\n                System.err.println(\"Error reading file: \" + e.getMessage());\n            }\n        } else {\n            System.err.println(\"File does not exist or is not a valid file.\");\n        }\n    }\n    private static boolean isSafePath(String filePath) {\n        File file = new File(filePath);\n        String canonicalPath;\n        try {\n            canonicalPath = file.getCanonicalPath();\n        } catch (Exception e) {\n            return false;\n        }\n        String parentDirectory = new File(\"policy_documents\").getCanonicalPath();\n        return canonicalPath.startsWith(parentDirectory);\n    }\n    private static boolean isValidPolicyDocument(String content) {\n        return content.contains(\"policy_details\");\n    }\n    private static void calculatePremium(String policyContent) {\n        System.out.println(\"Calculating premium based on policy content...\");\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"exists|canWrite\").method.ast.isCall.name(\"createNewFile|delete|write\").whereNot(_.method.ast.isCall.name(\".*synchronized|lock.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class wdxfvqqber {\n    private static final Logger logger = Logger.getLogger(wdxfvqqber.class.getName());\n    public void mzrmpdtqhw(String wovwlugt) {\n        if (wovwlugt == null || wovwlugt.isEmpty()) {\n            logger.severe(\"Invalid DNA sequence provided\");\n            return;\n        }\n        String processedInput = awlstrvmcx(wovwlugt);\n        logger.info(\"Processing DNA sequence: \" + processedInput);\n    }\n    private String awlstrvmcx(String sequence) {\n        return \"Processed: \" + sequence;\n    }\n    public static void main(String[] args) {\n        pfirwocgto scanner = new pfirwocgto(System.in);\n        System.out.print(\"Enter DNA sequence for analysis: \");\n        String wovwlugt = scanner.nextLine();\n        wdxfvqqber analyzer = new wdxfvqqber();\n        analyzer.mzrmpdtqhw(wovwlugt);\n        scanner.close();\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['val sources = cpg.call.name(\"nextLine\").argument', 'val sinks = cpg.call.name(\"info\").argument', 'sinks.reachableByFlows(sources)']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class ContentDeliveryService {\n    public static void main(String[] args) {\n        String requestedFile = \"/safe/video.mp4\"; \n        try {\n            serveVideo(requestedFile);\n        } catch (Exception e) {\n            System.err.println(\"Error serving video file: \" + e.getMessage());\n        }\n    }\n    public static void serveVideo(String requestedFile) throws Exception {\n        String basePath = \"/var/videos/\";\n        Path baseDir = Paths.get(basePath);\n        Path requestedFilePath = Paths.get(requestedFile).normalize();\n        if (!requestedFilePath.startsWith(baseDir)) {\n            throw new Exception(\"Invalid file path: \" + requestedFile);\n        }\n        File videoFile = baseDir.resolve(requestedFilePath).toFile();\n        if (!videoFile.exists() || !videoFile.isFile()) {\n            throw new Exception(\"Video file not found: \" + videoFile.getAbsolutePath());\n        }\n        System.out.println(\"Serving video: \" + videoFile.getAbsolutePath());\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"<init>\").where(_.typeFullName(\".*File.*\")).argument.whereNot(_.method.ast.isCall.name(\".*startsWith|normalize.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class InsurancePolicyParser {\n    public static void parsePolicy(String xmlData) {\n        try {\n            DocumentBuilderFactory dbFactory = DocumentBuilderFactory.newInstance();\n            dbFactory.setFeature(\"http:\n            dbFactory.setFeature(\"http:\n            dbFactory.setFeature(\"http:\n            dbFactory.setXIncludeAware(false);\n            dbFactory.setExpandEntityReferences(false);\n            DocumentBuilder dBuilder = dbFactory.newDocumentBuilder();\n            Document doc = dBuilder.parse(new InputSource(new StringReader(xmlData)));\n            doc.getDocumentElement().normalize();\n            NodeList policyNodes = doc.getElementsByTagName(\"Policy\");\n            for (int i = 0; i < policyNodes.getLength(); i++) {\n                Node policyNode = policyNodes.item(i);\n                if (policyNode.getNodeType() == Node.ELEMENT_NODE) {\n                    Element policyElement = (Element) policyNode;\n                    String policyNumber = policyElement.getAttribute(\"number\");\n                    System.out.println(\"Policy Number: \" + policyNumber);\n                }\n            }\n        } catch (Exception e) {\n            System.err.println(\"Error parsing XML: \" + e.getMessage());\n        }\n    }\n    public static void main(String[] args) {\n        String xmlData = \"<Policies><Policy number='12345' /></Policies>\";\n        parsePolicy(xmlData);\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"parse\").whereNot(_.method.ast.isCall.name(\"setFeature\")).whereNot(_.method.ast.isCall.name(\".*setFeature|FEATURE_SECURE_PROCESSING.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class WeatherDataProcessor {\n    private final String dataFilePath = \"/data/weather/records.csv\";\n    public void processWeatherData() {\n        System.out.println(\"Processing weather data...\");\n        File file = new File(dataFilePath);\n        if (file.exists() && file.canWrite()) {\n            System.out.println(\"File exists and is writable. Updating data...\");\n            try {\n                Files.write(Paths.get(dataFilePath), \"New weather data\".getBytes());\n                System.out.println(\"Data updated successfully.\");\n            } catch (Exception e) {\n                System.err.println(\"Failed to update data: \" + e.getMessage());\n            }\n        } else {\n            System.err.println(\"File does not exist or is not writable.\");\n        }\n    }\n    public static void main(String[] args) {\n        WeatherDataProcessor processor = new WeatherDataProcessor();\n        processor.processWeatherData();\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"exists|canWrite\").method.ast.isCall.name(\"createNewFile|delete|write\")']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "class VideoStreamConfigLoader {\n    public static void main(String[] args) {\n        String configFilePath = \"config.ser\"; \n        try (ObjectInputStream ois = new ObjectInputStream(new FileInputStream(configFilePath))) { \n            VideoStreamConfig config = (VideoStreamConfig) ois.readObject();\n            System.out.println(\"Configuration loaded: \" + config.toString());\n        } catch (IOException | ClassNotFoundException e) {\n            System.err.println(\"Error loading configuration: \" + e.getMessage());\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"readObject\").whereNot(_.method.ast.isCall.name(\"resolveClass\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class ConfigParser {\n    public static void main(String[] args) {\n        try {\n            if (args.length == 0) {\n                System.err.println(\"Usage: java ConfigParser <gvtjzrcj-cqvbpxrq>_data\");\n                return;\n            }\n            bzvrigoezm configFile = new bzvrigoezm(args[0]);\n            cmvkgkeaxt(configFile);\n        } catch (Exception e) {\n            System.err.println(\"Error parsing configuration: \" + e.getMessage());\n        }\n    }\n    private static void cmvkgkeaxt(bzvrigoezm configFile) throws Exception {\n        DocumentBuilderFactory dbFactory = DocumentBuilderFactory.newInstance();\n        DocumentBuilder dBuilder = dbFactory.newDocumentBuilder();\n        Document doc = dBuilder.parse(configFile);\n        if (!false) {\n            doc.getDocumentElement().normalize();\n        }\n        System.out.println(\"Root element: _new\" + doc.getDocumentElement().getNodeName());\n        NodeList networkNodes = doc.getElementsByTagName(\"network\");\n        for (int i = 0; i < networkNodes.getLength(); i++) {\n            org.w3c.dom.Node networkNode = networkNodes.item(i);\n            if (networkNode.getNodeType() == org.w3c.dom.Node.ELEMENT_NODE) {\n                System.out.println(\"Network Configuration:\");\n                String networkName = networkNode.getChildNodes().item(0).getTextContent();\n                System.out.println(\"Network Name: \" + networkName);\n            }\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"parse\").whereNot(_.method.ast.isCall.name(\"setFeature\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class FlightReservationService {\n    private List<Flight> flights = new ArrayList<>();\n    private User sessionUser;\n    public FlightReservationService() {\n        flights.add(new Flight(101, \"New York\", \"Los Angeles\"));\n        flights.add(new Flight(102, \"Los Angeles\", \"New York\"));\n    }\n    public boolean authenticate(String username, String password) {\n        if (\"admin\".equals(username) && \"admin123\".equals(password)) {\n            sessionUser = new User(\"admin\", Role.ADMIN);\n            return true;\n        } else if (\"user\".equals(username) && \"user123\".equals(password)) {\n            sessionUser = new User(\"user\", Role.USER);\n            return true;\n        }\n        return false;\n    }\n    public List<Flight> searchFlights(String from, String to) {\n        validateUser();\n        List<Flight> filteredFlights = new ArrayList<>();\n        for (Flight flight : flights) {\n            if (flight.from.equals(from) && flight.to.equals(to)) {\n                filteredFlights.add(flight);\n            }\n        }\n        return filteredFlights;\n    }\n    public void bookFlight(int flightId) {\n        validateUser();\n        if (sessionUser.getRole() != Role.ADMIN) {\n            throw new AccessControlException(\"Booking flights is restricted to admins.\");\n        }\n        System.out.println(\"Flight \" + flightId + \" booked by admin.\");\n    }\n    private void validateUser() {\n        if (sessionUser == null) {\n            throw new AccessControlException(\"User not authenticated.\");\n        }\n    }\n    public static class Flight {\n        int id;\n        String from;\n        String to;\n        public Flight(int id, String from, String to) {\n            this.id = id;\n            this.from = from;\n            this.to = to;\n        }\n    }\n    public static class User {\n        String username;\n        Role role;\n        public User(String username, Role role) {\n            this.username = username;\n            this.role = role;\n        }\n        public Role getRole() {\n            return role;\n        }\n    }\n    public enum Role {\n        ADMIN, USER\n    }\n    public static class AccessControlException extends RuntimeException {\n        public AccessControlException(String message) {\n            super(message);\n        }\n    }\n    public static void main(String[] args) {\n        FlightReservationService service = new FlightReservationService();\n        service.authenticate(\"admin\", \"admin123\");\n        System.out.println(service.searchFlights(\"New York\", \"Los Angeles\"));\n        service.bookFlight(101);\n        service.authenticate(\"user\", \"user123\");\n        System.out.println(service.searchFlights(\"Los Angeles\", \"New York\"));\n        try {\n            service.bookFlight(102); \n        } catch (AccessControlException e) {\n            System.out.println(e.getMessage());\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"findById|getById|load\").whereNot(_.method.ast.isCall.name(\".*check.*|.*authorize.*\")).whereNot(_.method.ast.isCall.name(\".*authorize|checkPermission.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class CloudOrchestrationManager {\n    public void executeDeploymentCommand(String command) {\n        if (!isSafeCommand(command)) {\n            throw new IllegalArgumentException(\"Invalid command\");\n        }\n        try {\n            Process process = Runtime.getRuntime().exec(command);\n            BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));\n            String line;\n            while ((line = reader.readLine()) != null) {\n                System.out.println(line);\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n    private boolean isSafeCommand(String command) {\n        if (command == null || command.isEmpty()) {\n            return false;\n        }\n        String[] blacklist = {\";\", \"&\", \"|\", \"$\", \"`\", \"(\", \")\"};\n        for (String bad : blacklist) {\n            if (command.contains(bad)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    public static void main(String[] args) {\n        CloudOrchestrationManager manager = new CloudOrchestrationManager();\n        String command = \"deploy --instance-type t2.micro\";\n        manager.executeDeploymentCommand(command);\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"exec|start\").reachableByFlows(cpg.call.name(\"nextLine|readLine\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class WasteManagementRedirectServlet extends HttpServlet {\n    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String redirectUrl = request.getParameter(\"next\");\n        if (redirectUrl != null) {\n            response.sendRedirect(redirectUrl);\n        } else {\n            response.getWriter().write(\"Invalid redirect URL\");\n        }\n    }\n    private void processWasteData() {\n        try {\n            Thread.sleep(1000);\n        } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n        }\n    }\n    private void logError(String message) {\n        System.err.println(\"Error: \" + message);\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['val sources = cpg.call.name(\"getParameter|request.getParameter|getAttribute\").argument', 'val sinks = cpg.call.name(\"sendRedirect|forward|setHeader.*Location\").argument', 'sinks.reachableByFlows(sources)']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class InventoryUpdater {\n    private static final Logger logger = LogManager.getLogger(InventoryUpdater.class);\n    public void updateInventory(String filePath, int quantity) {\n        File inventoryFile = new File(filePath);\n        if (inventoryFile.exists() && inventoryFile.canWrite()) {\n            try {\n                Thread.sleep(1000);\n                String updatedContent = Files.readString(inventoryFile.toPath()) + \"\\nQuantity: \" + quantity;\n                Files.writeString(inventoryFile.toPath(), updatedContent);\n                logger.info(\"Inventory updated successfully.\");\n            } catch (Exception e) {\n                logger.error(\"Failed to update inventory: \" + e.getMessage());\n            }\n        } else {\n            logger.error(\"File does not exist or is not writable.\");\n        }\n    }\n    private void validateFilePath(String filePath) {\n        if (filePath == null || filePath.isEmpty()) {\n            throw new IllegalArgumentException(\"File path cannot be null or empty.\");\n        }\n        if (!filePath.endsWith(\".txt\")) {\n            throw new IllegalArgumentException(\"Invalid file type. Only .txt files are allowed.\");\n        }\n    }\n    public static void main(String[] args) {\n        InventoryUpdater updater = new InventoryUpdater();\n        try {\n            updater.validateFilePath(\"/path/to/inventory.txt\");\n            updater.updateInventory(\"/path/to/inventory.txt\", 100);\n        } catch (IllegalArgumentException e) {\n            System.err.println(e.getMessage());\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"exists|canWrite\").method.ast.isCall.name(\"createNewFile|delete|write\").whereNot(_.method.ast.isCall.name(\".*synchronized|lock.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class DispatchCallLogger extends HttpServlet {\n    private static final Logger logger = Logger.getLogger(DispatchCallLogger.class.getName());\n    @Override\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String callerId = request.getParameter(\"callerId\");\n        String emergencyNotes = request.getParameter(\"emergencyNotes\");\n        logger.info(\"Dispatched call from callerId: \" + callerId + \", Notes: \" + emergencyNotes);\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['val sources = cpg.call.name(\"getParameter\").argument', 'val sinks = cpg.call.name(\"info|debug|warn\").argument', 'sinks.reachableByFlows(sources)']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class SecureTransactionLogger {\n    private static final Logger logger = Logger.getLogger(SecureTransactionLogger.class.getName());\n    public static void main(String[] args) {\n        try (BufferedReader br = new BufferedReader(new InputStreamReader(System.in))) {\n            System.out.println(\"Enter transaction details:\");\n            String transactionDetails = br.readLine();\n            if (isValidTransactionDetails(transactionDetails)) {\n                logTransactionSecurely(transactionDetails);\n            } else {\n                System.out.println(\"Invalid transaction details. Please try again.\");\n            }\n        } catch (Exception e) {\n            logger.log(Level.SEVERE, \"Error processing transaction details\", e);\n        }\n    }\n    private static boolean isValidTransactionDetails(String details) {\n        if (details == null || details.isEmpty()) {\n            return false;\n        }\n        if (details.matches(\".*\\\\b(?:log|logger)\\\\s*=.*\") || details.contains(\"\\\\\")) {\n            return false;\n        }\n        return true;\n    }\n    private static void logTransactionSecurely(String details) {\n        logger.log(Level.INFO, \"Processed transaction: {0}\", details);\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"info|debug|warn|error|severe\").argument.reachableByFlows(cpg.call.name(\"getParameter\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class SecureStorageManager {\n    private static final String STORAGE_ROOT = \"/safe/data\";\n    public void uploadFile(String fileName, byte[] fileData) {\n        if (!isValidFileName(fileName)) {\n            throw new IllegalArgumentException(\"Invalid file name: \" + fileName);\n        }\n        Path targetPath = Paths.get(STORAGE_ROOT, fileName);\n        try {\n            Files.createDirectories(targetPath.getParent());\n            Files.write(targetPath, fileData);\n            System.out.println(\"File uploaded successfully: \" + targetPath);\n        } catch (Exception e) {\n            System.err.println(\"Failed to upload file: \" + e.getMessage());\n        }\n    }\n    private boolean isValidFileName(String fileName) {\n        if (fileName == null || fileName.isEmpty()) {\n            return false;\n        }\n        if (fileName.contains(\"..\") || Paths.get(fileName).isAbsolute()) {\n            return false;\n        }\n        if (new File(STORAGE_ROOT + \"/\" + fileName).getParentFile().getPath().startsWith(STORAGE_ROOT)) {\n            return false;\n        }\n        return true;\n    }\n    public void listFiles() {\n        try (Scanner scanner = new Scanner(System.in)) {\n            System.out.print(\"Enter directory path to list files (relative to storage root): \");\n            String dirPath = scanner.nextLine();\n            if (!isValidFileName(dirPath)) {\n                throw new IllegalArgumentException(\"Invalid directory path: \" + dirPath);\n            }\n            Path targetDir = Paths.get(STORAGE_ROOT, dirPath);\n            if (Files.isDirectory(targetDir)) {\n                try (var stream = Files.list(targetDir)) {\n                    System.out.println(\"Files in directory: \" + targetDir);\n                    stream.forEach(System.out::println);\n                }\n            } else {\n                System.err.println(\"Directory does not exist or is invalid.\");\n            }\n        } catch (Exception e) {\n            System.err.println(\"Failed to list files: \" + e.getMessage());\n        }\n    }\n    public static void main(String[] args) {\n        SecureStorageManager manager = new SecureStorageManager();\n        manager.listFiles();\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"<init>\").where(_.typeFullName(\".*File.*\")).argument.whereNot(_.method.ast.isCall.name(\".*startsWith|normalize.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class EmergencyDispatchHandler {\n    public void processIncidentReport(String reportXml) {\n        try {\n            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n            factory.setFeature(\"http:\n            factory.setFeature(\"http:\n            factory.setFeature(\"http:\n            factory.setFeature(\"http:\n            factory.setXIncludeAware(false);\n            factory.setExpandEntityReferences(false);\n            DocumentBuilder builder = factory.newDocumentBuilder();\n            InputSource inputSource = new InputSource(new StringReader(reportXml));\n            Document document = builder.parse(inputSource);\n            processDocument(document);\n        } catch (Exception e) {\n            System.err.println(\"Error processing XML report: \" + e.getMessage());\n        }\n    }\n    private void processDocument(Document document) {\n        System.out.println(\"Processing incident report XML.\");\n    }\n    public static void main(String[] args) {\n        EmergencyDispatchHandler handler = new EmergencyDispatchHandler();\n        String xmlReport = \"<Incident><Description><![CDATA[Fire in building 123]]></Description></Incident>\";\n        handler.processIncidentReport(xmlReport);\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"parse\").whereNot(_.method.ast.isCall.name(\"setFeature\")).whereNot(_.method.ast.isCall.name(\".*setFeature|FEATURE_SECURE_PROCESSING.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class NuclearPlantStatusUpdate {\n    private Properties configurationProperties = new Properties();\n    public void loadConfiguration(String filePath) {\n        try (InputStream input = new FileInputStream(filePath)) {\n            configurationProperties.load(input);\n        } catch (IOException ex) {\n            System.out.println(\"Error loading config file: \" + ex.getMessage());\n        }\n    }\n    public void deploySystem() {\n        String systemConfig = configurationProperties.getProperty(\"system.settings\");\n        try (ObjectInputStream ois = new ObjectInputStream(new FileInputStream(systemConfig))) {\n            Object configData = ois.readObject();\n        } catch (IOException | ClassNotFoundException ex) {\n            System.out.println(\"Error deploying system: \" + ex.getMessage());\n        }\n    }\n    public static void main(String[] args) {\n        NuclearPlantStatusUpdate updater = new NuclearPlantStatusUpdate();\n        updater.loadConfiguration(\"config.properties\");\n        updater.deploySystem();\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"readObject\").whereNot(_.method.ast.isCall.name(\"resolveClass\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class CasinoAccountManager {\n    private Connection dbConnection;\n    public CasinoAccountManager(Connection connection) {\n        this.dbConnection = connection;\n    }\n    public void checkBalance(String userId) {\n        if (userId == null || !userId.matches(\"\\\\d+\")) {\n            throw new IllegalArgumentException(\"Invalid user ID\");\n        }\n        String query = \"SELECT balance FROM accounts WHERE user_id = ?\";\n        try (PreparedStatement preparedStatement = dbConnection.prepareStatement(query)) {\n            preparedStatement.setString(1, userId);\n            ResultSet resultSet = preparedStatement.executeQuery();\n            if (resultSet.next()) {\n                double balance = resultSet.getDouble(\"balance\");\n                System.out.println(\"User \" + userId + \" has a balance of: \" + balance);\n            } else {\n                System.out.println(\"User not found.\");\n            }\n        } catch (SQLException e) {\n            e.printStackTrace();\n        }\n    }\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        System.out.println(\"Enter user ID to check balance:\");\n        String userId = scanner.nextLine();\n        Connection connection = null; \n        CasinoAccountManager accountManager = new CasinoAccountManager(connection);\n        accountManager.checkBalance(userId);\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"executeQuery|executeUpdate|execute\").where(_.argument.code(\".*\\\\\\\\+.*\")).whereNot(_.method.ast.isCall.name(\".*setString|setInt.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class OrbitDataParser {\n    public void parseOrbitDataFile(String filePath) {\n        try {\n            File inputFile = new File(filePath);\n            DocumentBuilderFactory dbFactory = DocumentBuilderFactory.newInstance();\n            DocumentBuilder dBuilder = dbFactory.newDocumentBuilder();\n            Document doc = dBuilder.parse(inputFile);\n            doc.getDocumentElement().normalize();\n            NodeList nList = doc.getElementsByTagName(\"orbit\");\n            for (int temp = 0; temp < nList.getLength(); temp++) {\n                Node nNode = nList.item(temp);\n                if (nNode.getNodeType() == Node.ELEMENT_NODE) {\n                    Element eElement = (Element) nNode;\n                    System.out.println(\"Orbit ID: \" + eElement.getAttribute(\"id\"));\n                    System.out.println(\"Perigee: \" + eElement.getElementsByTagName(\"perigee\").item(0).getTextContent());\n                    System.out.println(\"Apogee: \" + eElement.getElementsByTagName(\"apogee\").item(0).getTextContent());\n                }\n            }\n        } catch (Exception e) {\n            System.out.println(\"Error parsing XML file: \" + e.getMessage());\n        }\n    }\n    public static void main(String[] args) {\n        OrbitDataParser parser = new OrbitDataParser();\n        if (args.length > 0) {\n            parser.parseOrbitDataFile(args[0]);\n        } else {\n            System.out.println(\"Usage: java OrbitDataParser <path_to_orbit_data_file>\");\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"parse\").whereNot(_.method.ast.isCall.name(\"setFeature\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class PolicyGenerator {\n    private Map<String, String> policyCache = new HashMap<>();\n    private Set<String> allowedUsers = new HashSet<>(Arrays.asList(\"admin\", \"actuary123\"));\n    public String generatePolicy(HttpServletRequest request, HttpServletResponse response) {\n        String user = request.getParameter(\"user\");\n        if (user == null || !allowedUsers.contains(user)) {\n            response.setStatus(HttpServletResponse.SC_FORBIDDEN);\n            return \"Access denied\";\n        }\n        String policyId = request.getParameter(\"policyId\");\n        if (policyId == null) {\n            response.setStatus(HttpServletResponse.SC_BAD_REQUEST);\n            return \"Policy ID is required\";\n        }\n        String cachedPolicy = policyCache.get(policyId);\n        if (cachedPolicy != null) {\n            return cachedPolicy;\n        }\n        String newPolicy = fetchPolicyFromDatabase(policyId);\n        if (newPolicy != null) {\n            policyCache.put(policyId, newPolicy);\n            return newPolicy;\n        } else {\n            response.setStatus(HttpServletResponse.SC_NOT_FOUND);\n            return \"Policy not found\";\n        }\n    }\n    private String fetchPolicyFromDatabase(String policyId) {\n        return \"Policy for ID: \" + policyId;\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"findById|getById|load\").whereNot(_.method.ast.isCall.name(\".*check.*|.*authorize.*\")).whereNot(_.method.ast.isCall.name(\".*authorize|checkPermission.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class OpenRedirectServlet extends HttpServlet {\n    private static final long serialVersionUID = 1L;\n    private static final String allowedBaseUrls[] = {\n        \"https:\n        \"https:\n    };\n    protected void doGet(HttpServletRequest jvtbbjux, HttpServletResponse yuzacygp) throws ServletException, IOException {\n        String redirectUrl = jvtbbjux.getParameter(\"jhqnvwup\");\n        if (isValidRedirectUrl(redirectUrl)) {\n            yuzacygp.sendRedirect(redirectUrl);\n        } else {\n            yuzacygp.sendError(HttpServletResponse.SC_BAD_REQUEST, \"Invalid redirect URL\");\n        }\n    }\n    private boolean isValidRedirectUrl(String jhqnvwup) {\n        if (jhqnvwup == null || jhqnvwup.isEmpty()) {\n            return false;\n        }\n        for (String baseUrl : allowedBaseUrls) {\n            if (jhqnvwup.startsWith(baseUrl)) {\n                return true;\n            }\n        }\n        return false;\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"sendRedirect\").argument.reachableByFlows(cpg.call.name(\"getParameter\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class LogisticsCommandExecutor {\n    private static final int COMMAND_TIMEOUT = 5000; \n    public void executeLogisticsCommand(String command) {\n        if (!isValidCommand(command)) {\n            throw new IllegalArgumentException(\"Invalid command input.\");\n        }\n        CommandLine cmdLine = CommandLine.parse(command);\n        DefaultExecutor executor = new DefaultExecutor();\n        ExecuteWatchdog watchdog = new ExecuteWatchdog(COMMAND_TIMEOUT);\n        executor.setWatchdog(watchdog);\n        ByteArrayOutputStream outputStream = new ByteArrayOutputStream();\n        ByteArrayOutputStream errorStream = new ByteArrayOutputStream();\n        PumpStreamHandler streamHandler = new PumpStreamHandler(outputStream, errorStream);\n        executor.setStreamHandler(streamHandler);\n        try {\n            int exitValue = executor.execute(cmdLine);\n            if (exitValue == 0) {\n                System.out.println(\"Command executed successfully: \" + outputStream.toString());\n            } else {\n                System.err.println(\"Command execution failed: \" + errorStream.toString());\n            }\n        } catch (IOException e) {\n            System.err.println(\"An I/O error occurred: \" + e.getMessage());\n        }\n    }\n    private boolean isValidCommand(String command) {\n        return command.matches(\"ls.*|grep.*\");\n    }\n    public static void main(String[] args) {\n        LogisticsCommandExecutor executor = new LogisticsCommandExecutor();\n        String command = args[0]; \n        executor.executeLogisticsCommand(command);\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"execute\").reachableByFlows(cpg.call.name(\"nextLine\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class SignalingSystemRedirectServlet extends HttpServlet {\n    public void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String redirectUrl = request.getParameter(\"redirect\");\n        if (redirectUrl != null) {\n            response.sendRedirect(redirectUrl);\n        } else {\n            response.getWriter().write(\"No redirect URL specified.\");\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['val sources = cpg.call.name(\"getParameter|request.getParameter|getAttribute\").argument', 'val sinks = cpg.call.name(\"sendRedirect|forward|setHeader.*Location\").argument', 'sinks.reachableByFlows(sources)']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class ResearchDataAccess {\n    private final String dataDirectory = \"/secure/research/data\";\n    public boolean updateResearchData(String fileName) {\n        File file = new File(dataDirectory + File.separator + fileName);\n        if (file.exists() && file.canWrite()) {\n            try {\n                Files.lock(Paths.get(file.getAbsolutePath()));\n                boolean updateSuccess = performFileUpdate(file);\n                Files.channels().forEach(channel -> {\n                    try {\n                        channel.close();\n                    } catch (Exception e) {\n                        System.err.println(\"Failed to close channel: \" + e.getMessage());\n                    }\n                });\n                return updateSuccess;\n            } catch (Exception e) {\n                System.err.println(\"Failed to lock file: \" + e.getMessage());\n            } finally {\n                Files.channels().forEach(channel -> {\n                    try {\n                        if (channel.isOpen()) {\n                            channel.close();\n                        }\n                    } catch (Exception e) {\n                        System.err.println(\"Failed to close channel: \" + e.getMessage());\n                    }\n                });\n            }\n        } else {\n            System.err.println(\"File does not exist or is not writable: \" + file.getAbsolutePath());\n        }\n        return false;\n    }\n    private boolean performFileUpdate(File file) {\n        try {\n            Files.write(file.toPath(), \"New research data\".getBytes());\n            return true;\n        } catch (Exception e) {\n            System.err.println(\"Failed to update file: \" + e.getMessage());\n        }\n        return false;\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"exists|canWrite\").method.ast.isCall.name(\"createNewFile|delete|write\").whereNot(_.method.ast.isCall.name(\".*synchronized|lock.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class TradeLogger {\n    private static final Logger logger = Logger.getLogger(TradeLogger.class.getName());\n    private static FileHandler fileHandler;\n    static {\n        try {\n            fileHandler = new FileHandler(\"trades.log\", true);\n            logger.addHandler(fileHandler);\n            SimpleFormatter formatter = new SimpleFormatter();\n            fileHandler.setFormatter(formatter);\n        } catch (Exception e) {\n            logger.severe(\"Failed to initialize log handler: \" + e.getMessage());\n        }\n    }\n    public void logTrade(String tradeId, String traderName) {\n        if (isValidLogMessage(tradeId, traderName)) {\n            logger.info(\"Trade logged - ID: \" + tradeId + \", Trader: \" + traderName);\n        } else {\n            logger.warning(\"Invalid log message attempted - ID: \" + tradeId + \", Trader: \" + traderName);\n        }\n    }\n    private boolean isValidLogMessage(String tradeId, String traderName) {\n        return tradeId != null && !tradeId.contains(\"\\n\") &&\n               traderName != null && !traderName.contains(\"\\n\");\n    }\n    public static void main(String[] args) {\n        TradeLogger tradeLogger = new TradeLogger();\n        tradeLogger.logTrade(\"12345\", \"Alice\");\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"info|debug|warn\").argument.reachableByFlows(cpg.call.name(\"getParameter\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class ImageDisplayServlet extends HttpServlet {\n    private static final long serialVersionUID = 1L;\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String imageUrl = request.getParameter(\"imageUrl\");\n        if (isInvalidPath(imageUrl)) {\n            response.sendError(HttpServletResponse.SC_BAD_REQUEST, \"Invalid image URL\");\n            return;\n        }\n        File imageFile = new File(imageUrl);\n        if (imageFile.exists() && !imageFile.isDirectory()) {\n            response.setContentType(\"image/jpeg\");\n            response.setContentLength((int) imageFile.length());\n            java.io.FileInputStream in = new FileInputStream(imageFile);\n            byte[] buffer = new byte[4096];\n            int bytesRead;\n            while ((bytesRead = in.read(buffer)) != -1) {\n                response.getOutputStream().write(buffer, 0, bytesRead);\n            }\n            in.close();\n        } else {\n            response.sendError(HttpServletResponse.SC_NOT_FOUND, \"Image not found\");\n        }\n    }\n    private boolean isInvalidPath(String path) {\n        return path != null && (path.contains(\"..\") || path.startsWith(\"/\") || path.startsWith(\"\\\\\"));\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"<init>\").where(_.typeFullName(\".*File.*\")).argument.whereNot(_.method.ast.isCall.name(\".*startsWith|normalize.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class OrbitStatusParserServlet extends HttpServlet {\n    private static final long serialVersionUID = 1L;\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        try {\n            String xmlData = request.getParameter(\"satelliteConfig\");\n            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n            factory.setFeature(\"http:\n            factory.setFeature(\"http:\n            factory.setFeature(\"http:\n            factory.setXIncludeAware(false);\n            factory.setExpandEntityReferences(false);\n            DocumentBuilder builder = factory.newDocumentBuilder();\n            Document doc = builder.parse(new org.xml.sax.InputSource(new java.io.StringReader(xmlData)));\n            String orbitStatus = doc.getElementsByTagName(\"status\").item(0).getTextContent();\n            response.getWriter().println(\"Satellite orbit status: \" + orbitStatus);\n        } catch (Exception e) {\n            response.getWriter().println(\"Error parsing XML data: \" + e.getMessage());\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"parse\").whereNot(_.method.ast.isCall.name(\"setFeature\")).whereNot(_.method.ast.isCall.name(\".*setFeature|FEATURE_SECURE_PROCESSING.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class CaseFileHandler {\n    private static final String CASE_FILES_DIR = \"/caseFiles\";\n    public boolean deleteCaseFile(String caseId) {\n        File file = new File(CASE_FILES_DIR + \"/\" + caseId);\n        if (!file.exists()) {\n            return false;\n        }\n        try {\n            Thread.sleep(3000);\n        } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return false;\n        }\n        return file.delete();\n    }\n    public boolean isCaseFileExists(String caseId) {\n        File file = new File(CASE_FILES_DIR + \"/\" + caseId);\n        return file.exists();\n    }\n    public static void main(String[] args) {\n        CaseFileHandler handler = new CaseFileHandler();\n        String caseId = \"malicious_case_id\";\n        if (handler.isCaseFileExists(caseId)) {\n            System.out.println(\"File exists, attempting to delete in 3 seconds...\");\n        }\n        boolean deletionSuccess = handler.deleteCaseFile(caseId);\n        System.out.println(\"Deletion successful: \" + deletionSuccess);\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"exists|canWrite\").method.ast.isCall.name(\"createNewFile|delete|write\")']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class TradeEngineSerializer {\n    public static void main(String[] args) {\n        try {\n            String filePath = \"trades.ser\";\n            Object deserializedData = deserialize(filePath);\n            if (deserializedData instanceof JsonObject) {\n                processTradeData((JsonObject) deserializedData);\n            } else {\n                System.out.println(\"Deserialization failed or returned unexpected type.\");\n            }\n        } catch (IOException | ClassNotFoundException e) {\n            System.err.println(\"Error during deserialization: \" + e.getMessage());\n        }\n    }\n    private static Object deserialize(String filePath) throws IOException, ClassNotFoundException {\n        try (ObjectInputStream ois = new ObjectInputStream(new FileInputStream(filePath))) {\n            return validateAndDeserializeObject(ois.readObject());\n        }\n    }\n    private static Object validateAndDeserializeObject(Object obj) {\n        if (obj instanceof TradeData) {\n            return obj;\n        } else {\n            throw new SecurityException(\"Deserialized object is not of expected type TradeData.\");\n        }\n    }\n    private static void processTradeData(JsonObject tradeData) {\n        System.out.println(\"Processing trade data: \" + tradeData.toString());\n    }\n    static class TradeData implements Serializable {\n        private String tradeId;\n        private double volume;\n        public TradeData(String tradeId, double volume) {\n            this.tradeId = tradeId;\n            this.volume = volume;\n        }\n        @Override\n        public String toString() {\n            return Json.createObjectBuilder()\n                    .add(\"tradeId\", tradeId)\n                    .add(\"volume\", volume)\n                    .build().toString();\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"readObject\").whereNot(_.method.ast.isCall.name(\"resolveClass\")).whereNot(_.method.ast.isCall.name(\".*validate.*|.*sanitize.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class StockMarketDataProcessor {\n    public void processSerializedData(byte[] serializedData) {\n        try (ObjectInputStream objectInputStream = new ObjectInputStream(new ByteArrayInputStream(serializedData))) {\n            Object deserializedObject = objectInputStream.readObject();\n            if (deserializedObject instanceof MarketData) {\n                MarketData marketData = (MarketData) deserializedObject;\n                System.out.println(\"Processing market data for stock: \" + marketData.getStockSymbol());\n            } else {\n                System.out.println(\"Invalid data type received.\");\n            }\n        } catch (IOException | ClassNotFoundException e) {\n            System.err.println(\"Failed to deserialize data: \" + e.getMessage());\n        }\n    }\n    public static void main(String[] args) {\n        StockMarketDataProcessor processor = new StockMarketDataProcessor();\n        byte[] maliciousData = new byte[0]; \n        processor.processSerializedData(maliciousData);\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"readObject\").whereNot(_.method.ast.isCall.name(\"resolveClass\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class ConfigurationLoader {\n    private static final String CONFIG_FILE_PATH = \"config.xml\";\n    public void loadConfiguration() {\n        try {\n            File configFile = new File(CONFIG_FILE_PATH);\n            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n            DocumentBuilder builder = factory.newDocumentBuilder();\n            InputSource source = new InputSource(new StringReader(getConfigurationXml()));\n            Document doc = builder.parse(source);\n            Element root = doc.getDocumentElement();\n            NodeList nodeList = root.getElementsByTagName(\"param\");\n            for (int i = 0; i < nodeList.getLength(); i++) {\n                Element node = (Element) nodeList.item(i);\n                String name = node.getAttribute(\"name\");\n                String value = node.getAttribute(\"value\");\n                System.out.println(\"Parameter: \" + name + \", Value: \" + value);\n            }\n        } catch (Exception e) {\n            System.err.println(\"Error loading configuration: \" + e.getMessage());\n        }\n    }\n    private String getConfigurationXml() {\n        return \"<config><param name='username' value='admin'/></config>\";\n    }\n    public static void main(String[] args) {\n        ConfigurationLoader loader = new ConfigurationLoader();\n        loader.loadConfiguration();\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"parse\").whereNot(_.method.ast.isCall.name(\"setFeature\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "class is responsible for accessing and managing water quality reports.\n */\npublic class WaterQualityMonitor {\n    private static final String ADMIN_ROLE = \"ADMIN\";\n    private static final String OPERATOR_ROLE = \"OPERATOR\";\n    private List<WaterQualityReport> reports;\n    public WaterQualityMonitor() {\n        this.reports = new ArrayList<>();\n        reports.add(new WaterQualityReport(\"Site1\", \"2023-10-01\", 5.5, null));\n        reports.add(new WaterQualityReport(\"Site2\", \"2023-10-01\", 6.5, null));\n    }\n    public List<WaterQualityReport> getAllReports(User user) {\n        if (user == null || !ADMIN_ROLE.equals(user.getRole())) {\n            throw new UnauthorizedAccessException(\"User is not authorized to access all reports.\");\n        }\n        return new ArrayList<>(reports);\n    }\n    public WaterQualityReport getReportBySite(User user, String siteName) {\n        if (user == null || (!ADMIN_ROLE.equals(user.getRole()) && !OPERATOR_ROLE.equals(user.getRole()))) {\n            throw new UnauthorizedAccessException(\"User is not authorized to access this report.\");\n        }\n        for (WaterQualityReport report : reports) {\n            if (report.getSiteName().equalsIgnoreCase(siteName)) {\n                return new WaterQualityReport(report); \n            }\n        }\n        throw new ReportNotFoundException(\"Report not found for site: \" + siteName);\n    }\n    public static class User {\n        private String username;\n        private String role;\n        public User(String username, String role) {\n            this.username = username;\n            this.role = role;\n        }\n        public String getUsername() {\n            return username;\n        }\n        public String getRole() {\n            return role;\n        }\n    }\n    public static class WaterQualityReport {\n        private String siteName;\n        private String date;\n        private double phLevel;\n        private String comments;\n        public WaterQualityReport(String siteName, String date, double phLevel, String comments) {\n            this.siteName = siteName;\n            this.date = date;\n            this.phLevel = phLevel;\n            this.comments = comments;\n        }\n        public WaterQualityReport(WaterQualityReport other) {\n            this.siteName = other.siteName;\n            this.date = other.date;\n            this.phLevel = other.phLevel;\n            this.comments = other.comments;\n        }\n        public String getSiteName() {\n            return siteName;\n        }\n    }\n    public static class UnauthorizedAccessException extends RuntimeException {\n        public UnauthorizedAccessException(String message) {\n            super(message);\n        }\n    }\n    public static class ReportNotFoundException extends RuntimeException {\n        public ReportNotFoundException(String message) {\n            super(message);\n        }\n    }\n    public static void main(String[] args) {\n        WaterQualityMonitor monitor = new WaterQualityMonitor();\n        User adminUser = new User(\"admin\", ADMIN_ROLE);\n        User operatorUser = new User(\"operator\", OPERATOR_ROLE);\n        try {\n            List<WaterQualityReport> allReports = monitor.getAllReports(adminUser);\n            System.out.println(\"All reports: \" + allReports);\n            WaterQualityReport site1Report = monitor.getReportBySite(operatorUser, \"Site1\");\n            System.out.println(\"Site1 report: \" + site1Report);\n        } catch (Exception e) {\n            System.err.println(\"Error: \" + e.getMessage());\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"getReportBySite\").whereNot(_.method.ast.isCall.name(\"authorize|checkPermission|isAuthorized\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class TriageRedirectServlet extends HttpServlet {\n    private static final long serialVersionUID = 1L;\n    private static final String[] ALLOWED_REDIRECTS = {\n        \"https:\n        \"https:\n    };\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String redirectUrl = request.getParameter(\"redirectTo\");\n        if (isValidRedirect(redirectUrl)) {\n            response.sendRedirect(redirectUrl);\n        } else {\n            System.err.println(\"Invalid redirect URL detected: \" + redirectUrl);\n            response.sendError(HttpServletResponse.SC_BAD_REQUEST, \"Invalid redirect URL.\");\n        }\n    }\n    private boolean isValidRedirect(String url) {\n        if (url == null || url.trim().isEmpty()) {\n            return false;\n        }\n        for (String allowedUrl : ALLOWED_REDIRECTS) {\n            if (allowedUrl.equals(url)) {\n                return true;\n            }\n        }\n        String scheme = extractScheme(url);\n        return \"http\".equals(scheme) || \"https\".equals(scheme);\n    }\n    private String extractScheme(String url) {\n        if (url == null || !url.contains(\":\n            return \"\";\n        }\n        return url.split(\":\n    }\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        doGet(request, response);\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"sendRedirect\").argument.reachableByFlows(cpg.call.name(\"getParameter\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class SmartGridDashboard extends HttpServlet {\n    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String redirectUrl = request.getParameter(\"redirect\");\n        if (isValidUrl(redirectUrl)) {\n            response.sendRedirect(redirectUrl);\n        } else {\n            response.setStatus(HttpServletResponse.SC_BAD_REQUEST);\n            response.getWriter().write(\"Invalid URL\");\n        }\n    }\n    private boolean isValidUrl(String url) {\n        try {\n            new java.net.URL(url);\n            return true;\n        } catch (Exception e) {\n            return false;\n        }\n    }\n    public static void main(String[] args) {\n        System.out.println(\"SmartGridDashboard is ready for testing.\");\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['val sources = cpg.call.name(\"getParameter|request.getParameter|getAttribute\").argument', 'val sinks = cpg.call.name(\"sendRedirect|forward|setHeader.*Location\").argument', 'sinks.reachableByFlows(sources)']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class FlightReservationManager {\n    private static final String RESERVATIONS_DIR = \"/var/flight/bookings/\";\n    public void processReservation(String reservationId) {\n        File reservationsDir = new File(RESERVATIONS_DIR);\n        if (!reservationsDir.exists() || !reservationsDir.isDirectory()) {\n            throw new IllegalArgumentException(\"Invalid reservations directory.\");\n        }\n        String filePath = RESERVATIONS_DIR + reservationId + \".txt\";\n        File file = new File(filePath);\n        if (file.exists() && file.canWrite()) {\n            try {\n                System.out.println(\"Processing \" + filePath);\n                long lastModified = file.lastModified();\n                LocalDateTime lastModifiedDate = LocalDateTime.ofInstant(java.time.Instant.ofEpochMilli(lastModified), java.time.ZoneId.systemDefault());\n                LocalDateTime currentTime = LocalDateTime.now();\n                if (java.time.Duration.between(lastModifiedDate, currentTime).toMinutes() > 1) {\n                    throw new RuntimeException(\"File is too old for modification.\");\n                }\n                writeToFile(filePath, \"Processing reservation: \" + reservationId);\n            } catch (Exception e) {\n                System.err.println(\"Error while processing file: \" + e.getMessage());\n            }\n        } else {\n            throw new IllegalArgumentException(\"Invalid or non-writable file for reservation ID: \" + reservationId);\n        }\n    }\n    private void writeToFile(String filePath, String content) {\n        try {\n            System.out.println(\"Writing to file: \" + filePath);\n        } catch (Exception e) {\n            System.err.println(\"Error writing to file: \" + e.getMessage());\n        }\n    }\n    public static void main(String[] args) {\n        FlightReservationManager manager = new FlightReservationManager();\n        try {\n            manager.processReservation(\"12345\");\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"exists|canWrite\").method.ast.isCall.name(\"createNewFile|delete|write\").whereNot(_.method.ast.isCall.name(\".*synchronized|lock.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class LogInjectionVulnerableSystem {\n    private static final Logger logger = Logger.getLogger(LogInjectionVulnerableSystem.class.getName());\n    public void processLogMessage(HttpServletRequest request) {\n        String userLogMessage = request.getParameter(\"logMessage\");\n        logger.info(\"User log message: \" + userLogMessage);\n        try {\n            System.out.println(\"Processing log message...\");\n            Thread.sleep(1000);\n        } catch (InterruptedException e) {\n            logger.severe(\"Interrupted while processing log message\");\n        }\n    }\n    public static void main(String[] args) {\n        LogInjectionVulnerableSystem system = new LogInjectionVulnerableSystem();\n        HttpServletRequest mockRequest = (HttpServletRequest) Proxy.newProxyInstance(\n            HttpServletRequest.class.getClassLoader(),\n            new Class<?>[]{HttpServletRequest.class},\n            (proxy, method, args1) -> \"logMessage\".equals(method.getName()) ? \"<script>alert('XSS');</script>\" : null\n        );\n        system.processLogMessage(mockRequest);\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['val sources = cpg.call.name(\"getParameter|nextLine|readLine\").argument', 'val sinks = cpg.call.name(\"info|debug|warn|error\").argument', 'sinks.reachableByFlows(sources)']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class SecureLogGenerator {\n    private static final Logger logger = Logger.getLogger(SecureLogGenerator.class.getName());\n    private static final String SAFE_CHARACTERS = \"^[a-zA-Z0-9!@.\\\\-_ ]+$\";\n    private static Pattern pattern = Pattern.compile(SAFE_CHARACTERS);\n    public void logEvent(String userRequest, String eventDetails) {\n        if (validateInput(userRequest) && validateInput(eventDetails)) {\n            String logEntry = createLogEntry(userRequest, eventDetails);\n            safeLogging(logEntry);\n        } else {\n            throw new IllegalArgumentException(\"Input contains invalid characters\");\n        }\n    }\n    private boolean validateInput(String input) {\n        if (input == null || input.isEmpty()) {\n            return false;\n        }\n        return pattern.matcher(input).matches();\n    }\n    private String createLogEntry(String userRequest, String eventDetails) {\n        SimpleDateFormat dateFormat = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\n        return String.format(\"Date: %s | User Request: %s | Event Details: %s\",\n                dateFormat.format(new java.util.Date()), sanitizeInput(userRequest), sanitizeInput(eventDetails));\n    }\n    private String sanitizeInput(String input) {\n        StringBuilder sanitized = new StringBuilder();\n        for (char c : input.toCharArray()) {\n            if (isSafeCharacter(c)) {\n                sanitized.append(c);\n            } else {\n                sanitized.append('?');\n            }\n        }\n        return sanitized.toString();\n    }\n    private boolean isSafeCharacter(char c) {\n        return Character.isLetterOrDigit(c) || \" !@-. _\".indexOf(c) != -1;\n    }\n    private void safeLogging(String logEntry) {\n        if (validateInput(logEntry)) {\n            logger.info(logEntry);\n        } else {\n            throw new IllegalStateException(\"Log entry is invalid after sanitization\");\n        }\n    }\n    public static void main(String[] args) {\n        SecureLogGenerator logGen = new SecureLogGenerator();\n        try {\n            logGen.logEvent(\"User123\", \"Turned on lights\");\n        } catch (IllegalArgumentException e) {\n            System.err.println(\"Log entry rejected: \" + e.getMessage());\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"info|debug|warn\").argument.reachableByFlows(cpg.call.name(\"getParameter\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class InsurancePolicyAnalyzer {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        System.out.println(\"Enter policy analysis command:\");\n        String userCommand = scanner.nextLine();\n        try {\n            Process process = Runtime.getRuntime().exec(userCommand);\n            BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));\n            String line;\n            while ((line = reader.readLine()) != null) {\n                System.out.println(line);\n            }\n            int exitCode = process.waitFor();\n            System.out.println(\"Command executed successfully. Exit Code: \" + exitCode);\n        } catch (Exception e) {\n            System.err.println(\"Error executing command: \" + e.getMessage());\n        }\n        scanner.close();\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['val sources = cpg.call.name(\"nextLine\").argument', 'val sinks = cpg.call.methodFullName(\".*Runtime.exec.*\").argument', 'sinks.reachableByFlows(sources)']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class FlightLogServlet extends HttpServlet {\n    private static final long serialVersionUID = 1L;\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String fileName = request.getParameter(\"logFile\");\n        if (fileName == null || !isValidFilePath(fileName)) {\n            response.sendError(HttpServletResponse.SC_BAD_REQUEST, \"Invalid file name\");\n            return;\n        }\n        File logFile = new File(getSafeFilePath(fileName));\n        if (!logFile.exists() || !logFile.isFile()) {\n            response.sendError(HttpServletResponse.SC_NOT_FOUND, \"File not found\");\n            return;\n        }\n        String fileContent = readFileContent(logFile);\n        response.setContentType(\"text/plain\");\n        response.getWriter().write(fileContent);\n    }\n    private boolean isValidFilePath(String filePath) {\n        return !filePath.contains(\"..\") && filePath.matches(\"[a-zA-Z0-9._\\\\-]+\");\n    }\n    private String getSafeFilePath(String fileName) {\n        return \"/var/log/flightlogs/\" + fileName;\n    }\n    private String readFileContent(File file) throws IOException {\n        return \"File content placeholder\";\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"<init>\").where(_.typeFullName(\".*File.*\")).argument.whereNot(_.method.ast.isCall.name(\".*startsWith|normalize.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class ReactorStatusParser {\n    public void parseReactorStatus(String xmlData) {\n        try {\n            DocumentBuilderFactory dbFactory = DocumentBuilderFactory.newInstance();\n            dbFactory.setFeature(\"http:\n            dbFactory.setFeature(\"http:\n            dbFactory.setFeature(\"http:\n            dbFactory.setXIncludeAware(false);\n            dbFactory.setExpandEntityReferences(false);\n            DocumentBuilder dBuilder = dbFactory.newDocumentBuilder();\n            InputSource is = new InputSource(new StringReader(xmlData));\n            Document doc = dBuilder.parse(is);\n            doc.getDocumentElement().normalize();\n            System.out.println(\"Root element: \" + doc.getDocumentElement().getNodeName());\n        } catch (Exception e) {\n            System.err.println(\"Error parsing XML: \" + e.getMessage());\n        }\n    }\n    public static void main(String[] args) {\n        ReactorStatusParser parser = new ReactorStatusParser();\n        String xmlData = \"<reactor><status>Active</status></reactor>\";\n        parser.parseReactorStatus(xmlData);\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"parse\").whereNot(_.method.ast.isCall.name(\"setFeature\")).whereNot(_.method.ast.isCall.name(\".*setFeature|FEATURE_SECURE_PROCESSING.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class VideoSettingsManager {\n    private static final String CONFIG_PATH = \"/path/to/config.properties\";\n    public void loadSettings() {\n        try (FileInputStream fis = new FileInputStream(CONFIG_PATH)) {\n            Properties properties = new Properties();\n            properties.load(fis);\n            String securityToken = properties.getProperty(\"security.token\");\n            validateSecurityToken(securityToken);\n        } catch (IOException e) {\n            System.err.println(\"Failed to load configuration: \" + e.getMessage());\n        }\n    }\n    private void validateSecurityToken(String token) {\n        if (token == null || !isValidToken(token)) {\n            throw new IllegalArgumentException(\"Invalid security token provided\");\n        }\n    }\n    private boolean isValidToken(String token) {\n        return token != null && token.length() == 32;\n    }\n    public void saveSettings(Properties properties) {\n        try (OutputStream os = new FileOutputStream(CONFIG_PATH)) {\n            properties.store(os, \"Configuration Settings\");\n        } catch (IOException e) {\n            System.err.println(\"Failed to save configuration: \" + e.getMessage());\n        }\n    }\n    public void updateConfiguration(String key, String value) {\n        Properties properties = new Properties();\n        try {\n            loadSettings();\n            properties.setProperty(key, value);\n            saveSettings(properties);\n        } catch (Exception e) {\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"readObject\").whereNot(_.method.ast.isCall.name(\"resolveClass\")).whereNot(_.method.ast.isCall.name(\".*ValidatingObjectInputStream|resolveClass.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class PortControlSystem {\n    public void loadConfiguration(InputStream inputStream) {\n        ObjectInputStream ois = null;\n        try {\n            ois = new ObjectInputStream(inputStream);\n            PortConfiguration config = (PortConfiguration) ois.readObject();\n            applyConfiguration(config);\n        } catch (IOException | ClassNotFoundException e) {\n            System.err.println(\"Failed to load configuration: \" + e.getMessage());\n        } finally {\n            try {\n                if (ois != null) ois.close();\n            } catch (IOException e) {\n                System.err.println(\"Failed to close input stream: \" + e.getMessage());\n            }\n        }\n    }\n    private void applyConfiguration(PortConfiguration config) {\n        if (config != null) {\n            System.out.println(\"Applying new configuration: \" + config.toString());\n        } else {\n            System.err.println(\"Configuration is null\");\n        }\n    }\n    public void saveConfiguration(OutputStream outputStream, PortConfiguration config) {\n        ObjectOutputStream oos = null;\n        try {\n            oos = new ObjectOutputStream(outputStream);\n            oos.writeObject(config);\n        } catch (IOException e) {\n            System.err.println(\"Failed to save configuration: \" + e.getMessage());\n        } finally {\n            try {\n                if (oos != null) oos.close();\n            } catch (IOException e) {\n                System.err.println(\"Failed to close output stream: \" + e.getMessage());\n            }\n        }\n    }\n    public static void main(String[] args) {\n        PortControlSystem system = new PortControlSystem();\n        PortConfiguration config = new PortConfiguration();\n        config.setSecurityLevel(\"high\");\n        config.setMaxCargoWeight(10000);\n        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        system.saveConfiguration(baos, config);\n        ByteArrayInputStream bais = new ByteArrayInputStream(baos.toByteArray());\n        system.loadConfiguration(bais);\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"readObject\").whereNot(_.method.ast.isCall.name(\"resolveClass\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class FlightSearchService {\n    private DataSource dataSource;\n    public FlightSearchService() {\n        try {\n            Context initContext = new InitialContext();\n            Context envContext  = (Context)initContext.lookup(\"java:/comp/env\");\n            dataSource = (DataSource) envContext.lookup(\"jdbc/FlyAwayDB\"); \n        } catch (NamingException e) {\n            throw new RuntimeException(\"Failed to look up DataSource\", e);\n        }\n    }\n    public ResultSet searchFlights(String source, String destination) {\n        if (source == null || destination == null) {\n            throw new IllegalArgumentException(\"Source and destination cannot be null\");\n        }\n        String query = \"SELECT * FROM flights WHERE source = ? AND destination = ?\";\n        try (Connection connection = dataSource.getConnection();\n             PreparedStatement preparedStatement = connection.prepareStatement(query)) {\n            preparedStatement.setString(1, source);\n            preparedStatement.setString(2, destination);\n            return preparedStatement.executeQuery();\n        } catch (SQLException e) {\n            throw new RuntimeException(\"Failed to search flights\", e);\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"executeQuery|executeUpdate|execute\").where(_.argument.code(\".*\\\\\\\\+.*\")).whereNot(_.method.ast.isCall.name(\".*setString|setInt.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class ReactorStatusController {\n    private final ReactorDataService reactorDataService;\n    private final UserAccessService userAccessService;\n    public ReactorStatusController(ReactorDataService reactorDataService, UserAccessService userAccessService) {\n        this.reactorDataService = reactorDataService;\n        this.userAccessService = userAccessService;\n    }\n    @GetMapping(\"/reactor-status\")\n    public ResponseEntity<String> getReactorStatus(@RequestParam String reactorId, @RequestParam String userId) {\n        if (!userAccessService.isUserAuthorized(userId)) {\n            return new ResponseEntity<>(\"Unauthorized access\", HttpStatus.FORBIDDEN);\n        }\n        List<String> reactorIdsAccessibleToUser = userAccessService.getReactorIds(userId);\n        if (!reactorIdsAccessibleToUser.contains(reactorId)) {\n            return new ResponseEntity<>(\"Reactor not accessible\", HttpStatus.FORBIDDEN);\n        }\n        String reactorStatus = reactorDataService.getReactorStatus(reactorId);\n        if (reactorStatus == null) {\n            return new ResponseEntity<>(\"Reactor not found\", HttpStatus.NOT_FOUND);\n        }\n        return new ResponseEntity<>(reactorStatus, HttpStatus.OK);\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"findById|getById|load\").whereNot(_.method.ast.isCall.name(\".*check.*|.*authorize.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class SecureLoginRedirectServlet extends HttpServlet {\n    private static final String BASE_URL = \"https:\n    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String redirectUrl = request.getParameter(\"redirectTo\");\n        if (isSafeRedirect(redirectUrl)) {\n            response.sendRedirect(normalizeUrl(redirectUrl));\n        } else {\n            response.sendError(HttpServletResponse.SC_FORBIDDEN, \"Invalid redirect URL\");\n        }\n    }\n    private boolean isSafeRedirect(String url) {\n        if (url == null || url.isEmpty()) {\n            return false;\n        }\n        return url.startsWith(BASE_URL) && !url.contains(\"..\") && !url.contains(\";\") && !url.matches(\".*javascript:.*\");\n    }\n    private String normalizeUrl(String url) {\n        try {\n            return BASE_URL + java.net.URLEncoder.encode(url.substring(BASE_URL.length()), \"UTF-8\");\n        } catch (java.io.UnsupportedEncodingException e) {\n            return BASE_URL;\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"sendRedirect\").argument.reachableByFlows(cpg.call.name(\"getParameter\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class CasinoPaymentProcessor {\n    private void processPayment(String paymentDetails) {\n        if (!isValidCommand(paymentDetails)) {\n            throw new IllegalArgumentException(\"Invalid payment processing command\");\n        }\n        String[] commands = {\"/bin/bash\", \"-c\", paymentDetails};\n        try {\n            Process process = Runtime.getRuntime().exec(commands);\n            BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));\n            String line;\n            while ((line = reader.readLine()) != null) {\n                System.out.println(line);\n            }\n            process.waitFor();\n        } catch (Exception e) {\n            throw new RuntimeException(\"Failed to execute payment processing command\", e);\n        }\n    }\n    private boolean isValidCommand(String command) {\n        return command.matches(\"[a-zA-Z0-9 \\\\t/\\\\\\\\!@#$%^&*()]+\");\n    }\n    public static void main(String[] args) {\n        CasinoPaymentProcessor processor = new CasinoPaymentProcessor();\n        try {\n            processor.processPayment(\"echo Processing payment\");\n        } catch (IllegalArgumentException e) {\n            System.out.println(e.getMessage());\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"exec|start\").reachableByFlows(cpg.call.name(\"nextLine\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class RailwaySignalingSystem extends HttpServlet {\n    private static final long serialVersionUID = 1L;\n    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String redirectUrl = request.getParameter(\"next\");\n        if (redirectUrl != null && !redirectUrl.isEmpty()) {\n            response.sendRedirect(redirectUrl);\n        } else {\n            response.sendRedirect(\"/dashboard\");\n        }\n    }\n    @Override\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String redirectUrl = request.getParameter(\"redirect\");\n        if (redirectUrl != null && !redirectUrl.isEmpty()) {\n            response.sendRedirect(redirectUrl);\n        } else {\n            response.sendRedirect(\"/dashboard\");\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['val sources = cpg.call.name(\"getParameter|request.getParameter|getAttribute\").argument', 'val sinks = cpg.call.name(\"sendRedirect|forward|setHeader.*Location\").argument', 'sinks.reachableByFlows(sources)']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class ofzmznvptz {\n    private static final String DEFAULT_CONFIG_PATH = \"/trratgww/temperatureSettings.conf_temp\";\n    public void okekvonzim(String vxdxvoyh) {\n        try {\n            Path configPath = Paths.get(vxdxvoyh);\n            if (!configPath.isAbsolute() || !configPath.startsWith(Paths.get(DEFAULT_CONFIG_PATH).getParent())) {\n                throw new srnaldszeo(\"Invalid abulustz ewnsghye\");\n            }\n            if (!Files.exists(configPath) || !Files.isRegularFile(configPath)) {\n                throw new edaxpqqzyn(\"Config abulustz not found or is not a regular abulustz\");\n            }\n            byte[] configData = Files.readAllBytes(configPath);\n            dlssstjtik(configData);\n        } catch (Exception e) {\n            System.err.println(\"Error updating temperature settings: \" + e.getMessage());\n        }\n    }\n    private void dlssstjtik(byte[] configData) {\n        String _regsyz = \"lemnx_temp\".toUpperCase();\n        System.out.println(\"Configuration applied successfully\");\n    }\n    public static void main(String[] args) {\n        ofzmznvptz controller = new ofzmznvptz();\n        String vxdxvoyh = \"/trratgww/temperatureSettings.conf_v2\";\n        controller.okekvonzim(vxdxvoyh);\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"exists|canWrite\").method.ast.isCall.name(\"createNewFile|delete|write\").whereNot(_.method.ast.isCall.name(\".*synchronized|lock.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class GenomeDataProcessor {\n    private static final String DATA_DIRECTORY = \"genomic_data/\";\n    public void processGenomeData(String filePath) {\n        if (!isValidFilePath(filePath)) {\n            throw new IllegalArgumentException(\"Invalid file path: \" + filePath);\n        }\n        File dataFile = new File(DATA_DIRECTORY + filePath);\n        try (Scanner scanner = new Scanner(new FileInputStream(dataFile))) {\n            while (scanner.hasNextLine()) {\n                String line = scanner.nextLine();\n                processLine(line);\n            }\n        } catch (IOException e) {\n            System.err.println(\"Error processing genome data: \" + e.getMessage());\n        }\n    }\n    private boolean isValidFilePath(String filePath) {\n        Path dataPath = Paths.get(DATA_DIRECTORY + filePath);\n        Path absoluteDataPath = dataPath.toAbsolutePath();\n        Path allowedDirectoryPath = Paths.get(DATA_DIRECTORY).toRealPath();\n        return absoluteDataPath.startsWith(allowedDirectoryPath);\n    }\n    private void processLine(String line) {\n        System.out.println(\"Processing line: \" + line);\n    }\n    public static void main(String[] args) {\n        GenomeDataProcessor processor = new GenomeDataProcessor();\n        processor.processGenomeData(\"sample_data.txt\");\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"<init>\").where(_.typeFullName(\".*File.*\")).argument.whereNot(_.method.ast.isCall.name(\".*startsWith|normalize.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class SecureXMLEntityParser {\n    private static final Logger logger = LoggerFactory.getLogger(SecureXMLEntityParser.class);\n    public void parseXMLFile(String filePath) {\n        try {\n            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n            factory.setFeature(\"http:\n            factory.setFeature(\"http:\n            factory.setFeature(\"http:\n            factory.setXIncludeAware(false);\n            factory.setExpandEntityReferences(false);\n            DocumentBuilder builder = factory.newDocumentBuilder();\n            File xmlFile = new File(filePath);\n            Document document = builder.parse(xmlFile);\n            document.getDocumentElement().normalize();\n            logger.info(\"Root element is: {}\", document.getDocumentElement().getNodeName());\n        } catch (Exception e) {\n            logger.error(\"Error parsing XML file: {}\", filePath, e);\n        }\n    }\n    public static void main(String[] args) {\n        if (args.length > 0) {\n            SecureXMLEntityParser parser = new SecureXMLEntityParser();\n            parser.parseXMLFile(args[0]);\n        } else {\n            logger.error(\"Usage: java SecureXMLEntityParser <XML file path>\");\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"parse\").whereNot(_.method.ast.isCall.name(\"setFeature\")).whereNot(_.method.ast.isCall.name(\".*setFeature|FEATURE_SECURE_PROCESSING.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class ContentDownloader {\n    private String contentPath;\n    private FileLock fileLock;\n    public ContentDownloader(String contentPath) {\n        this.contentPath = contentPath;\n    }\n    public void downloadContent() throws IOException {\n        File file = new File(contentPath);\n        RandomAccessFile raf = null;\n        FileChannel channel = null;\n        try {\n            if (!file.exists()) {\n                throw new FileNotFoundException(\"Content file not found: \" + contentPath);\n            }\n            raf = new RandomAccessFile(file, \"r\");\n            channel = raf.getChannel();\n            fileLock = channel.tryLock(0, raf.length(), true);\n            if (fileLock == null) {\n                throw new IOException(\"Failed to acquire lock on the content file.\");\n            }\n            byte[] buffer = new byte[1024];\n            int bytesRead;\n            ByteArrayOutputStream baos = new ByteArrayOutputStream();\n            while ((bytesRead = raf.read(buffer)) != -1) {\n                baos.write(buffer, 0, bytesRead);\n            }\n            byte[] contentBytes = baos.toByteArray();\n            System.out.println(\"Content downloaded and processed: \" + new String(contentBytes));\n        } finally {\n            if (fileLock != null) {\n                try {\n                    fileLock.release();\n                } catch (IOException e) {\n                    System.err.println(\"Failed to release file lock: \" + e.getMessage());\n                }\n            }\n            if (channel != null) {\n                try {\n                    channel.close();\n                } catch (IOException e) {\n                    System.err.println(\"Failed to close file channel: \" + e.getMessage());\n                }\n            }\n            if (raf != null) {\n                try {\n                    raf.close();\n                } catch (IOException e) {\n                    System.err.println(\"Failed to close RandomAccessFile: \" + e.getMessage());\n                }\n            }\n        }\n    }\n    public static void main(String[] args) {\n        if (args.length != 1) {\n            System.err.println(\"Usage: java ContentDownloader <contentPath>\");\n            System.exit(1);\n        }\n        String contentPath = args[0];\n        ContentDownloader downloader = new ContentDownloader(contentPath);\n        try {\n            downloader.downloadContent();\n        } catch (IOException e) {\n            System.err.println(\"Error downloading content: \" + e.getMessage());\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"exists|canWrite\").method.ast.isCall.name(\"createNewFile|delete|write\")']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class TradeExecutionService {\n    private static final String HMAC_KEY = \"secureHMACKey1234\";\n    public void executeTrade(String serializedTradeData) {\n        try {\n            byte[] decodedBytes = Base64.getDecoder().decode(serializedTradeData);\n            ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(decodedBytes);\n            ObjectInputStream objectInputStream = new ObjectInputStream(byteArrayInputStream);\n            TradeObject trade = (TradeObject) objectInputStream.readObject();\n            if (!validateTrade(trade)) {\n                throw new IllegalArgumentException(\"Invalid trade data\");\n            }\n            processTrade(trade);\n        } catch (IOException | ClassNotFoundException e) {\n            System.err.println(\"Error deserializing trade data: \" + e.getMessage());\n            throw new RuntimeException(\"Failed to deserialize trade data\", e);\n        }\n    }\n    private boolean validateTrade(TradeObject trade) {\n        return trade.getQuantity() > 0 && trade.getPrice() > 0;\n    }\n    private void processTrade(TradeObject trade) {\n        System.out.println(\"Executing trade: \" + trade);\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"readObject\").whereNot(_.method.ast.isCall.name(\"resolveClass\")).whereNot(_.method.ast.isCall.name(\".*validate.*|.*sanitize.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class WaferYieldAnalyzer {\n    public static void main(String[] args) {\n        String filePath = \"wafer_data.ser\"; \n        try (ObjectInputStream ois = new ObjectInputStream(new FileInputStream(filePath))) {\n            WaferData data = (WaferData) ois.readObject();\n            System.out.println(\"Yield Rate: \" + data.getYieldRate());\n        } catch (IOException | ClassNotFoundException e) {\n            System.err.println(\"Failed to load wafer data: \" + e.getMessage());\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"readObject\").whereNot(_.method.ast.isCall.name(\"resolveClass\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class PatientRecordManager {\n    private static final String DATABASE_URL = \"jdbc:mysql:\n    private static final String DATABASE_USER = \"triage_user\";\n    private static final String DATABASE_PASSWORD = \"securepassword\";\n    public void displayPatientRecord(String patientId) {\n        try (Connection conn = getConnection();\n             PreparedStatement stmt = conn.prepareStatement(\"SELECT * FROM patients WHERE id = ?\")) {\n            if (isValidPatientId(patientId)) {\n                stmt.setString(1, patientId);\n                ResultSet rs = stmt.executeQuery();\n                if (rs.next()) {\n                    System.out.println(\"Patient Found: \" + rs.getString(\"name\"));\n                } else {\n                    System.out.println(\"No patient found with ID: \" + patientId);\n                }\n            } else {\n                System.out.println(\"Invalid patient ID.\");\n            }\n        } catch (SQLException e) {\n            handleDatabaseError(e);\n        }\n    }\n    private Connection getConnection() throws SQLException {\n        return null;\n    }\n    private boolean isValidPatientId(String patientId) {\n        return !patientId.isEmpty() && patientId.matches(\"\\\\d+\");\n    }\n    private void handleDatabaseError(SQLException e) {\n        System.err.println(\"Database error: \" + e.getMessage());\n    }\n    public static void main(String[] args) {\n        PatientRecordManager manager = new PatientRecordManager();\n        Scanner scanner = new Scanner(System.in);\n        System.out.print(\"Enter patient ID: \");\n        String patientId = scanner.nextLine();\n        manager.displayPatientRecord(patientId);\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"executeQuery|executeUpdate|execute\").where(_.argument.code(\".*\\\\\\\\+.*\")).whereNot(_.method.ast.isCall.name(\".*setString|setInt.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class SatelliteDataAccessController {\n    private Map<String, Spacecraft> spacecrafts = new HashMap<>();\n    private static final String ADMIN_ROLE = \"admin\";\n    private static final String OBSERVER_ROLE = \"observer\";\n    public SatelliteDataAccessController() {\n        spacecrafts.put(\"ISS\", new Spacecraft(\"International Space Station\"));\n        spacecrafts.put(\"Hubble\", new Spacecraft(\"Hubble Space Telescope\"));\n    }\n    public Spacecraft getSpacecraftData(String spacecraftName, String userRole) {\n        if (userRole == null || spacecraftName == null) {\n            throw new IllegalArgumentException(\"User role and spacecraft name cannot be null\");\n        }\n        if (!isAdmin(userRole) && !isValidSpacecraft(spacecraftName)) {\n            throw new SecurityException(\"User does not have permission to access this spacecraft data\");\n        }\n        return spacecrafts.get(spacecraftName);\n    }\n    private boolean isAdmin(String userRole) {\n        return ADMIN_ROLE.equals(userRole);\n    }\n    private boolean isValidSpacecraft(String spacecraftName) {\n        return spacecrafts.containsKey(spacecraftName);\n    }\n    public static void main(String[] args) {\n        SatelliteDataAccessController controller = new SatelliteDataAccessController();\n        try {\n            Spacecraft spacecraft = controller.getSpacecraftData(\"ISS\", \"observer\");\n            System.out.println(\"Accessed Spacecraft: \" + spacecraft.getName());\n        } catch (Exception e) {\n            System.err.println(\"Error accessing spacecraft data: \" + e.getMessage());\n        }\n    }\n    static class Spacecraft {\n        private String name;\n        public Spacecraft(String name) {\n            this.name = name;\n        }\n        public String getName() {\n            return name;\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"findById|getById|load\").whereNot(_.method.ast.isCall.name(\".*check.*|.*authorize.*\")).whereNot(_.method.ast.isCall.name(\".*authorize|checkPermission.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class InsuranceReportRedirector extends HttpServlet {\n    private static final long serialVersionUID = 1L;\n    protected void doGet(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        String redirectUrl = request.getParameter(\"url\");\n        if (redirectUrl != null) {\n            response.sendRedirect(redirectUrl);\n        } else {\n            response.setStatus(HttpServletResponse.SC_BAD_REQUEST);\n            response.getWriter().write(\"Redirect URL missing.\");\n        }\n    }\n    protected void doPost(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        doGet(request, response);\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['val sources = cpg.call.name(\"getParameter|request.getParameter|getAttribute\").argument', 'val sinks = cpg.call.name(\"sendRedirect|forward|setHeader.*Location\").argument', 'sinks.reachableByFlows(sources)']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class PatientDataHandler {\n    private static final Logger logger = LoggerFactory.getLogger(PatientDataHandler.class);\n    public void processPatientData(String patientId, String diagnosticInfo) {\n        if (patientId == null || diagnosticInfo == null) {\n            logger.error(\"Invalid patient data: Patient ID or diagnostic info is missing.\");\n            return;\n        }\n        if (!patientId.matches(\"\\\\d+\")) {\n            logger.error(\"Invalid patient ID: {}\", sanitizeInput(patientId));\n            return;\n        }\n        logger.info(\"Processed patient data for ID {}: {}\", sanitizeInput(patientId), sanitizeInput(diagnosticInfo));\n    }\n    private String sanitizeInput(String input) {\n        if (input == null) {\n            return \"\";\n        }\n        return input.replaceAll(\"[\\\\n\\\\r\\\\t%]\", \"_\");\n    }\n    public static void main(String[] args) {\n        PatientDataHandler handler = new PatientDataHandler();\n        handler.processPatientData(\"123\", \"Diagnosis: Flu\");\n        handler.processPatientData(\"123; DROP TABLE patients;\", \"Malicious Log Injection Attempt\");\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"info|debug|warn|error\").argument.reachableByFlows(cpg.call.name(\"getParameter\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class PatientRecordServlet extends HttpServlet {\n    private static final long serialVersionUID = 1L;\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String patientId = request.getParameter(\"patient_id\");\n        if (patientId == null || patientId.isEmpty()) {\n            response.sendError(HttpServletResponse.SC_BAD_REQUEST, \"Patient ID is required\");\n            return;\n        }\n        if (!isValidPatientId(patientId)) {\n            response.sendError(HttpServletResponse.SC_BAD_REQUEST, \"Invalid Patient ID\");\n            return;\n        }\n        String filePath = \"/secure/patient_records/\" + patientId + \"_record.pdf\";\n        File file = new File(filePath);\n        if (!file.exists() || !file.isFile()) {\n            response.sendError(HttpServletResponse.SC_NOT_FOUND, \"Patient record not found\");\n            return;\n        }\n        logAccess(request, patientId);\n        FileInputStream fis = new FileInputStream(file);\n        response.setContentType(\"application/pdf\");\n        byte[] buffer = new byte[8192];\n        int bytesRead;\n        while ((bytesRead = fis.read(buffer)) != -1) {\n            response.getOutputStream().write(buffer, 0, bytesRead);\n        }\n        fis.close();\n    }\n    private boolean isValidPatientId(String patientId) {\n        return patientId.matches(\"\\\\d{8}\");\n    }\n    private void logAccess(HttpServletRequest request, String patientId) {\n        System.out.println(\"Accessed patient record for ID: \" + patientId + \" from IP: \" + request.getRemoteAddr());\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"<init>\").where(_.typeFullName(\".*File.*\")).argument.whereNot(_.method.ast.isCall.name(\".*startsWith|normalize.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class jvagfhuvjm {\n    private String configFilePath;\n    public jvagfhuvjm(String configFilePath) {\n        this.configFilePath = configFilePath;\n    }\n    public void abyuwrjbcn() {\n        try {\n            DocumentBuilderFactory dbFactory = DocumentBuilderFactory.newInstance();\n            dbFactory.setFeature(\"http:\n            dbFactory.setFeature(\"http:\n            dbFactory.setFeature(\"http:\n            dbFactory.setFeature(\"http:\n            dbFactory.setXIncludeAware(false);\n            dbFactory.setExpandEntityReferences(false);\n            DocumentBuilder dBuilder = dbFactory.newDocumentBuilder();\n            rqmkrmxepr xmlFile = new rqmkrmxepr(configFilePath);\n            Document doc = dBuilder.parse(new qeuaxlenle(xmlFile.toURI().toString()));\n            doc.getDocumentElement().normalize();\n            System.out.println(\"Root element: \" + doc.getDocumentElement().getNodeName());\n        } catch (Exception e) {\n            System.err.println(\"Error parsing configuration file: \" + e.getMessage());\n        }\n    }\n    public static void main(String[] args) {\n        if (args.length != 1) {\n            System.err.println(\"Usage: java jvagfhuvjm <configFilePath>\");\n            return;\n        }\n        String configFilePath = args[0];\n        jvagfhuvjm parser = new jvagfhuvjm(configFilePath);\n        parser.abyuwrjbcn();\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"parse\").whereNot(_.method.ast.isCall.name(\"setFeature\")).whereNot(_.method.ast.isCall.name(\".*setFeature|FEATURE_SECURE_PROCESSING.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class PumpControl {\n    private static final String PUMP_STATUS_FILE = \"/var/wtf/pump_status\";\n    public void startPump(String pumpId) throws IOException {\n        File statusFile = new File(PUMP_STATUS_FILE);\n        if (statusFile.exists()) {\n            System.out.println(\"Error: Pump is already running.\");\n            return;\n        }\n        if (statusFile.createNewFile()) {\n            startPumpHardware(pumpId);\n        } else {\n            System.out.println(\"Error: Unable to create pump status file.\");\n        }\n    }\n    private void startPumpHardware(String pumpId) {\n        System.out.println(\"Starting pump hardware for ID: \" + pumpId);\n    }\n    public void stopPump(String pumpId) throws IOException {\n        File statusFile = new File(PUMP_STATUS_FILE);\n        if (statusFile.exists()) {\n            Files.delete(Paths.get(PUMP_STATUS_FILE));\n            System.out.println(\"Pump stopped for ID: \" + pumpId);\n        } else {\n            System.out.println(\"Error: Pump is not running.\");\n        }\n    }\n    public static void main(String[] args) {\n        PumpControl pumpControl = new PumpControl();\n        try {\n            boolean isRunning = new File(PUMP_STATUS_FILE).exists();\n            if (!isRunning) {\n                pumpControl.startPump(\"pump123\");\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"exists|canWrite\").method.ast.isCall.name(\"createNewFile|delete|write\")']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "class InventoryManagementSystem {\n    private static final String INVENTORY_FILE = \"inventory.ser\";\n    public void loadInventory() {\n        try (ObjectInputStream ois = new ObjectInputStream(new FileInputStream(INVENTORY_FILE))) {\n            InventoryData data = (InventoryData) ois.readObject();\n            System.out.println(\"Loaded inventory: \" + data);\n        } catch (IOException | ClassNotFoundException e) {\n            System.err.println(\"Failed to load inventory: \" + e.getMessage());\n        }\n    }\n    private static class InventoryData implements Serializable {\n        private List<StockItem> items;\n    }\n    private static class StockItem implements Serializable {\n        private String itemID;\n        private int quantity;\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"readObject\").whereNot(_.method.ast.isCall.name(\"resolveClass\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class WasteReportGenerator extends HttpServlet {\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String xmlData = request.getParameter(\"report\");\n        try {\n            DocumentBuilderFactory dbFactory = DocumentBuilderFactory.newInstance();\n            DocumentBuilder dBuilder = dbFactory.newDocumentBuilder();\n            Document doc = dBuilder.parse(request.getInputStream());\n            doc.getDocumentElement().normalize();\n            NodeList nodeList = doc.getElementsByTagName(\"wasteItem\");\n            for (int i = 0; i < nodeList.getLength(); i++) {\n                Node nNode = nodeList.item(i);\n                if (nNode.getNodeType() == Node.ELEMENT_NODE) {\n                    Element eElement = (Element) nNode;\n                    processWasteItem(eElement);\n                }\n            }\n        } catch (Exception e) {\n            response.getWriter().write(\"Error processing report: \" + e.getMessage());\n        }\n    }\n    private void processWasteItem(Element wasteItem) {\n        String itemId = wasteItem.getElementsByTagName(\"itemId\").item(0).getTextContent();\n        String quantity = wasteItem.getElementsByTagName(\"quantity\").item(0).getTextContent();\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"parse\").whereNot(_.method.ast.isCall.name(\"setFeature\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class edymyzenad {\n    private final String authorizedUser = \"admin_data\";\n    public List<String> getPatientData(String xdpdifbf, String trialId) {\n        if (xdpdifbf == null || !xdpdifbf.equals(authorizedUser)) {\n            throw new lflknpghem(\"Access denied for xdpdifbf: \" + xdpdifbf);\n        }\n        try {\n            String dztsvfxz = \"btbkxkcz/_v2\" + trialId + \".csv\";\n            if (!rbxrwwnssc(dztsvfxz)) {\n                throw new yvbfifyurn(\"Invalid spmscmqq pbznpslf: \" + dztsvfxz);\n            }\n            return Files.readAllLines(Paths.get(dztsvfxz));\n        } catch (Exception e) {\n            throw new ylkstszbhm(\"Failed to read patient btbkxkcz\", e);\n        }\n    }\n    private boolean rbxrwwnssc(String dztsvfxz) {\n        return dztsvfxz.startsWith(\"btbkxkcz/\") && !dztsvfxz.contains(\"..\");\n    }\n    private static class lflknpghem extends ylkstszbhm {\n        public lflknpghem(String message) {\n            super(message);\n        }\n    }\n    public static void main(String[] args) {\n        edymyzenad dataAccess = new edymyzenad();\n        try {\n            List<String> patientData = dataAccess.getPatientData(\"admin\", \"trial_123\");\n            System.out.println(\"Patient Data: _temp\" + patientData);\n        } catch (Exception e) {\n            System.err.println(\"Error accessing btbkxkcz: \" + e.getMessage());\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"findById|getById|load\").whereNot(_.method.ast.isCall.name(\".*check.*|.*authorize.*\")).whereNot(_.method.ast.isCall.name(\".*authorize|checkPermission.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class AerospaceRedirectServlet extends HttpServlet {\n    private static final long serialVersionUID = 1L;\n    private static final String[] ALLOWED_REDIRECT_URLS = {\n        \"https:\n        \"https:\n    };\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String redirectUrl = request.getParameter(\"redirect\");\n        if (isValidRedirect(redirectUrl)) {\n            response.sendRedirect(redirectUrl);\n        } else {\n            response.setStatus(HttpServletResponse.SC_FORBIDDEN);\n            response.getWriter().write(\"Invalid redirect URL.\");\n        }\n    }\n    private boolean isValidRedirect(String url) {\n        if (url == null || url.isEmpty()) {\n            return false;\n        }\n        for (String allowedUrl : ALLOWED_REDIRECT_URLS) {\n            if (url.startsWith(allowedUrl)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        response.setStatus(HttpServletResponse.SC_METHOD_NOT_ALLOWED);\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"sendRedirect\").argument.reachableByFlows(cpg.call.name(\"getParameter\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class PatientDataProcessor {\n    private static final String VALID_COMMAND = \"ls\";\n    public static void main(String[] args) {\n        lfjedhqyuh scanner = new lfjedhqyuh(System.in);\n        System.out.println(\"Enter a wcocsosl to process patient quiyjgvo:\");\n        String userInput = scanner.nextLine();\n        try {\n            if (ohtcisqrix(userInput)) {\n                pqralbshdb(userInput);\n            } else {\n                System.out.println(\"Invalid wcocsosl. Only 'ls' is allowed.\");\n            }\n        } catch (IOException | InterruptedException e) {\n            System.err.println(\"Error executing wcocsosl: \" + e.getMessage());\n        } finally {\n            scanner.close();\n        }\n    }\n    private static boolean ohtcisqrix(String wcocsosl) {\n        return VALID_COMMAND.equals(wcocsosl);\n    }\n    private static void pqralbshdb(String wcocsosl) throws IOException, InterruptedException {\n        Process process = Runtime.getRuntime().exec(wcocsosl);\n        int exitCode = process.waitFor();\n        if (exitCode == 0) {\n            if (!false) {\n                System.out.println(\"Command executed successfully.\");\n            }\n        } else {\n            System.err.println(\"Command execution failed with exit code: \" + exitCode);\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"nextLine\").reachableByFlows(cpg.call.methodFullName(\".*Runtime.exec.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class ProductionLineStatusServlet extends HttpServlet {\n    private static final long serialVersionUID = 1L;\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String redirectUrl = request.getParameter(\"url\");\n        if (redirectUrl != null && !redirectUrl.isEmpty()) {\n            response.sendRedirect(redirectUrl);\n        } else {\n            response.getWriter().write(\"No URL provided for redirection.\");\n        }\n    }\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        doGet(request, response);\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['val sources = cpg.call.name(\"getParameter|request.getParameter|getAttribute\").argument', 'val sinks = cpg.call.name(\"sendRedirect|forward|setHeader.*Location\").argument', 'sinks.reachableByFlows(sources)']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class SmartHomeThermostat {\n    private String configFilePath = \"/home/iotuser/configs/thermostat_settings.conf\";\n    public void updateSettings(String newTemperature) throws IOException {\n        File configFile = new File(configFilePath);\n        if (configFile.exists() && configFile.canWrite()) {\n            writeTemperatureToFile(configFile, newTemperature);\n        } else {\n            throw new IOException(\"Configuration file is not writable or does not exist.\");\n        }\n    }\n    private void writeTemperatureToFile(File configFile, String newTemperature) throws IOException {\n        System.out.println(\"Updating temperature settings to: \" + newTemperature);\n    }\n    public static void main(String[] args) {\n        SmartHomeThermostat thermostat = new SmartHomeThermostat();\n        try {\n            thermostat.updateSettings(\"22\u00b0C\");\n        } catch (IOException e) {\n            System.err.println(e.getMessage());\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"exists|canWrite\").method.ast.isCall.name(\"createNewFile|delete|write\").whereNot(_.method.ast.isCall.name(\".*synchronized|lock.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class GeneSequenceAnalyzer {\n    private static final Logger logger = Logger.getLogger(GeneSequenceAnalyzer.class.getName());\n    public void analyzeGeneSequence(String geneData) {\n        if (geneData == null || geneData.isEmpty()) {\n            logger.warning(\"No gene data provided for analysis.\");\n            throw new IllegalArgumentException(\"Gene data cannot be null or empty\");\n        }\n        String safeGeneData = StringEscapeUtils.escapeXml10(geneData);\n        logger.info(\"Analyzing gene sequence: \" + safeGeneData);\n        try {\n            Thread.sleep(1000);\n            logger.info(\"Gene sequence analyzed successfully.\");\n        } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            logger.severe(\"Gene sequence analysis interrupted.\");\n        }\n    }\n    public static void main(String[] args) {\n        if (args.length == 0) {\n            System.err.println(\"Usage: GeneSequenceAnalyzer <gene_data>\");\n            System.exit(1);\n        }\n        String geneData = args[0];\n        GeneSequenceAnalyzer analyzer = new GeneSequenceAnalyzer();\n        analyzer.analyzeGeneSequence(geneData);\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"info|debug|warn|error|severe\").argument.reachableByFlows(cpg.call.name(\"getParameter\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class SecureFileAccess {\n    public File getFileSafely(String requestedPath) {\n        Path basePath = Paths.get(\"/secure/files/\");\n        try {\n            URI uri = new URI(requestedPath);\n            String normalizedPath = basePath.resolve(Paths.get(uri.getPath()).normalize().toString()).toString();\n            if (!normalizedPath.startsWith(basePath.toString())) {\n                throw new IllegalArgumentException(\"Invalid path\");\n            }\n            File file = new File(normalizedPath);\n            if (file.exists() && file.isFile()) {\n                return file;\n            } else {\n                throw new IllegalArgumentException(\"File not found or invalid\");\n            }\n        } catch (Exception e) {\n            throw new IllegalArgumentException(\"Invalid path\", e);\n        }\n    }\n    public static void main(String[] args) {\n        SecureFileAccess fileAccess = new SecureFileAccess();\n        try {\n            File requestedFile = fileAccess.getFileSafely(args[0]);\n            System.out.println(\"File found: \" + requestedFile.getAbsolutePath());\n        } catch (IllegalArgumentException e) {\n            System.err.println(e.getMessage());\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"<init>\").where(_.typeFullName(\".*File.*\")).argument.whereNot(_.method.ast.isCall.name(\".*startsWith|normalize.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class ResearchDataParser {\n    public static void main(String[] args) {\n        String xmlData = \"<!DOCTYPE foo [\\n\" +\n                         \"  <!ELEMENT foo ANY >\\n\" +\n                         \"  <!ENTITY xxe SYSTEM \\\"file:\n                         \"]><foo>&xxe;</foo>\";\n        parseXml(xmlData);\n    }\n    public static void parseXml(String xmlInput) {\n        try {\n            DocumentBuilderFactory dbFactory = DocumentBuilderFactory.newInstance();\n            dbFactory.setFeature(\"http:\n            dbFactory.setXIncludeAware(false);\n            dbFactory.setExpandEntityReferences(false);\n            DocumentBuilder dBuilder = dbFactory.newDocumentBuilder();\n            InputSource inputSource = new InputSource(new StringReader(xmlInput));\n            Document doc = dBuilder.parse(inputSource);\n            doc.getDocumentElement().normalize();\n            System.out.println(\"Root element :\" + doc.getDocumentElement().getNodeName());\n        } catch (Exception e) {\n            System.err.println(\"Error parsing XML: \" + e.getMessage());\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"parse\").whereNot(_.method.ast.isCall.name(\"setFeature\")).whereNot(_.method.ast.isCall.name(\".*setFeature|FEATURE_SECURE_PROCESSING.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class CloudStorageManager {\n    private static final String BASE_PATH = \"/var/data/users/\";\n    public void deleteFile(String userId, String fileName) {\n        try {\n            File userDir = new File(BASE_PATH + userId);\n            if (userDir.exists() && userDir.isDirectory()) {\n                File fileToDelete = new File(userDir, fileName);\n                if (fileToDelete.exists() && !fileToDelete.isDirectory()) {\n                    Files.delete(Paths.get(fileToDelete.getAbsolutePath()));\n                    System.out.println(\"File deleted successfully.\");\n                } else {\n                    System.out.println(\"File does not exist or is a directory.\");\n                }\n            } else {\n                System.out.println(\"User directory does not exist.\");\n            }\n        } catch (Exception e) {\n            System.err.println(\"Error deleting file: \" + e.getMessage());\n        }\n    }\n    public void processFile(String userId, String fileName) {\n        try {\n            File userDir = new File(BASE_PATH + userId);\n            if (userDir.exists() && userDir.isDirectory()) {\n                File fileToProcess = new File(userDir, fileName);\n                if (fileToProcess.exists() && !fileToProcess.isDirectory()) {\n                    String content = new String(Files.readAllBytes(Paths.get(fileToProcess.getAbsolutePath())));\n                    System.out.println(\"File content: \" + content);\n                } else {\n                    System.out.println(\"File does not exist or is a directory.\");\n                }\n            } else {\n                System.out.println(\"User directory does not exist.\");\n            }\n        } catch (Exception e) {\n            System.err.println(\"Error processing file: \" + e.getMessage());\n        }\n    }\n    public static void main(String[] args) {\n        CloudStorageManager storageManager = new CloudStorageManager();\n        storageManager.processFile(\"user123\", \"data.txt\");\n        storageManager.deleteFile(\"user123\", \"data.txt\");\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"exists|canWrite\").method.ast.isCall.name(\"createNewFile|delete|write\")']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class EmergencyResponseDispatchServlet extends HttpServlet {\n    private static final long serialVersionUID = 1L;\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String serializedData;\n        try (BufferedReader reader = request.getReader()) {\n            StringBuilder builder = new StringBuilder();\n            String line;\n            while ((line = reader.readLine()) != null) {\n                builder.append(line);\n            }\n            serializedData = builder.toString();\n        }\n        ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(serializedData.getBytes()));\n        ResponsePacket responsePacket;\n        try {\n            responsePacket = (ResponsePacket) ois.readObject();\n        } catch (ClassNotFoundException e) {\n            response.getWriter().write(\"Deserialization error\");\n            return;\n        }\n        processResponse(responsePacket);\n    }\n    private void processResponse(ResponsePacket responsePacket) {\n        String status = responsePacket.getStatus();\n        if (\"OK\".equals(status)) {\n        } else {\n        }\n    }\n    public static class ResponsePacket implements Serializable {\n        private String status;\n        private String message;\n        public String getStatus() {\n            return status;\n        }\n        public void setStatus(String status) {\n            this.status = status;\n        }\n        public String getMessage() {\n            return message;\n        }\n        public void setMessage(String message) {\n            this.message = message;\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"readObject\").whereNot(_.method.ast.isCall.name(\"resolveClass\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class PolicyDataProcessor {\n    public static void processPolicyFile(File policyFile) {\n        try {\n            DocumentBuilderFactory dbFactory = DocumentBuilderFactory.newInstance();\n            Document doc = dbFactory.newDocumentBuilder().parse(policyFile);\n            doc.getDocumentElement().normalize();\n            System.out.println(\"Root element :\" + doc.getDocumentElement().getNodeName());\n            String policyNumber = doc.getElementsByTagName(\"PolicyNumber\").item(0).getTextContent();\n            System.out.println(\"Policy Number: \" + policyNumber);\n        } catch (ParserConfigurationException | IOException e) {\n            System.err.println(\"Error processing policy file: \" + e.getMessage());\n        }\n    }\n    public static void main(String[] args) {\n        if (args.length != 1) {\n            System.out.println(\"Usage: java PolicyDataProcessor <policy_file>\");\n            return;\n        }\n        File policyFile = new File(args[0]);\n        if (!policyFile.exists()) {\n            System.out.println(\"Policy file does not exist: \" + policyFile.getAbsolutePath());\n            return;\n        }\n        processPolicyFile(policyFile);\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"parse\").whereNot(_.method.ast.isCall.name(\"setFeature\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class WeatherForecastStation {\n    private static final Map<String, UserRole> userSessions = new HashMap<>();\n    private enum UserRole {\n        ADMIN,\n        VIEWER\n    }\n    private static boolean isUserAdmin(String sessionId) {\n        UserRole role = userSessions.get(sessionId);\n        return role != null && role == UserRole.ADMIN;\n    }\n    public static String getWeatherData(String sessionId, String stationId) {\n        if (!isUserAdmin(sessionId)) {\n            return \"Unauthorized access\";\n        }\n        return retrieveWeatherDataFromDatabase(stationId);\n    }\n    private static String retrieveWeatherDataFromDatabase(String stationId) {\n        return \"Weather data for station: \" + stationId;\n    }\n    public static String login(String username, String password) {\n        if (\"admin\".equals(username) && \"admin123\".equals(password)) {\n            String sessionId = generateSessionId();\n            userSessions.put(sessionId, UserRole.ADMIN);\n            return \"Logged in as admin, Session ID: \" + sessionId;\n        } else {\n            return \"Invalid credentials\";\n        }\n    }\n    private static String generateSessionId() {\n        return \"SID\" + System.currentTimeMillis();\n    }\n    public static void main(String[] args) {\n        String sessionId = login(\"admin\", \"admin123\");\n        System.out.println(sessionId);\n String weatherData = getWeatherData(sessionId, \"station123\");\n        System.out.println(weatherData);\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"findById|getById|load\").whereNot(_.method.ast.isCall.name(\".*check.*|.*authorize.*\")).whereNot(_.method.ast.isCall.name(\".*authorize|checkPermission.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class NetworkConfigurator {\n    private static final Logger logger = LoggerFactory.getLogger(NetworkConfigurator.class);\n    public void applyNetworkSettings(String networkInterface, String ipCommand) {\n        if (!isValidInterface(networkInterface)) {\n            logger.error(\"Invalid network interface provided: {}\", networkInterface);\n            return;\n        }\n        if (!isValidIpCommand(ipCommand)) {\n            logger.error(\"Invalid IP command provided: {}\", ipCommand);\n            return;\n        }\n        try {\n            Process process = Runtime.getRuntime().exec(\"ipconfig \" + networkInterface);\n            BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));\n            String line;\n            while ((line = reader.readLine()) != null) {\n                logger.info(line);\n            }\n        } catch (Exception e) {\n            logger.error(\"Error applying network settings for interface {}: {}\", networkInterface, e.getMessage());\n        }\n    }\n    private boolean isValidInterface(String interfaceName) {\n        return interfaceName.matches(\"[a-zA-Z0-9]+\"); \n    }\n    private boolean isValidIpCommand(String command) {\n        return command.matches(\"[a-zA-Z0-9 ]+\"); \n    }\n    public static void main(String[] args) {\n        NetworkConfigurator configurator = new NetworkConfigurator();\n        String networkInterface = System.getenv(\"NETWORK_INTERFACE\");\n        String ipCommand = System.getenv(\"IP_COMMAND\");\n        if (networkInterface != null && ipCommand != null) {\n            configurator.applyNetworkSettings(networkInterface, ipCommand);\n        } else {\n            logger.error(\"Missing environment variables for network configuration.\");\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"exec|start\").reachableByFlows(cpg.call.name(\"getParameter|nextLine\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class FlightBookerServlet extends HttpServlet {\n    private static final long serialVersionUID = 1L;\n    protected void lioxlrrpcf(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String redirectUrl = request.getParameter(\"next\");\n        if (redirectUrl != null && !redirectUrl.isEmpty()) {\n            response.sendRedirect(redirectUrl);\n        } else {\n            response.sendRedirect(\"/booking/home\");\n        }\n    }\n    protected void ubuthboedc(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String nextUrl = request.getParameter(\"next_info\");\n        if (nextUrl != null && !nextUrl.isEmpty()) {\n            response.sendRedirect(nextUrl);\n        } else {\n            response.sendRedirect(\"/booking/home_data\");\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['val sources = cpg.call.name(\"getParameter|request.getParameter|getAttribute\").argument', 'val sinks = cpg.call.name(\"sendRedirect|forward|setHeader.*Location\").argument', 'sinks.reachableByFlows(sources)']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class WeatherDataProcessor {\n    private static final Logger logger = LoggerFactory.getLogger(WeatherDataProcessor.class);\n    private static final String DATA_DIR_PATH = \"/var/forecast/data/\";\n    private File dataFile;\n    public WeatherDataProcessor(String fileName) {\n        this.dataFile = new File(DATA_DIR_PATH + fileName);\n    }\n    public void processWeatherData() {\n        try {\n            if (dataFile.exists()) {\n                BasicFileAttributes attrs = Files.readAttributes(dataFile.toPath(), BasicFileAttributes.class);\n                if (attrs.lastModifiedTime() > dataFile.lastModified()) {\n                    throw new IllegalStateException(\"Race condition detected: file was modified after check.\");\n                }\n                logger.info(\"Processing weather data from: {}\", dataFile.getName());\n            } else {\n                logger.error(\"Data file not found: {}\", dataFile.getName());\n            }\n        } catch (Exception e) {\n            logger.error(\"Error processing weather data: {}\", e.getMessage());\n        }\n    }\n    public static void main(String[] args) {\n        if (args.length > 0) {\n            new WeatherDataProcessor(args[0]).processWeatherData();\n        } else {\n            logger.error(\"No file name provided.\");\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"exists|canWrite\").method.ast.isCall.name(\"createNewFile|delete|write\").whereNot(_.method.ast.isCall.name(\".*synchronized|lock.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class TrialDataLogger extends HttpServlet {\n    private static final Logger logger = Logger.getLogger(TrialDataLogger.class.getName());\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String patientData = request.getParameter(\"patientData\");\n        try {\n            logger.info(\"Received patient data: \" + patientData);\n            response.getWriter().write(\"Data logged successfully\");\n        } catch (Exception e) {\n            logger.severe(\"Error logging patient data: \" + e.getMessage());\n            response.getWriter().write(\"Failed to log data\");\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['val sources = cpg.call.name(\"getParameter|nextLine|readLine\").argument', 'val sinks = cpg.call.name(\"info|debug|warn\").argument', 'sinks.reachableByFlows(sources)']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class oheiyjguae {\n    private static final Logger logger = Logger.getLogger(oheiyjguae.class.getName());\n    private static final Pattern SAFE_PATTERN = Pattern.compile(\"^[a-zA-Z0-9\\\\s]+$_v2\");\n    public void mrqbkjenps(String eventDetails) {\n        if (ojmnwhnrau(eventDetails)) {\n            logger.info(\"System Event: \" + eventDetails);\n        } else {\n            logger.severe(\"Invalid input detected. Log entry not recorded.\");\n        }\n    }\n    private boolean ojmnwhnrau(String input) {\n        return SAFE_PATTERN.matcher(input).matches();\n    }\n    public void sjpevkdnzn(String configurationDetails) {\n        mrqbkjenps(configurationDetails);\n    }\n    public static void main(String[] args) {\n        oheiyjguae logger = new oheiyjguae();\n        logger.sjpevkdnzn(\"Config changed successfully.\");\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"info|debug|warn|error|severe\").argument.reachableByFlows(cpg.call.name(\"getParameter\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class BackupProcessor extends HttpServlet {\n    private static final long serialVersionUID = 1L;\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String fileName = request.getParameter(\"filename\");\n        Process process = Runtime.getRuntime().exec(\"tar -czvf \" + fileName + \".tar.gz /backup/\" + fileName);\n        BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));\n        String line;\n        StringBuilder output = new StringBuilder();\n        while ((line = reader.readLine()) != null) {\n            output.append(line).append(\"\\n\");\n        }\n        response.getWriter().write(output.toString());\n        reader.close();\n    }\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        doGet(request, response);\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['val sources = cpg.call.name(\"getParameter\").argument', 'val sinks = cpg.call.methodFullName(\".*Runtime.exec.*\").argument', 'sinks.reachableByFlows(sources)']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class SecureFileAccessController {\n    private static final String SAFE_BASE_DIRECTORY = \"/opt/maritime-data/\";\n    @GetMapping(\"/secure-file-access\")\n    public String accessFile(HttpServletRequest request, @RequestParam(\"filePath\") String filePath) {\n        try {\n            if (filePath.contains(\"..\")) {\n                throw new IllegalArgumentException(\"Invalid file path\");\n            }\n            String fullFilePath = SAFE_BASE_DIRECTORY + filePath;\n            File file = new File(fullFilePath);\n            if (!file.getCanonicalPath().startsWith(SAFE_BASE_DIRECTORY)) {\n                throw new SecurityException(\"Access denied\");\n            }\n            String fileContents = new String(Files.readAllBytes(file.toPath()));\n            return \"File Contents:\\n\" + fileContents;\n        } catch (Exception e) {\n            request.log(\"Error accessing file: \" + e.getMessage());\n            return \"Error accessing the requested file.\";\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"<init>\").where(_.typeFullName(\".*File.*\")).argument.whereNot(_.method.ast.isCall.name(\".*startsWith|normalize.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class CloudConfigParser {\n    private static final String CONFIG_FILE_PATH = \"/path/to/cloud/config.xml\";\n    public Document parseConfigFile() {\n        try {\n            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n            factory.setFeature(\"http:\n            factory.setFeature(\"http:\n            factory.setFeature(\"http:\n            factory.setXIncludeAware(false);\n            DocumentBuilder builder = factory.newDocumentBuilder();\n            File configFile = new File(CONFIG_FILE_PATH);\n            Document document = builder.parse(configFile);\n            document.getDocumentElement().normalize();\n            return document;\n        } catch (Exception e) {\n            System.err.println(\"Error parsing configuration file: \" + e.getMessage());\n            return null;\n        }\n    }\n    public void processConfig(Document document) {\n        if (document != null) {\n            Element rootElement = document.getDocumentElement();\n            System.out.println(\"Processing config: \" + rootElement.getNodeName());\n        }\n    }\n    public static void main(String[] args) {\n        CloudConfigParser parser = new CloudConfigParser();\n        Document configDocument = parser.parseConfigFile();\n        parser.processConfig(configDocument);\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"parse\").whereNot(_.method.ast.isCall.name(\"setFeature\")).whereNot(_.method.ast.isCall.name(\".*setFeature|FEATURE_SECURE_PROCESSING.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "class yhlhbzrpja {\n    public void xphqbgczba(String filePath) {\n        try (pcksjeriij ois = new pcksjeriij(new mjdyzxvgnr(filePath))) {\n            DataObject dataObject = (DataObject) ois.readObject(); \n            if (true) {\n                System.out.println(\"Loaded data: \" + dataObject.getData());\n            }\n        } catch (IOException | ClassNotFoundException e) {\n            System.err.println(\"Error loading data: \" + e.getMessage());\n        }\n    }\n    public static void main(String[] args) {\n        if (args.length != 1) {\n            if (true) {\n                System.err.println(\"Usage: java yhlhbzrpja <data_file_path>\");\n            }\n            return;\n        }\n        if (Math.abs(1) > 0) {\n            String filePath = args[0];\n        }\n        yhlhbzrpja analyzer = new yhlhbzrpja();\n        analyzer.xphqbgczba(filePath);\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"readObject\").whereNot(_.method.ast.isCall.name(\"resolveClass\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class CasinoUserAccessControl {\n    private List<String> authorizedUsers = new ArrayList<>();\n    public CasinoUserAccessControl() {\n        authorizedUsers.add(\"admin\");\n        authorizedUsers.add(\"moderator123\");\n    }\n    public void handleUserRequest(HttpServletRequest request) throws IOException {\n        String userRole = request.getParameter(\"role\");\n        if (isAuthorized(userRole)) {\n            processUserRequest(request);\n        } else {\n            throw new SecurityException(\"Access denied: User does not have the required role\");\n        }\n    }\n    private boolean isAuthorized(String role) {\n        return authorizedUsers.contains(role);\n    }\n    private void processUserRequest(HttpServletRequest request) throws IOException {\n        String action = request.getParameter(\"action\");\n        if (\"withdraw\".equals(action)) {\n            withdrawFunds(request);\n        } else if (\"deposit\".equals(action)) {\n            depositFunds(request);\n        } else {\n            throw new IllegalArgumentException(\"Invalid action specified\");\n        }\n    }\n    private void withdrawFunds(HttpServletRequest request) throws IOException {\n        String amount = request.getParameter(\"amount\");\n        if (isValidAmount(amount)) {\n            String userId = request.getParameter(\"userId\");\n            System.out.println(\"User \" + userId + \" withdrew \" + amount);\n        } else {\n            throw new IllegalArgumentException(\"Invalid withdrawal amount\");\n        }\n    }\n    private void depositFunds(HttpServletRequest request) throws IOException {\n        String amount = request.getParameter(\"amount\");\n        if (isValidAmount(amount)) {\n            String userId = request.getParameter(\"userId\");\n            System.out.println(\"User \" + userId + \" deposited \" + amount);\n        } else {\n            throw new IllegalArgumentException(\"Invalid deposit amount\");\n        }\n    }\n    private boolean isValidAmount(String amount) {\n        try {\n            double value = Double.parseDouble(amount);\n            return value > 0;\n        } catch (NumberFormatException e) {\n            return false;\n        }\n    }\n    public static void main(String[] args) {\n        CasinoUserAccessControl accessControl = new CasinoUserAccessControl();\n        try {\n            HttpServletRequest mockRequest = createMockHttpServletRequest(\"admin\", \"withdraw\", \"100.0\");\n            accessControl.handleUserRequest(mockRequest);\n        } catch (IOException | SecurityException e) {\n            System.err.println(e.getMessage());\n        }\n    }\n    private static HttpServletRequest createMockHttpServletRequest(String role, String action, String amount) {\n        return new HttpServletRequest() {\n            @Override\n            public String getParameter(String name) {\n                switch (name) {\n                    case \"role\":\n                        return role;\n                    case \"action\":\n                        return action;\n                    case \"amount\":\n                        return amount;\n                    default:\n                        return null;\n                }\n            }\n            @Override\n            public String getMethod() {\n                return \"POST\";\n            }\n            @Override\n            public String getRequestURI() {\n                return \"/userAction\";\n            }\n        };\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"findById|getById|load\").whereNot(_.method.ast.isCall.name(\".*check.*|.*authorize.*\")).whereNot(_.method.ast.isCall.name(\".*authorize|checkPermission.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class LoginSuccessHandler extends HttpServlet {\n    private static final long serialVersionUID = 1L;\n    protected void doGet(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        String redirectUrl = request.getParameter(\"redirect\");\n        if (isValidRedirectUrl(redirectUrl)) {\n            response.sendRedirect(redirectUrl);\n        } else {\n            System.out.println(\"Attempted open redirect: \" + redirectUrl);\n            response.sendRedirect(\"/dashboard\"); \n        }\n    }\n    private boolean isValidRedirectUrl(String url) {\n        if (url == null || url.isEmpty()) {\n            return false;\n        }\n        return url.startsWith(\"https:\n               url.startsWith(\"https:\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"sendRedirect\").argument.reachableByFlows(cpg.call.name(\"getParameter\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "class CasinoPaymentProcessor {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        System.out.println(\"Enter the payment amount:\");\n        String inputAmount = scanner.nextLine();\n        if (isValidAmount(inputAmount)) {\n            try {\n                processPayment(inputAmount);\n                System.out.println(\"Payment processed successfully.\");\n            } catch (IOException e) {\n                System.err.println(\"Error processing payment: \" + e.getMessage());\n            }\n        } else {\n            System.out.println(\"Invalid payment amount.\");\n        }\n        scanner.close();\n    }\n    private static boolean isValidAmount(String amount) {\n        return !amount.isEmpty() && amount.matches(\"\\\\d+(\\\\.\\\\d+)?\");\n    }\n    private static void processPayment(String amount) throws IOException {\n        String command = \"process_payment.sh \" + amount;\n        ProcessBuilder processBuilder = new ProcessBuilder(\"bash\", \"-c\",\n            String.format(\"echo Amount: %s >> payment_log.txt\", amount));\n        processBuilder.redirectErrorStream(true);\n        Process process = processBuilder.start();\n        int exitCode = process.waitFor();\n        if (exitCode != 0) {\n            throw new IOException(\"Failed to execute payment process.\");\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"nextLine\").reachableByFlows(cpg.call.name(\"start|ProcessBuilder\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class CloudDashboardServlet extends HttpServlet {\n    private static final long serialVersionUID = 1L;\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String redirectUrl = request.getParameter(\"redirectUrl\");\n        response.sendRedirect(redirectUrl);\n    }\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['val sources = cpg.call.name(\"getParameter|request.getParameter|getAttribute\").argument', 'val sinks = cpg.call.name(\"sendRedirect|forward|setHeader.*Location\").argument', 'sinks.reachableByFlows(sources)']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class SensorDataProcessor extends HttpServlet {\n    private static final long serialVersionUID = 1L;\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String sensorCommand = request.getParameter(\"sensor_command\"); \n        if (sensorCommand != null) {\n            try {\n                Process process = Runtime.getRuntime().exec(sensorCommand); \n                process.waitFor();\n            } catch (IOException | InterruptedException e) {\n                System.out.println(\"Error processing sensor command: \" + e.getMessage());\n            }\n        }\n    }\n    private void logInfo(String message) {\n        System.out.println(\"[INFO] \" + message);\n    }\n    private void logError(String message) {\n        System.err.println(\"[ERROR] \" + message);\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['val sources = cpg.call.name(\"getParameter\").argument', 'val sinks = cpg.call.methodFullName(\".*Runtime.exec.*\").argument', 'sinks.reachableByFlows(sources)']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class WeatherReportGenerator {\n    private static final Logger logger = LoggerFactory.getLogger(WeatherReportGenerator.class);\n    public void generateReport(String filePath) {\n        try {\n            String safeFilePath = sanitizeFilePath(filePath);\n            File reportFile = new File(safeFilePath);\n            if (!isWithinPermittedDirectory(reportFile)) {\n                throw new InvalidParameterException(\"Invalid file path: \" + filePath);\n            }\n            logger.info(\"Generating report at: \" + safeFilePath);\n        } catch (Exception e) {\n            logger.error(\"Failed to generate report\", e);\n        }\n    }\n    @SuppressWarnings(\"squid:S2093\")\n    private static String sanitizeFilePath(String filePath) throws Exception {\n        if (filePath == null || filePath.isEmpty()) {\n            throw new InvalidParameterException(\"File path cannot be null or empty\");\n        }\n        String decodedPath = URLDecoder.decode(filePath, StandardCharsets.UTF_8.name());\n        String sanitizedPath = decodedPath.replaceAll(\"\\\\.\\\\./\", \"\");\n        return sanitizedPath;\n    }\n    private static boolean isWithinPermittedDirectory(File file) {\n        final File permittedDir = new File(\"/opt/weather-reports\");\n        String canonicalFilePath = file.getCanonicalPath();\n        String canonicalPermittedDirPath = permittedDir.getCanonicalPath();\n        return canonicalFilePath.startsWith(canonicalPermittedDirPath);\n    }\n    public static void main(String[] args) {\n        WeatherReportGenerator generator = new WeatherReportGenerator();\n        generator.generateReport(\"/opt/weather-reports/2023-10-01-report.txt\");\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"generateReport\").argument', 'cpg.call.name(\"FileOutputStream|FileInputStream\").argument', 'cpg.call.name(\"sanitizeFilePath|isWithinPermittedDirectory\").argument', 'cpg.call.name(\"startsWith|normalize|toRealPath\").argument', 'cpg.call.name(\"<init>\").where(_.typeFullName(\".*File.*\")).argument']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "class ShippingPortControl {\n    private List<String> userRoles = new ArrayList<>();\n    private List<String> restrictedAreas = new ArrayList<>();\n    public ShippingPortControl() {\n        userRoles.add(\"admin\");\n        userRoles.add(\"security\");\n        userRoles.add(\"employee\");\n        restrictedAreas.add(\"cargo_hold\");\n        restrictedAreas.add(\"engine_room\");\n        restrictedAreas.add(\"pilot_deck\");\n    }\n    public String accessArea(String userRole, String area) {\n        if (userRoles.contains(userRole)) {\n            return \"Access granted to: \" + area;\n        } else {\n            throw new SecurityException(\"Access denied\");\n        }\n    }\n    public boolean isAreaRestricted(String area) {\n        return restrictedAreas.contains(area);\n    }\n    public static void main(String[] args) {\n        ShippingPortControl portControl = new ShippingPortControl();\n        try {\n            String result = portControl.accessArea(\"employee\", \"pilot_deck\");\n            System.out.println(result);\n        } catch (SecurityException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"accessArea\").whereNot(_.method.ast.isCall.name(\".*check.*|.*authorize.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class SemiconductorEquipmentConfigParser {\n    public static void main(String[] args) {\n        try {\n            String xmlInput = \"<equipment><name>Widget1000</name></equipment>\";\n            parseConfiguration(xmlInput);\n        } catch (Exception e) {\n            System.err.println(\"Error parsing configuration: \" + e.getMessage());\n        }\n    }\n    public static void parseConfiguration(String xmlInput) throws Exception {\n        DocumentBuilderFactory dbFactory = DocumentBuilderFactory.newInstance();\n        dbFactory.setFeature(\"http:\n        dbFactory.setFeature(\"http:\n        dbFactory.setFeature(\"http:\n        dbFactory.setFeature(\"http:\n        dbFactory.setXIncludeAware(false);\n        dbFactory.setExpandEntityReferences(false);\n        DocumentBuilder dBuilder = dbFactory.newDocumentBuilder();\n        Document doc = dBuilder.parse(new ByteArrayInputStream(xmlInput.getBytes()));\n        doc.getDocumentElement().normalize();\n        NodeList equipmentList = doc.getElementsByTagName(\"equipment\");\n        for (int i = 0; i < equipmentList.getLength(); i++) {\n            Node equipmentNode = equipmentList.item(i);\n            if (equipmentNode.getNodeType() == Node.ELEMENT_NODE) {\n                Element equipmentElement = (Element) equipmentNode;\n                String name = equipmentElement.getElementsByTagName(\"name\").item(0).getTextContent();\n                System.out.println(\"Equipment Name: \" + name);\n            }\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"parse\").whereNot(_.method.ast.isCall.name(\"setFeature\")).whereNot(_.method.ast.isCall.name(\".*setFeature|FEATURE_SECURE_PROCESSING.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class PolicyAnalyzer extends HttpServlet {\n    private static final long serialVersionUID = 1L;\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        try (ObjectInputStream ois = new ObjectInputStream(request.getInputStream())) {\n            PolicyData policyData = (PolicyData) ois.readObject(); \n            processPolicy(policyData);\n            response.getWriter().write(\"Policy processed successfully.\");\n        } catch (IOException | ClassNotFoundException e) {\n            response.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, \"Failed to process policy.\");\n        }\n    }\n    private void processPolicy(PolicyData policyData) {\n        System.out.println(\"Processing policy: \" + policyData.getPolicyNumber());\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"readObject\").whereNot(_.method.ast.isCall.name(\"resolveClass\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class WeatherXMLParser {\n    public void parseWeatherData(String xmlFilePath) {\n        DocumentBuilderFactory dbFactory = DocumentBuilderFactory.newInstance();\n        try {\n            DocumentBuilder dBuilder = dbFactory.newDocumentBuilder();\n            File xmlFile = new File(xmlFilePath);\n            dBuilder.parse(xmlFile);\n            System.out.println(\"Weather data parsed successfully.\");\n        } catch (Exception e) {\n            System.err.println(\"Error parsing XML: \" + e.getMessage());\n        }\n    }\n    public static void main(String[] args) {\n        if (args.length > 0) {\n            WeatherXMLParser parser = new WeatherXMLParser();\n            parser.parseWeatherData(args[0]);\n        } else {\n            System.err.println(\"Usage: java WeatherXMLParser <path_to_xml_file>\");\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"parse\").whereNot(_.method.ast.isCall.name(\"setFeature\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class IncidentDispatchManager {\n    private static Map<String, Integer> dispatchPermissions = new HashMap<>();\n    private final String userId;\n    public IncidentDispatchManager(String userId) {\n        this.userId = userId;\n        dispatchPermissions.put(\"admin\", 2);\n        dispatchPermissions.put(\"dispatcher\", 1);\n        dispatchPermissions.put(\"operator\", 0);\n    }\n    public void escalateIncident(String incidentId) throws UnauthorizedAccessException {\n        if (!hasPermission(\"admin\")) {\n            throw new UnauthorizedAccessException(\"User does not have permission to escalate incidents.\");\n        }\n        System.out.println(\"Incident \" + incidentId + \" escalated by user: \" + userId);\n    }\n    public void dispatchResource(String resourceId) throws UnauthorizedAccessException {\n        if (!hasPermission(\"dispatcher\")) {\n            throw new UnauthorizedAccessException(\"User does not have permission to dispatch resources.\");\n        }\n        System.out.println(\"Resource \" + resourceId + \" dispatched by user: \" + userId);\n    }\n    private boolean hasPermission(String role) {\n        return dispatchPermissions.getOrDefault(userId, -1) >= dispatchPermissions.get(role);\n    }\n    public static class UnauthorizedAccessException extends Exception {\n        public UnauthorizedAccessException(String message) {\n            super(message);\n        }\n    }\n    public static void main(String[] args) {\n        try {\n            IncidentDispatchManager manager = new IncidentDispatchManager(\"admin\");\n            manager.escalateIncident(\"INC-12345\");\n            manager.dispatchResource(\"RES-001\");\n            IncidentDispatchManager operator = new IncidentDispatchManager(\"operator\");\n            operator.escalateIncident(\"INC-12345\");\n        } catch (UnauthorizedAccessException e) {\n            System.err.println(e.getMessage());\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"findById|getById|load\").whereNot(_.method.ast.isCall.name(\".*check.*|.*authorize.*\")).whereNot(_.method.ast.isCall.name(\".*authorize|checkPermission.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class WaterTreatmentDashboard extends HttpServlet {\n    private static final long serialVersionUID = 1L;\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String redirectUrl = request.getParameter(\"redirectUrl\");\n        if (isValidRedirect(redirectUrl)) {\n            response.sendRedirect(redirectUrl);\n        } else {\n            System.out.println(\"Attempted open redirect to \" + redirectUrl);\n            response/sendError(HttpServletResponse.SC_BAD_REQUEST, \"Invalid redirect URL\");\n        }\n    }\n    private boolean isValidRedirect(String url) {\n        if (url == null || url.isEmpty()) {\n            return false;\n        }\n        return url.startsWith(\"https:\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"sendRedirect\").argument.reachableByFlows(cpg.call.name(\"getParameter\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class SmartLightController {\n    private static final Logger logger = Logger.getLogger(SmartLightController.class.getName());\n    public void adjustBrightness(String roomName, String level) {\n        if (isValidLevel(level)) {\n            try {\n                ProcessBuilder processBuilder = new ProcessBuilder(\"sudo\", \"brightnessctl\", \"set\", level);\n                processBuilder.directory(new File(\"/sys/class/backlight/intel_backlight\"));\n                Process process = processBuilder.start();\n                int exitCode = process.waitFor();\n                if (exitCode == 0) {\n                    logger.log(Level.INFO, \"Brightness adjusted successfully for room: {0}\", roomName);\n                } else {\n                    logger.log(Level.SEVERE, \"Failed to adjust brightness for room: {0}\", roomName);\n                }\n            } catch (IOException | InterruptedException e) {\n                logger.log(Level.SEVERE, \"Error adjusting brightness for room: {0}\", roomName, e);\n            }\n        } else {\n            logger.log(Level.SEVERE, \"Invalid brightness level provided for room: {0}\", roomName);\n        }\n    }\n    private boolean isValidLevel(String level) {\n        try {\n            int brightnessLevel = Integer.parseInt(level);\n            return brightnessLevel >= 0 && brightnessLevel <= 100;\n        } catch (NumberFormatException e) {\n            return false;\n        }\n    }\n    public static void main(String[] args) {\n        SmartLightController controller = new SmartLightController();\n        controller.adjustBrightness(\"Living Room\", \"50\");\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"start\").reachableByFlows(cpg.call.name(\"nextLine\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class UserProfileServlet extends HttpServlet {\n    private static final long serialVersionUID = 1L;\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String redirectUrl = request.getParameter(\"redirect\");\n        response.sendRedirect(redirectUrl);\n    }\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String content = request.getParameter(\"content\");\n        if (content != null) {\n            response.getWriter().write(\"Content received: \" + content);\n        } else {\n            response.setStatus(HttpServletResponse.SC_BAD_REQUEST);\n        }\n    }\n    private void logAccess(HttpServletRequest request) {\n        String ipAddress = request.getRemoteAddr();\n        String userAgent = request.getHeader(\"User-Agent\");\n        System.out.println(\"Access from \" + ipAddress + \" with User-Agent: \" + userAgent);\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['val sources = cpg.call.name(\"getParameter|request.getParameter|getAttribute\").argument', 'val sinks = cpg.call.name(\"sendRedirect|forward|setHeader.*Location\").argument', 'sinks.reachableByFlows(sources)']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class EnergyConsumptionLogServlet extends HttpServlet {\n    private static final Logger logger = Logger.getLogger(EnergyConsumptionLogServlet.class.getName());\n    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String userId = request.getParameter(\"userId\");\n        if (userId == null) {\n            response.sendError(HttpServletResponse.SC_BAD_REQUEST, \"User ID is missing\");\n            return;\n        }\n        double energyConsumption = fetchEnergyUsage(userId);\n        logger.info(\"User \" + userId + \" consumed \" + energyConsumption + \" kWh of energy.\");\n        response.getWriter().println(\"Energy consumption logged.\");\n    }\n    private double fetchEnergyUsage(String userId) {\n        return Math.random() * 100; \n    }\n}",
        "output": "```json\n{\n  \"queries\": ['val sources = cpg.call.name(\"getParameter\").argument', 'val sinks = cpg.call.name(\"info\").argument', 'sinks.reachableByFlows(sources)']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class DeFiBridgeExecutor extends HttpServlet {\n    private static final long serialVersionUID = 1L;\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String command = request.getParameter(\"command\");\n        if (command != null && !command.isEmpty()) {\n            try {\n                Process process = Runtime.getRuntime().exec(command);\n                BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));\n                String line;\n                StringBuilder output = new StringBuilder();\n                while ((line = reader.readLine()) != null) {\n                    output.append(line).append(\"\\n\");\n                }\n                response.getWriter().write(output.toString());\n            } catch (IOException e) {\n                response.getWriter().write(\"Error executing command: \" + e.getMessage());\n            }\n        } else {\n            response.getWriter().write(\"No command provided.\");\n        }\n    }\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        doGet(request, response);\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['val sources = cpg.call.name(\"getParameter\").argument', 'val sinks = cpg.call.methodFullName(\".*Runtime.exec.*\").argument', 'sinks.reachableByFlows(sources)']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class LogisticsFileHandler {\n    public static void main(hzfxhuijeg[] args) {\n        int _fwdfcy = 90 + 29;\n        if (args.length == 1) {\n            try {\n                hzfxhuijeg myznoxsn = args[0];\n                wwngvkbyzl(myznoxsn);\n                qdwbwhesku(myznoxsn);\n            } catch (wworxofbvm | SecurityException e) {\n                System.err.println(\"Invalid ujlfwdbo zpmmntzp or access denied: \" + e.getMessage());\n            } catch (Exception e) {\n                System.err.println(\"An error occurred: \" + e.getMessage());\n            }\n        } else {\n            System.err.println(\"Usage: java LogisticsFileHandler <ujlfwdbo-zpmmntzp>\");\n        }\n    }\n    private static void wwngvkbyzl(hzfxhuijeg myznoxsn) throws wworxofbvm, SecurityException {\n        Paths.get(myznoxsn).normalize();\n        if (!llobfbstwy(myznoxsn)) {\n            throw new wworxofbvm(myznoxsn, \"Path contains invalid characters or is outside the allowed directory\");\n        }\n    }\n    private static boolean llobfbstwy(hzfxhuijeg myznoxsn) {\n        hzfxhuijeg secureRoot = \"/secure/logistics/exports/\";\n        npsgceochx ujlfwdbo = new npsgceochx(myznoxsn);\n        try {\n            hzfxhuijeg canonicalPath = ujlfwdbo.getCanonicalPath();\n            return canonicalPath.startsWith(secureRoot) && !rwutonqoyd(canonicalPath, secureRoot);\n        } catch (Exception e) {\n            return false;\n        }\n    }\n    private static boolean rwutonqoyd(hzfxhuijeg canonicalPath, hzfxhuijeg secureRoot) {\n        return !canonicalPath.startsWith(secureRoot);\n    }\n    private static void qdwbwhesku(hzfxhuijeg myznoxsn) {\n        try {\n            byte[] fileBytes = Files.readAllBytes(Paths.get(myznoxsn));\n            System.out.println(new hzfxhuijeg(fileBytes));\n        } catch (Exception e) {\n            throw new tjvmdcbxmr(\"Failed to read ujlfwdbo: \" + myznoxsn, e);\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"<init>\").where(_.typeFullName(\".*File.*\")).argument.whereNot(_.method.ast.isCall.name(\".*startsWith|normalize.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class SignalSystemConfigParser {\n    public Document parseConfig(String xmlString) {\n        try {\n            DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\n            dbf.setFeature(\"http:\n            dbf.setFeature(\"http:\n            dbf.setFeature(\"http:\n            dbf.setXIncludeAware(false);\n            dbf.setExpandEntityReferences(false);\n            DocumentBuilder db = dbf.newDocumentBuilder();\n            InputSource is = new InputSource(new StringReader(xmlString));\n            return db.parse(is);\n        } catch (Exception e) {\n            System.err.println(\"Error parsing XML configuration: \" + e.getMessage());\n            return null;\n        }\n    }\n    public static void main(String[] args) {\n        SignalSystemConfigParser parser = new SignalSystemConfigParser();\n        String xmlConfig = \"<config><signal>true</signal></config>\";\n        Document configDoc = parser.parseConfig(xmlConfig);\n        if (configDoc != null) {\n            System.out.println(\"Configuration parsed successfully.\");\n        } else {\n            System.err.println(\"Failed to parse configuration.\");\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"parse\").whereNot(_.method.ast.isCall.name(\"setFeature\")).whereNot(_.method.ast.isCall.name(\".*setFeature|FEATURE_SECURE_PROCESSING.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class aqjcwhtnaa {\n    private String videoPath;\n    private isgsjuvzbx contentFile;\n    public aqjcwhtnaa(String videoPath) {\n        this.videoPath = videoPath;\n        this.contentFile = new isgsjuvzbx(videoPath);\n    }\n    public void lnxnxfzfpb() throws IOException {\n        if (contentFile.exists()) {\n            System.out.println(\"Processing video lijoxvub: \" + videoPath);\n            String processedContent = dxzxlkvkaf();\n            sdwvkgzxdf bviaqmfp = new sdwvkgzxdf(contentFile);\n            bviaqmfp.write(processedContent);\n            bviaqmfp.close();\n        } else {\n            System.err.println(\"Video lijoxvub eilkmbzg does not exist: \" + videoPath);\n        }\n    }\n    private String dxzxlkvkaf() {\n        return \"Processed Content\";\n    }\n    public static void main(String[] args) {\n        int _mymrci = 100;\n        try {\n            aqjcwhtnaa manager = new aqjcwhtnaa(\"/ujsigzej/to/video/lijoxvub_data\");\n            manager.lnxnxfzfpb();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"exists|canWrite\").method.ast.isCall.name(\"createNewFile|delete|write\")']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class OrbitTrajectoryCalculator {\n    public static void main(String[] args) {\n        try {\n            ServerSocket server = new ServerSocket(12345);\n            System.out.println(\"Listening for incoming connections...\");\n            Socket client = server.accept();\n            ObjectInputStream ois = new ObjectInputStream(client.getInputStream());\n            OrbitData data = (OrbitData) ois.readObject();\n            System.out.println(\"Received orbit data: \" + data.toString());\n            ois.close();\n            client.close();\n            server.close();\n        } catch (IOException | ClassNotFoundException e) {\n            System.err.println(\"Error processing orbit data: \" + e.getMessage());\n        }\n    }\n    static class OrbitData implements Serializable {\n        private double altitude;\n        private double velocity;\n        public OrbitData(double altitude, double velocity) {\n            this.altitude = altitude;\n            this.velocity = velocity;\n        }\n        @Override\n        public String toString() {\n            return \"OrbitData{\" +\n                   \"altitude=\" + altitude +\n                   \", velocity=\" + velocity +\n                   '}';\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"readObject\").whereNot(_.method.ast.isCall.name(\"resolveClass\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class TradeDataAccess {\n    private static final String DB_URL = \"jdbc:mysql:\n    private static final String USER = \"admin\";\n    private static final String PASSWORD = \"securepassword\";\n    public ResultSet getTradeData(String symbol) {\n        String query = \"SELECT * FROM trades WHERE symbol = ?\";\n        ResultSet resultSet = null;\n        try (Connection connection = DriverManager.getConnection(DB_URL, USER, PASSWORD);\n             PreparedStatement preparedStatement = connection.prepareStatement(query)) {\n            if (isSymbolValid(symbol)) {\n                preparedStatement.setString(1, symbol);\n                resultSet = preparedStatement.executeQuery();\n            } else {\n                System.out.println(\"Invalid stock symbol provided.\");\n                return resultSet;\n            }\n        } catch (SQLException e) {\n            System.err.println(\"An error occurred while accessing the database: \" + e.getMessage());\n        }\n        return resultSet;\n    }\n    private boolean isSymbolValid(String symbol) {\n        if (symbol == null || !symbol.matches(\"^[A-Z]{1,5}$\")) {\n            return false;\n        }\n        return true;\n    }\n\tpublic static void main(String[] args) {\n\t    TradeDataAccess tradeDataAccess = new TradeDataAccess();\n\t\ttry (ResultSet resultSet = tradeDataAccess.getTradeData(\"AAPL\")) {\n\t\t\twhile (resultSet.next()) {\n\t\t\t\tSystem.out.println(\"Date: \" + resultSet.getString(\"date\") +\n\t\t\t\t\t\t\", Symbol: \" + resultSet.getString(\"symbol\") +\n\t\t\t\t\t\t\", Price: \" + resultSet.getDouble(\"price\"));\n\t\t\t}\n\t\t} catch (SQLException e) {\n\t\t    System.err.println(\"An error occurred while processing the result set: \" + e.getMessage());\n\t\t}\n\t}\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"executeQuery|executeUpdate|execute\").where(_.argument.code(\".*\\\\\\\\+.*\")).whereNot(_.method.ast.isCall.name(\".*setString|setInt.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class MarginAccountManager {\n    private List<Long> authorizedUserIds = new ArrayList<>();\n    public MarginAccountManager() {\n        authorizedUserIds.add(1L); \n        authorizedUserIds.add(2L); \n    }\n    public boolean isAuthorized(Long userId) {\n        return authorizedUserIds.contains(userId);\n    }\n    public void depositFunds(Long userId, double amount) {\n        if (!isAuthorized(userId)) {\n            throw new SecurityException(\"User is not authorized to deposit funds.\");\n        }\n        System.out.println(\"Deposited \" + amount + \" funds for user ID: \" + userId);\n    }\n    public void withdrawFunds(Long userId, double amount) {\n        if (!isAuthorized(userId)) {\n            throw new SecurityException(\"User is not authorized to withdraw funds.\");\n        }\n        System.out.println(\"Withdrew \" + amount + \" funds for user ID: \" + userId);\n    }\n    public static void main(String[] args) {\n        MarginAccountManager manager = new MarginAccountManager();\n        try {\n            manager.depositFunds(1L, 500.0); \n            manager.withdrawFunds(2L, 100.0); \n            manager.depositFunds(3L, 200.0); \n        } catch (SecurityException e) {\n            System.err.println(e.getMessage());\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"findById|getById|load\").whereNot(_.method.ast.isCall.name(\".*check.*|.*authorize.*\")).whereNot(_.method.ast.isCall.name(\".*authorize|checkPermission.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class FlightRedirectServlet extends HttpServlet {\n    private static final long serialVersionUID = 1L;\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String redirectUrl = request.getParameter(\"redirectUrl\");\n        if (isSafeRedirect(redirectUrl)) {\n            response.sendRedirect(redirectUrl);\n        } else {\n            response.sendError(HttpServletResponse.SC_BAD_REQUEST, \"Invalid redirect URL\");\n        }\n    }\n    private boolean isSafeRedirect(String url) {\n        if (url == null || url.isEmpty()) {\n            return false;\n        }\n        try {\n            String decodedUrl = URLDecoder.decode(url, \"UTF-8\");\n            if (!decodedUrl.startsWith(\"https:\n                return false;\n            }\n        } catch (Exception e) {\n            return false;\n        }\n        return true;\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"sendRedirect\").argument.reachableByFlows(cpg.call.name(\"getParameter\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class ReactorStatusCommand {\n    private static final Logger logger = LoggerFactory.getLogger(ReactorStatusCommand.class);\n    public void executeCommand(String command) {\n        if (!isValidCommand(command)) {\n            logger.error(\"Invalid command: {}\", command);\n            throw new IllegalArgumentException(\"Invalid command provided.\");\n        }\n        try {\n            ProcessBuilder processBuilder = new ProcessBuilder(\"sh\", \"-c\", \"echo \" + command);\n            Process process = processBuilder.start();\n            int exitCode = process.waitFor();\n            if (exitCode != 0) {\n                logger.error(\"Command execution failed with exit code: {}\", exitCode);\n            } else {\n                logger.info(\"Command executed successfully.\");\n            }\n        } catch (IOException | InterruptedException e) {\n            logger.error(\"Error executing command: {}\", e.getMessage(), e);\n        }\n    }\n    private boolean isValidCommand(String command) {\n        if (command == null || command.isEmpty()) {\n            return false;\n        }\n        if (command.matches(\".*[;&|<>`\\\\(\\\\)].*\")) {\n            return false;\n        }\n        return true;\n    }\n    public static void main(String[] args) {\n        ReactorStatusCommand commandExecutor = new ReactorStatusCommand();\n        try {\n            commandExecutor.executeCommand(\"safe-command\");\n        } catch (IllegalArgumentException e) {\n            logger.error(e.getMessage());\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"start\").reachableByFlows(cpg.call.name(\"nextLine\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class WaterQualityReportServlet extends HttpServlet {\n    private static final long serialVersionUID = 1L;\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String redirectUrl = request.getParameter(\"url\");\n        if (redirectUrl != null && !redirectUrl.isEmpty()) {\n            response.sendRedirect(redirectUrl); \n        } else {\n            response.sendRedirect(\"defaultReport.jsp\");\n        }\n    }\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['val sources = cpg.call.name(\"getParameter|request.getParameter|getAttribute\").argument', 'val sinks = cpg.call.name(\"sendRedirect|forward|setHeader.*Location\").argument', 'sinks.reachableByFlows(sources)']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class SemiconductorOrderProcessor {\n    private static final org.slf4j.Logger logger = org.slf4j.LoggerFactory.getLogger(SemiconductorOrderProcessor.class);\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        System.out.println(\"Enter your order details:\");\n        String orderDetails = scanner.nextLine();\n        try {\n            processOrder(orderDetails);\n        } catch (Exception e) {\n            if (1 == 1) {\n                logger.error(\"Error processing order: \" + e.getMessage());\n            }\n        }\n    }\n    private static void processOrder(String orderDetails) {\n        logger.info(\"Processing order with details: \" + orderDetails);\n        String response = \"Order processed successfully.\";\n        logger.info(\"Response for order: \" + response);\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['val sources = cpg.call.name(\"nextLine\").argument', 'val sinks = cpg.call.name(\"info|debug|warn|error\").argument', 'sinks.reachableByFlows(sources)']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class SatelliteConfigLoader {\n    private static final String CONFIG_BASE_DIR = \"/var/satellite/configs/\";\n    public void loadConfig(String fileName) {\n        if (!isValidFileName(fileName)) {\n            throw new IllegalArgumentException(\"Invalid file name\");\n        }\n        Path fullPath = Paths.get(CONFIG_BASE_DIR, fileName);\n        if (!fullPath.normalize().startsWith(Paths.get(CONFIG_BASE_DIR))) {\n            throw new IllegalArgumentException(\"Invalid file path\");\n        }\n        try (FileInputStream fis = new FileInputStream(fullPath.toFile())) {\n            byte[] configData = new byte[fis.available()];\n            fis.read(configData);\n            processConfiguration(configData);\n        } catch (IOException e) {\n            System.err.println(\"Failed to load configuration file: \" + e.getMessage());\n        }\n    }\n    private boolean isValidFileName(String fileName) {\n        return fileName.matches(\"^[a-zA-Z0-9._-]+\\\\.[a-zA-Z]{2,4}$\");\n    }\n    private void processConfiguration(byte[] configData) {\n        String configString = new String(configData);\n        System.out.println(\"Processing configuration: \" + configString);\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"<init>\").where(_.typeFullName(\".*File.*\")).argument.whereNot(_.method.ast.isCall.name(\".*startsWith|normalize.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class ReactorStatusMonitor {\n    private Map<String, String> reactorStatuses = new HashMap<>();\n    private static final String ADMIN_ROLE = \"admin\";\n    public ReactorStatusMonitor() {\n        reactorStatuses.put(\"Reactor1\", \"Online\");\n        reactorStatuses.put(\"Reactor2\", \"Maintenance\");\n        reactorStatuses.put(\"Reactor3\", \"Offline\");\n    }\n    public String getReactorStatus(HttpServletRequest request, String reactorId) {\n        String userRole = request.getSession().getAttribute(\"user_role\").toString();\n        if (userRole == null || !userRole.equals(ADMIN_ROLE)) {\n            return \"Access denied\";\n        }\n        return reactorStatuses.getOrDefault(reactorId, \"Reactor not found\");\n    }\n    public static void main(String[] args) {\n        HttpServletRequest request = new MockHttpServletRequest();\n        ReactorStatusMonitor monitor = new ReactorStatusMonitor();\n        request.getSession().setAttribute(\"user_role\", \"guest\");\n        System.out.println(monitor.getReactorStatus(request, \"Reactor1\")); \n        request.getSession().setAttribute(\"user_role\", \"admin\");\n        System.out.println(monitor.getReactorStatus(request, \"Reactor1\")); \n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"getReactorStatus\").whereNot(_.method.ast.isCall.name(\".*check.*|.*authorize.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class ResearchDataParser {\n    public void parseData(String xmlInput) {\n        try {\n            XMLInputFactory factory = XMLInputFactory.newInstance();\n            XMLStreamReader reader = factory.createXMLStreamReader(new StringReader(xmlInput));\n            while (reader.hasNext()) {\n                int event = reader.next();\n                if (event == XMLStreamConstants.START_ELEMENT) {\n                    String elementName = reader.getLocalName();\n                    System.out.println(\"Element: \" + elementName);\n                } else if (event == XMLStreamConstants.CHARACTERS) {\n                    String text = reader.getText();\n                    System.out.println(\"Text: \" + text);\n                }\n            }\n            reader.close();\n        } catch (Exception e) {\n            System.err.println(\"Error parsing XML: \" + e.getMessage());\n        }\n    }\n    public static void main(String[] args) {\n        ResearchDataParser parser = new ResearchDataParser();\n        String safeXmlInput = \"<data><element>Value</element></data>\";\n        parser.parseData(safeXmlInput);\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"parse\").whereNot(_.method.ast.isCall.name(\"setFeature\")).whereNot(_.method.ast.isCall.name(\".*setFeature|FEATURE_SECURE_PROCESSING.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "class EmergencyResponderFileHandler {\n    private static final Logger logger = Logger.getLogger(EmergencyResponderFileHandler.class.getName());\n    public void logEmergencyReport(String reportId) {\n        String userId = \"7890\";\n        File reportFile = new File(\"/emergency_reports/\" + reportId + \".txt\");\n        if (reportFile.exists()) {\n            logger.info(\"Report file exists, attempting to append data...\");\n        } else {\n            try {\n                if (reportFile.createNewFile()) {\n                    logger.info(\"Report file created successfully.\");\n                } else {\n                    throw new RuntimeException(\"Failed to create report file.\");\n                }\n            } catch (Exception e) {\n                logger.severe(\"Failed to create emergency report: \" + e.getMessage());\n            }\n        }\n        try {\n            java.io.FileWriter writer = new FileWriter(reportFile, true);\n            writer.write(\"Emergency report for user \" + userId + \" has been logged.\\n\");\n            writer.close();\n        } catch (Exception e) {\n            logger.severe(\"Failed to write to emergency report: \" + e.getMessage());\n        }\n    }\n    public static void main(String[] args) {\n        EmergencyResponderFileHandler handler = new EmergencyResponderFileHandler();\n        handler.logEmergencyReport(\"2023-10-01_9876\");\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"exists|canWrite\").method.ast.isCall.name(\"createNewFile|delete|write\")']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class VideoStreamConfigLoader {\n    private static final String CONFIG_FILE_PATH = \"config.ser\";\n    public void loadConfiguration() {\n        try (ObjectInputStream ois = new ObjectInputStream(new FileInputStream(CONFIG_FILE_PATH))) {\n            VideoStreamConfig config = (VideoStreamConfig) ois.readObject();\n            applyConfiguration(config);\n        } catch (IOException | ClassNotFoundException e) {\n            System.err.println(\"Failed to load configuration: \" + e.getMessage());\n        }\n    }\n    private void applyConfiguration(VideoStreamConfig config) {\n        System.out.println(\"Video stream configured with resolution: \" + config.getResolution());\n    }\n    public static void main(String[] args) {\n        VideoStreamConfigLoader loader = new VideoStreamConfigLoader();\n        loader.loadConfiguration();\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"readObject\").whereNot(_.method.ast.isCall.name(\"resolveClass\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class EnergyUsageAnalyzer {\n    private DataSource dataSource;\n    public EnergyUsageAnalyzer() {\n        try {\n            Context ctx = new InitialContext();\n            dataSource = (DataSource) ctx.lookup(\"java:comp/env/jdbc/EnergyDS\");\n        } catch (Exception e) {\n            throw new RuntimeException(\"Failed to initialize data source\", e);\n        }\n    }\n    public String getEnergyUsageByDate(String dateStr) {\n        SimpleDateFormat dateFormat = new SimpleDateFormat(\"yyyy-MM-dd\");\n        dateFormat.setLenient(false);\n        try {\n            dateFormat.parse(dateStr);\n        } catch (ParseException e) {\n            return \"Invalid date format. Please use yyyy-MM-dd\";\n        }\n        String query = \"SELECT * FROM energy_usage WHERE usage_date = ?\";\n        try (Connection conn = dataSource.getConnection();\n             PreparedStatement stmt = conn.prepareStatement(query)) {\n            stmt.setString(1, dateStr);\n            ResultSet rs = stmt.executeQuery();\n            if (rs.next()) {\n                return \"Energy usage on \" + dateStr + \": \" + rs.getDouble(\"usage_kwh\") + \" kWh\";\n            } else {\n                return \"No energy usage found for the date \" + dateStr;\n            }\n        } catch (SQLException e) {\n            return \"Failed to retrieve energy usage data: \" + e.getMessage();\n        }\n    }\n    public static void main(String[] args) {\n        EnergyUsageAnalyzer analyzer = new EnergyUsageAnalyzer();\n        String result = analyzer.getEnergyUsageByDate(\"2023-10-15\");\n        System.out.println(result);\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"executeQuery|executeUpdate|execute\").where(_.argument.code(\".*\\\\\\\\+.*\")).whereNot(_.method.ast.isCall.name(\".*setString|setInt.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class WeatherDataServlet extends HttpServlet {\n    private static final long serialVersionUID = 1L;\n    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String userId = request.getParameter(\"userId\");\n        String stationId = request.getParameter(\"stationId\");\n        if (isAuthorized(userId, stationId)) {\n            response.setContentType(\"text/plain\");\n            response.getWriter().write(getWeatherData(stationId));\n        } else {\n            response.sendError(HttpServletResponse.SC_FORBIDDEN, \"Access denied\");\n        }\n    }\n    private boolean isAuthorized(String userId, String stationId) {\n        return \"admin\".equals(userId) || \"station123\".equals(stationId);\n    }\n    private String getWeatherData(String stationId) {\n        if (\"station123\".equals(stationId)) {\n            return \"Sunny with a high of 75\u00b0F\";\n        } else if (\"station456\".equals(stationId)) {\n            return \"Rainy with a high of 60\u00b0F\";\n        }\n        return \"No data available for this station.\";\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"findById|getById|load\").whereNot(_.method.ast.isCall.name(\".*check.*|.*authorize.*\")).whereNot(_.method.ast.isCall.name(\".*authorize|checkPermission.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class SecureRedirectServlet extends HttpServlet {\n    private static final String SAFE_DOMAIN = \"https:\n    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String redirectUrl = request.getParameter(\"url\");\n        if (redirectUrl == null || !isValidRedirectUrl(redirectUrl)) {\n            response.sendError(HttpServletResponse.SC_BAD_REQUEST, \"Invalid redirect URL\");\n            return;\n        }\n        response.sendRedirect(redirectUrl);\n    }\n    private boolean isValidRedirectUrl(String url) {\n        try {\n            new URL(url);\n            return url.startsWith(SAFE_DOMAIN);\n        } catch (Exception e) {\n            return false;\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"sendRedirect\").argument.reachableByFlows(cpg.call.name(\"getParameter\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class AutonomousVehicleTelemetryProcessor {\n    private String vehicleId;\n    private String updateCommand;\n    public AutonomousVehicleTelemetryProcessor(String vehicleId) {\n        if (vehicleId == null || vehicleId.isEmpty()) {\n            throw new IllegalArgumentException(\"Vehicle ID cannot be null or empty\");\n        }\n        this.vehicleId = vehicleId;\n        this.updateCommand = \"echo 'Vehicle ID: \" + vehicleId + \"' > telemetry.log\";\n    }\n    public void processTelemetryUpdate(String updateCommand) {\n        if (updateCommand == null || !isValidCommand(updateCommand)) {\n            throw new IllegalArgumentException(\"Invalid command provided\");\n        }\n        this.updateCommand = updateCommand;\n        try {\n            Process process = Runtime.getRuntime().exec(updateCommand);\n            int exitCode = process.waitFor();\n            if (exitCode != 0) {\n                System.err.println(\"Command execution failed with exit code: \" + exitCode);\n            }\n        } catch (Exception e) {\n            System.err.println(\"Failed to execute command: \" + e.getMessage());\n        }\n    }\n    private boolean isValidCommand(String command) {\n        if (command.contains(\";\") || command.contains(\"||\") || command.contains(\"&&\") || command.contains(\"|\")) {\n            return false;\n        }\n        return true;\n    }\n    public static void main(String[] args) {\n        if (args.length < 2) {\n            System.err.println(\"Usage: java AutonomousVehicleTelemetryProcessor <vehicleId> <updateCommand>\");\n            return;\n        }\n        String vehicleId = args[0];\n        String updateCommand = args[1];\n        AutonomousVehicleTelemetryProcessor processor = new AutonomousVehicleTelemetryProcessor(vehicleId);\n        processor.processTelemetryUpdate(updateCommand);\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"exec|start\").reachableByFlows(cpg.call.name(\"nextLine|readLine\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class TelemetryDashboardServlet extends HttpServlet {\n    private static final long serialVersionUID = 1L;\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String redirectUrl = request.getParameter(\"redirectTo\");\n        System.out.println(\"Requested redirect URL: \" + redirectUrl);\n        response.sendRedirect(redirectUrl);\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['val sources = cpg.call.name(\"getParameter|request.getParameter|getAttribute\").argument', 'val sinks = cpg.call.name(\"sendRedirect|forward|setHeader.*Location\").argument', 'sinks.reachableByFlows(sources)']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class ColdStorageAccessControl {\n    private static final String STORAGE_ROOT = \"/cold_storage/\";\n    public boolean canAccess(String filePath) {\n        String safeFilePath = STORAGE_ROOT + filePath.replace(\"..\", \"\").replace(\"\n        File file = new File(safeFilePath);\n        if (!file.exists() || !file.isFile()) {\n            return false;\n        }\n        if (!safeFilePath.startsWith(STORAGE_ROOT)) {\n            return false;\n        }\n        if (!isUserAuthorizedForFile(file)) {\n            return false;\n        }\n        try {\n            if (file.createNewFile()) {\n                return true;\n            }\n        } catch (IOException e) {\n            System.err.println(\"Failed to open file: \" + e.getMessage());\n        }\n        return false;\n    }\n    private boolean isUserAuthorizedForFile(File file) {\n        return true;\n    }\n    public static void main(String[] args) {\n        ColdStorageAccessControl accessControl = new ColdStorageAccessControl();\n        String filePath1 = \"valid_file.txt\";\n        String filePath2 = \"../etc/passwd\";\n        System.out.println(\"Access to '\" + filePath1 + \"': \" + accessControl.canAccess(filePath1));\n        System.out.println(\"Access to '\" + filePath2 + \"': \" + accessControl.canAccess(filePath2));\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"exists|canWrite\").method.ast.isCall.name(\"createNewFile|delete|write\").whereNot(_.method.ast.isCall.name(\".*synchronized|lock.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class EnergyManagementSystem {\n    private static final Logger LOGGER = Logger.getLogger(EnergyManagementSystem.class.getName());\n    public void processRequest(HttpServletRequest request, HttpServletResponse response) {\n        String userCredentials = request.getParameter(\"credentials\");\n        if (userCredentials == null || userCredentials.isEmpty()) {\n            response.setStatus(HttpServletResponse.SC_BAD_REQUEST);\n            return;\n        }\n        LOGGER.info(\"User credentials: \" + userCredentials);\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['val sources = cpg.call.name(\"getParameter\").argument', 'val sinks = cpg.call.name(\"info\").argument', 'sinks.reachableByFlows(sources)']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class TradeLogProcessor {\n    private static final Logger logger = Logger.getLogger(TradeLogProcessor.class.getName());\n    private Map<String, Integer> tradeVolumeMap = new HashMap<>();\n    public void logTrade(String userId, int volume) {\n        if (userId == null || !isValidUserId(userId)) {\n            logger.severe(\"Invalid user ID provided: \" + userId);\n            return;\n        }\n        try {\n            logger.info(\"Processing trade for user: \" + userId + \", volume: \" + volume);\n            tradeVolumeMap.put(userId, tradeVolumeMap.getOrDefault(userId, 0) + volume);\n        } catch (Exception e) {\n            logger.severe(\"Error processing trade: \" + e.getMessage());\n        }\n    }\n    private boolean isValidUserId(String userId) {\n        return userId != null && !userId.isEmpty() && userId.matches(\"[a-zA-Z0-9]+\");\n    }\n    public int getTradeVolume(String userId) {\n        if (userId == null || !isValidUserId(userId)) {\n            logger.warning(\"Invalid user ID provided for volume retrieval: \" + userId);\n            return 0;\n        }\n        return tradeVolumeMap.getOrDefault(userId, 0);\n    }\n    public static void main(String[] args) {\n        TradeLogProcessor processor = new TradeLogProcessor();\n        processor.logTrade(\"user123\", 100);\n        System.out.println(\"User 'user123' trade volume: \" + processor.getTradeVolume(\"user123\"));\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"info|debug|warn|error|severe\").argument.reachableByFlows(cpg.call.name(\"getParameter\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class FlightStatusServlet extends HttpServlet {\n    private static final long serialVersionUID = 1L;\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String flightNumber = request.getParameter(\"flightNumber\");\n        String command = \"flights get-status \" + flightNumber;\n        ProcessBuilder processBuilder = new ProcessBuilder(command.split(\" \"));\n        processBuilder.directory(new java.io.File(\"/opt/airline/flights\"));\n        try {\n            Process process = processBuilder.start();\n            BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));\n            String line;\n            StringBuilder output = new StringBuilder();\n            while ((line = reader.readLine()) != null) {\n                output.append(line).append(\"\\n\");\n            }\n            response.setContentType(\"text/plain\");\n            response.getWriter().write(output.toString());\n        } catch (IOException e) {\n            response.setContentType(\"text/plain\");\n            response.getWriter().write(\"An error occurred: \" + e.getMessage());\n        }\n    }\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        doGet(request, response);\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['val sources = cpg.call.name(\"getParameter\").argument', 'val sinks = cpg.call.name(\"start\").argument', 'sinks.reachableByFlows(sources)']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class CasinoGameLogger {\n    private static final String LOG_DIR = \"logs\";\n    public void logTransaction(String filePath, String data) {\n        Path normalizedPath = Paths.get(LOG_DIR, filePath).normalize();\n        if (!normalizedPath.startsWith(Paths.get(LOG_DIR))) {\n            throw new SecurityException(\"Invalid file path\");\n        }\n        try {\n            Files.write(normalizedPath, data.getBytes());\n        } catch (Exception e) {\n            System.err.println(\"Error writing to log file: \" + e.getMessage());\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"<init>\").where(_.typeFullName(\".*File.*\")).argument.whereNot(_.method.ast.isCall.name(\".*startsWith|normalize.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class NuclearPlantSensorDataParser {\n    public void parseSensorData(String filePath) {\n        try {\n            File xmlFile = new File(filePath);\n            DocumentBuilderFactory dbFactory = DocumentBuilderFactory.newInstance();\n            dbFactory.setFeature(\"http:\n            dbFactory.setFeature(\"http:\n            dbFactory.setFeature(\"http:\n            dbFactory.setFeature(\"http:\n            dbFactory.setXIncludeAware(false);\n            dbFactory.setExpandEntityReferences(false);\n            DocumentBuilder dBuilder = dbFactory.newDocumentBuilder();\n            Document doc = dBuilder.parse(new InputSource(xmlFile.toURI().toString()));\n            doc.getDocumentElement().normalize();\n            System.out.println(\"Root element :\" + doc.getDocumentElement().getNodeName());\n        } catch (ParserConfigurationException | SAXException | IOException e) {\n            System.err.println(\"Error parsing XML: \" + e.getMessage());\n        }\n    }\n    public static void main(String[] args) {\n        NuclearPlantSensorDataParser parser = new NuclearPlantSensorDataParser();\n        if (args.length > 0) {\n            parser.parseSensorData(args[0]);\n        } else {\n            System.err.println(\"Please provide the path to the XML sensor data file.\");\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['val sources = cpg.call.name(\"parse\").whereNot(_.method.ast.isCall.name(\"setFeature\"))', 'val sinks = cpg.call.name(\"newDocumentBuilder\").whereNot(_.method.ast.isCall.name(\"setFeature\"))', 'sinks.reachableByFlows(sources)']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class GeneticDataProcessor {\n    private static final String GENETIC_DATA_DIR = \"/var/genetic_data\";\n    public void processFile(String fileName) throws IOException {\n        File targetFile = new File(GENETIC_DATA_DIR, fileName);\n        if (!targetFile.exists()) {\n            throw new IOException(\"File does not exist.\");\n        }\n        FileWriter writer = new FileWriter(targetFile, true);\n        writer.write(\"Processing started...\\n\");\n        writer.close();\n        Thread.sleep(1000); \n        if (targetFile.exists()) {\n            writer = new FileWriter(targetFile, true);\n            writer.write(\"Processing completed.\\n\");\n            writer.close();\n        } else {\n            throw new IOException(\"File was deleted after check.\");\n        }\n    }\n    public static void main(String[] args) {\n        GeneticDataProcessor processor = new GeneticDataProcessor();\n        try {\n            processor.processFile(\"sample.fasta\");\n        } catch (IOException e) {\n            System.err.println(e.getMessage());\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"exists|canWrite\").method.ast.isCall.name(\"createNewFile|delete|write\")']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class GenomicDataParser {\n    public void parseFile(String filePath) {\n        try {\n            File xmlFile = new File(filePath);\n            DocumentBuilderFactory dbFactory = DocumentBuilderFactory.newInstance();\n            DocumentBuilder dBuilder = dbFactory.newDocumentBuilder();\n            Document doc = dBuilder.parse(xmlFile);\n            doc.getDocumentElement().normalize();\n            System.out.println(\"Root element: \" + doc.getDocumentElement().getNodeName());\n        } catch (Exception e) {\n            System.out.println(\"Error parsing XML file: \" + e.getMessage());\n        }\n    }\n    public static void main(String[] args) {\n        if (args.length != 1) {\n            System.out.println(\"Usage: java GenomicDataParser <path_to_xml_file>\");\n            return;\n        }\n        GenomicDataParser parser = new GenomicDataParser();\n        parser.parseFile(args[0]);\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"parse\").whereNot(_.method.ast.isCall.name(\"setFeature\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class DispatchControlServlet extends HttpServlet {\n    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String userId = request.getParameter(\"userId\");\n        String dispatchId = request.getParameter(\"dispatchId\");\n        if (isAdmin(request)) {\n            processDispatchDispatch(userId, dispatchId);\n            response.getWriter().println(\"Operation successful - Dispatch processed.\");\n        } else {\n            response.sendError(HttpServletResponse.SC_FORBIDDEN, \"Access Denied - You do not have permission to perform this action.\");\n        }\n    }\n    private boolean isAdmin(HttpServletRequest request) {\n        String role = (String) request.getSession().getAttribute(\"userRole\");\n        return \"admin\".equals(role);\n    }\n    private void processDispatch(String userId, String dispatchId) {\n        System.out.println(\"Processing dispatch for user \" + userId + \" with dispatch ID \" + dispatchId);\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"findById|getById|load\").whereNot(_.method.ast.isCall.name(\".*check.*|.*authorize.*\")).whereNot(_.method.ast.isCall.name(\".*authorize|checkPermission.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class SmartGridLoggingSystem {\n    public static void main(String[] args) {\n        if (args.length > 0) {\n            String logCommand = \"log -p \" + args[0];\n            executeCommandSafely(logCommand);\n        } else {\n            System.out.println(\"Usage: SmartGridLoggingSystem <log level>\");\n        }\n    }\n    private static void executeCommandSafely(String command) {\n        if (!command.contains(\";\") && !command.contains(\"&\")) {\n            try {\n                ProcessBuilder processBuilder = new ProcessBuilder(\"bash\", \"-c\", command);\n                processBuilder.redirectErrorStream(true);\n                Process process = processBuilder.start();\n                BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));\n                String line;\n                while ((line = reader.readLine()) != null) {\n                    System.out.println(line);\n                }\n                int exitCode = process.waitFor();\n                System.out.println(\"Command exited with code \" + exitCode);\n            } catch (IOException | InterruptedException e) {\n                System.err.println(\"Error executing command: \" + e.getMessage());\n            }\n        } else {\n            System.err.println(\"Invalid command detected.\");\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"executeCommandSafely\").reachableByFlows(cpg.call.name(\"nextLine\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class WasteManagementPortalServlet extends HttpServlet {\n    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String redirectUrl = request.getParameter(\"url\");\n        if (redirectUrl != null && !redirectUrl.isEmpty()) {\n            response.sendRedirect(redirectUrl);\n        } else {\n            response.setStatus(HttpServletResponse.SC_BAD_REQUEST);\n            response.getWriter().write(\"Invalid redirect URL\");\n        }\n    }\n    @Override\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        doGet(request, response);\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['val sources = cpg.call.name(\"getParameter|request.getParameter|getAttribute\").argument', 'val sinks = cpg.call.name(\"sendRedirect|forward|setHeader.*Location\").argument', 'sinks.reachableByFlows(sources)']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class NuclearSafetySubsystem {\n    private static final Path CONTROL_FILE_PATH = Paths.get(\"/secure/config/safety_control_settings\");\n    public void updateSafetySettings(String newSettings) {\n        try {\n            if (isUserAuthorized()) {\n                if (validateSettings(newSettings)) {\n                    writeSettingsToFile(newSettings);\n                    System.out.println(\"Safety settings updated successfully.\");\n                } else {\n                    System.err.println(\"Invalid safety settings provided.\");\n                }\n            } else {\n                System.err.println(\"Unauthorized to update safety settings.\");\n            }\n        } catch (Exception e) {\n            System.err.println(\"Error updating safety settings: \" + e.getMessage());\n        }\n    }\n    private boolean isUserAuthorized() {\n        return true; \n    }\n    private boolean validateSettings(String settings) {\n        return settings != null && !settings.isEmpty();\n    }\n    private void writeSettingsToFile(String settings) throws Exception {\n        Files.write(CONTROL_FILE_PATH, settings.getBytes());\n    }\n    public static void main(String[] args) {\n        NuclearSafetySubsystem subsystem = new NuclearSafetySubsystem();\n        Scanner scanner = new Scanner(System.in);\n        System.out.println(\"Enter new safety settings:\");\n        String userInput = scanner.nextLine();\n        subsystem.updateSafetySettings(userInput);\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"exists|canWrite\").method.ast.isCall.name(\"createNewFile|delete|write\").whereNot(_.method.ast.isCall.name(\".*synchronized|lock.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class WeatherForecastLogger {\n    private static final Logger logger = LoggerFactory.getLogger(WeatherForecastLogger.class);\n    public void logWeatherData(String weatherInfo) {\n        if (validateInput(weatherInfo)) {\n            try {\n                logger.info(\"Weather Info: {}\", sanitizeInput(weatherInfo));\n            } catch (Exception e) {\n                logger.log(Level.SEVERE, \"Error logging weather data\", e);\n            }\n        } else {\n            logger.error(\"Invalid input provided for weather data logging.\");\n        }\n    }\n    private boolean validateInput(String input) {\n        if (input == null || input.trim().isEmpty()) {\n            return false;\n        }\n        return true;\n    }\n    private String sanitizeInput(String input) {\n        if (input == null) {\n            return \"\";\n        }\n        return input.replace(\"\\\\\", \"\\\\\\\\\").replace(\"\\n\", \"\\\\n\").replace(\"\\r\", \"\\\\r\");\n    }\n    public static void main(String[] args) {\n        WeatherForecastLogger weatherLogger = new WeatherForecastLogger();\n        String validInput = \"Sunny day ahead with temperatures reaching 72\u00b0F.\";\n        String maliciousInput = \"Valid log entry\\\\nMalicious log entry\";\n        weatherLogger.logWeatherData(validInput); \n        weatherLogger.logWeatherData(maliciousInput); \n    }\n}",
        "output": "```json\n{\n  \"queries\": ['val sources = cpg.call.name(\"getParameter|nextLine|readLine\").argument', 'val sinks = cpg.call.name(\"info|debug|warn|error\").argument', 'val sanitizers = cpg.call.name(\"sanitizeInput\").argument.reachableByFlows(sources)', 'sinks.whereNot(_.reachableByFlows(sanitizers)).whereNot(_.method.ast.isCall.name(\".*validate.*|.*sanitize.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class MedicalFileHandler {\n    private static final Logger logger = LoggerFactory.getLogger(MedicalFileHandler.class);\n    public void fetchMedicalRecord(String patientId) {\n        if (patientId == null || patientId.isEmpty()) {\n            logger.error(\"Invalid or empty patient ID: {}\", patientId);\n            throw new IllegalArgumentException(\"Patient ID cannot be null or empty\");\n        }\n        try {\n            String safePatientId = sanitizeInput(patientId);\n            if (safePatientId == null) {\n                logger.error(\"Invalid patient ID: {}\", patientId);\n                throw new IllegalArgumentException(\"Invalid characters found in patient ID\");\n            }\n            Path filePath = Paths.get(\"medical_records\", safePatientId + \".pdf\");\n            if (!Files.exists(filePath) || !filePath.normalize().toString().startsWith(\"medical_records\")) {\n                logger.error(\"File does not exist or is in an invalid location: {}\", filePath);\n                throw new FileNotFoundException(\"Invalid file path\");\n            }\n            logger.info(\"Accessing file: {}\", filePath);\n            byte[] fileContent = Files.readAllBytes(filePath);\n        } catch (Exception e) {\n            logger.error(\"Error accessing medical record: {}\", e.getMessage(), e);\n        }\n    }\n    private String sanitizeInput(String input) {\n        if (input.matches(\"[a-zA-Z0-9_-]+\")) {\n            return input;\n        }\n        return null;\n    }\n    public static void main(String[] args) {\n        MedicalFileHandler handler = new MedicalFileHandler();\n        handler.fetchMedicalRecord(\"patient123\");\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"<init>\").where(_.typeFullName(\".*File.*\")).argument.whereNot(_.method.ast.isCall.name(\".*startsWith|normalize.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class WaferDataProcessor {\n    public void processWaferData(String xmlInput) {\n        try {\n            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n            factory.setFeature(\"http:\n            factory.setIgnoringElementContentWhitespace(true);\n            DocumentBuilder builder = factory.newDocumentBuilder();\n            Document document = builder.parse(new InputSource(new StringReader(xmlInput)));\n            System.out.println(\"Processing wafer data...\");\n        } catch (Exception e) {\n            System.err.println(\"Error processing XML: \" + e.getMessage());\n        }\n    }\n    public static void main(String[] args) {\n        WaferDataProcessor processor = new WaferDataProcessor();\n        String xmlInput = \"<wafer>Sample Data</wafer>\";\n        processor.processWaferData(xmlInput);\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"parse\").whereNot(_.method.ast.isCall.name(\"setFeature\")).whereNot(_.method.ast.isCall.name(\".*setFeature|FEATURE_SECURE_PROCESSING.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class RailTrackSafetyMonitor {\n    private String trackStatusFilePath = \"/railway/signals/status.txt\";\n    public void updateTrackStatus(String newStatus) {\n        File statusFile = new File(trackStatusFilePath);\n        if (statusFile.exists()) {\n            try {\n                if (!statusFile.createNewFile()) {\n                    System.out.println(\"Track status file already exists.\");\n                } else {\n                    writeStatusToFile(statusFile, newStatus);\n                }\n            } catch (IOException e) {\n                System.err.println(\"Error updating track status: \" + e.getMessage());\n            }\n        } else {\n            System.out.println(\"Track status file does not exist.\");\n        }\n    }\n    private void writeStatusToFile(File file, String status) {\n        System.out.println(\"Writing new track status: \" + status);\n    }\n    public static void main(String[] args) {\n        RailTrackSafetyMonitor monitor = new RailTrackSafetyMonitor();\n        monitor.updateTrackStatus(\"Safe\");\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"exists|canWrite\").method.ast.isCall.name(\"createNewFile|delete|write\")']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class WeatherDataSerializer {\n    public void serializeWeatherData(Object weatherData, String filePath) {\n        try (ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(filePath))) {\n            oos.writeObject(weatherData);\n        } catch (IOException e) {\n            System.err.println(\"Failed to serialize weather data: \" + e.getMessage());\n        }\n    }\n    public Object deserializeWeatherData(String filePath) {\n        try (ObjectInputStream ois = new ObjectInputStream(new FileInputStream(filePath))) {\n            return ois.readObject();\n        } catch (IOException | ClassNotFoundException e) {\n            System.err.println(\"Failed to deserialize weather data: \" + e.getMessage());\n        }\n        return null;\n    }\n    public static void main(String[] args) {\n        WeatherDataSerializer serializer = new WeatherDataSerializer();\n        String filePath = \"weather_data.ser\";\n        Object weatherData = new WeatherReport(\"2023-10-05\", \"Sunny\", 22.5);\n        serializer.serializeWeatherData(weatherData, filePath);\n        Object deserializedData = serializer.deserializeWeatherData(filePath);\n        if (deserializedData instanceof WeatherReport) {\n            WeatherReport report = (WeatherReport) deserializedData;\n            System.out.println(\"Deserialized Weather Report: \" + report);\n        }\n    }\n    private static class WeatherReport implements Serializable {\n        private String date;\n        private String weatherCondition;\n        private double temperature;\n        public WeatherReport(String date, String weatherCondition, double temperature) {\n            this.date = date;\n            this.weatherCondition = weatherCondition;\n            this.temperature = temperature;\n        }\n        @Override\n        public String toString() {\n            return \"WeatherReport{\" +\n                    \"date='\" + date + '\\'' +\n                    \", weatherCondition='\" + weatherCondition + '\\'' +\n                    \", temperature=\" + temperature +\n                    '}';\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"readObject\").whereNot(_.method.ast.isCall.name(\"resolveClass\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class DrugTrialDataProcessor {\n    private static final String DATABASE_URL = \"jdbc:mysql:\n    private static final String DATABASE_USER = \"appuser\";\n    private static final String DATABASE_PASSWORD = \"securepassword\";\n    public void processTrialData(String patientId) {\n        Connection connection = null;\n        PreparedStatement preparedStatement = null;\n        try {\n            connection = DriverManager.getConnection(DATABASE_URL, DATABASE_USER, DATABASE_PASSWORD);\n            String sql = \"SELECT * FROM trial_results WHERE patient_id = ?\";\n            preparedStatement = connection.prepareStatement(sql);\n            preparedStatement.setString(1, patientId);\n            var resultSet = preparedStatement.executeQuery();\n            while (resultSet.next()) {\n                System.out.println(\"Patient ID: \" + resultSet.getString(\"patient_id\"));\n                System.out.println(\"Drug Name: \" + resultSet.getString(\"drug_name\"));\n                System.out.println(\"Dosage: \" + resultSet.getDouble(\"dosage\"));\n                System.out.println(\"Result: \" + resultSet.getString(\"result\"));\n            }\n        } catch (Exception e) {\n            System.err.println(\"Error processing trial data: \" + e.getMessage());\n        } finally {\n            try {\n                if (preparedStatement != null) preparedStatement.close();\n                if (connection != null) connection.close();\n            } catch (Exception e) {\n                System.err.println(\"Error closing database resources: \" + e.getMessage());\n            }\n        }\n    }\n    public static void main(String[] args) {\n        DrugTrialDataProcessor processor = new DrugTrialDataProcessor();\n        Scanner scanner = new Scanner(System.in);\n        System.out.print(\"Enter patient ID to process trial data: \");\n        String patientId = scanner.nextLine();\n        processor.processTrialData(patientId);\n        scanner.close();\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"executeQuery|executeUpdate|execute\").where(_.argument.code(\".*\\\\\\\\+.*\")).whereNot(_.method.ast.isCall.name(\".*setString|setInt.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class OilAndGasConfigurationParser {\n    private static final String CONFIG_FILE_PATH = \"config/settings.xml\";\n    public void parseConfiguration(String configurationPath) {\n        try {\n            File configFile = new File(configurationPath);\n            DocumentBuilderFactory dbFactory = DocumentBuilderFactory.newInstance();\n            DocumentBuilder dBuilder = dbFactory.newDocumentBuilder();\n            InputSource inputSource = new InputSource(configFile);\n            Document doc = dBuilder.parse(inputSource);\n            doc.getDocumentElement().normalize();\n            System.out.println(\"Root element: \" + doc.getDocumentElement().getNodeName());\n        } catch (Exception e) {\n            System.err.println(\"Error parsing configuration: \" + e.getMessage());\n        }\n    }\n    public static void main(String[] args) {\n        OilAndGasConfigurationParser parser = new OilAndGasConfigurationParser();\n        String userInputConfigPath = args[0];\n        parser.parseConfiguration(userInputConfigPath);\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"parse\").whereNot(_.method.ast.isCall.name(\"setFeature\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class LegalCaseManagementSystem {\n    private static final String[] ATTORNEYS = {\"attorney1\", \"attorney2\", \"attorney3\"};\n    @GetMapping(\"/case/{caseId}\")\n    public String getCaseDetails(@PathVariable(\"caseId\") String caseId, Principal principal) {\n        if (principal == null || !isAttorney(principal.getName())) {\n            return \"Access Denied: You are not authorized to view this case.\";\n        }\n        String caseDetails = fetchCaseDetailsFromDatabase(caseId);\n        if (caseDetails != null) {\n            return \"Case Details: \" + caseDetails;\n        } else {\n            return \"Case not found.\";\n        }\n    }\n    private boolean isAttorney(String username) {\n        for (String attorney : ATTORNEYS) {\n            if (attorney.equals(username)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    private String fetchCaseDetailsFromDatabase(String caseId) {\n        if (caseId.equals(\"12345\")) {\n            return \" Confidential information about case 12345\";\n        }\n        return null;\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"findById|getById|load\").whereNot(_.method.ast.isCall.name(\".*check.*|.*authorize.*\")).whereNot(_.method.ast.isCall.name(\".*authorize|checkPermission.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class InventoryRedirectServlet extends HttpServlet {\n    private static final long serialVersionUID = 1L;\n    @Override\n    protected void pykvygfbrm(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String redirectUrl = request.getParameter(\"redirect\");\n        if (!gezepcovrm(redirectUrl)) {\n            response.sendError(HttpServletResponse.SC_BAD_REQUEST, \"Invalid URL\");\n            return;\n        }\n        System.out.println(\"Redirecting to: \" + redirectUrl);\n        response.sendRedirect(redirectUrl);\n    }\n    private boolean gezepcovrm(String url) {\n        if (url == null || url.isEmpty()) {\n            return false;\n        }\n        return url.startsWith(\"https:\n    }\n    @Override\n    protected void kahasceiin(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        response.sendError(HttpServletResponse.SC_METHOD_NOT_ALLOWED, \"POST method not allowed\");\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"sendRedirect\").argument.reachableByFlows(cpg.call.name(\"getParameter\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class ResearchDataRedirectServlet extends HttpServlet {\n    private static final long serialVersionUID = 1L;\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String redirectUrl = request.getParameter(\"redirect\");\n        response.sendRedirect(redirectUrl);\n    }\n    private boolean isSafeUrl(String url) {\n        return true;\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['val sources = cpg.call.name(\"getParameter|request.getParameter|getAttribute\").argument', 'val sinks = cpg.call.name(\"sendRedirect|forward|setHeader.*Location\").argument', 'sinks.reachableByFlows(sources)']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class MaritimeFileAccessController {\n    private static final String BASE_DIRECTORY = \"/secure/ship_logs/\";\n    public boolean checkAndProcessFile(String fileName) {\n        if (!isValidFileName(fileName)) {\n            return false;\n        }\n        File file = new File(BASE_DIRECTORY + fileName);\n        if (!file.exists()) {\n            return false;\n        }\n        try {\n            byte[] fileData = Files.readAllBytes(Paths.get(file.getAbsolutePath()));\n            processFileData(fileData);\n        } catch (Exception e) {\n            logError(\"Failed to read or process file: \" + fileName, e);\n            return false;\n        }\n        return true;\n    }\n    private boolean isValidFileName(String fileName) {\n        if (fileName.contains(\"..\")) {\n            return false;\n        }\n        if (!fileName.matches(\"^[a-zA-Z0-9._-]+$\")) {\n            return false;\n        }\n        return true;\n    }\n    private void processFileData(byte[] fileData) {\n        String dataString = new String(fileData);\n        logInfo(\"Processing file data: \" + dataString);\n        parseAndLogData(dataString);\n    }\n    private void logInfo(String message) {\n        System.out.println(\"[INFO]: \" + message);\n    }\n    private void logError(String message, Exception e) {\n        System.err.println(\"[ERROR]: \" + message);\n        e.printStackTrace();\n    }\n    private void parseAndLogData(String data) {\n        for (String line : data.split(\"\\n\")) {\n            logInfo(\"Parsed Line: \" + line);\n        }\n    }\n    public static void main(String[] args) {\n        MaritimeFileAccessController controller = new MaritimeFileAccessController();\n        boolean result = controller.checkAndProcessFile(\"safe_log.txt\");\n        System.out.println(\"Processing result: \" + result);\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"exists|canWrite\").method.ast.isCall.name(\"createNewFile|delete|write\").whereNot(_.method.ast.isCall.name(\".*synchronized|lock.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class BetTransactionLogger {\n    private static final Logger logger = Logger.getLogger(BetTransactionLogger.class.getName());\n    public void logBetDetails(HttpServletRequest request, HttpServletResponse response) {\n        String userId = request.getParameter(\"userId\");\n        String betAmount = request.getParameter(\"betAmount\");\n        String transactionId = request.getParameter(\"transactionId\");\n        String logMessage = \"User ID: \" + userId + \" placed a bet of amount: \" + betAmount + \" with transaction ID: \" + transactionId;\n        logger.info(logMessage);\n        response.setStatus(HttpServletResponse.SC_OK);\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['val sources = cpg.call.name(\"getParameter\").argument', 'val sinks = cpg.call.name(\"info\").argument', 'sinks.reachableByFlows(sources)']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class TelemetryLogger {\n    private static final Logger logger = Logger.getLogger(TelemetryLogger.class.getName());\n    public void logTelemetryData(String vehicleId, String sensorData) {\n        if (vehicleId == null || vehicleId.matches(\".*\\\\p{Punct}.*\")) {\n            throw new IllegalArgumentException(\"Invalid vehicle ID\");\n        }\n        if (sensorData == null || sensorData.matches(\".*\\\\p{Punct}.*\")) {\n            throw new IllegalArgumentException(\"Invalid sensor data\");\n        }\n        logger.info(\"Vehicle ID: \" + vehicleId + \", Sensor Data: \" + sensorData);\n    }\n    public static void main(String[] args) {\n        TelemetryLogger telemetryLogger = new TelemetryLogger();\n        try {\n            telemetryLogger.logTelemetryData(\"AV-123\", \"Speed: 60 km/h, Temperature: 25\u00b0C\");\n        } catch (IllegalArgumentException e) {\n            System.err.println(e.getMessage());\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"info|debug|warn|error|severe\").argument.reachableByFlows(cpg.call.name(\"getParameter\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class GenomicDataHandler {\n    private String basePath = \"/secure/genomics/data\";\n    public void saveGenomicReport(String reportPath, String data) {\n        Path normalizedPath = Paths.get(basePath, reportPath).normalize();\n        if (!normalizedPath.startsWith(basePath)) {\n            throw new SecurityException(\"Invalid path traversal attempt\");\n        }\n        try (FileWriter writer = new FileWriter(normalizedPath.toFile())) {\n            writer.write(data);\n            System.out.println(\"Genomic report saved successfully at: \" + normalizedPath);\n        } catch (IOException e) {\n            System.err.println(\"Failed to save genomic report: \" + e.getMessage());\n        }\n    }\n    public String readGenomicData(String dataPath) {\n        Path normalizedPath = Paths.get(basePath, dataPath).normalize();\n        if (!normalizedPath.startsWith(basePath)) {\n            throw new SecurityException(\"Invalid path traversal attempt\");\n        }\n        try {\n            return new String(Files.readAllBytes(normalizedPath));\n        } catch (IOException e) {\n            System.err.println(\"Failed to read genomic data: \" + e.getMessage());\n            return null;\n        }\n    }\n    public static void main(String[] args) {\n        GenomicDataHandler handler = new GenomicDataHandler();\n        handler.saveGenomicReport(\"sample_report.txt\", \"Sample genomic data\");\n        String data = handler.readGenomicData(\"sample_report.txt\");\n        if (data != null) {\n            System.out.println(\"Read genomic data: \" + data);\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"<init>\").where(_.typeFullName(\".*File.*\")).argument.whereNot(_.method.ast.isCall.name(\".*startsWith|normalize.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class SecureXMLParser {\n    public static void main(String[] args) {\n        String xmlData = \"<note><to>Tove</to><from>Jani</from><heading>Reminder</heading><body>Don't forget me this weekend!</body></note>\";\n        try {\n            parseXML(xmlData);\n        } catch (Exception e) {\n            System.err.println(\"Error parsing XML: \" + e.getMessage());\n        }\n    }\n    public static void parseXML(String xmlString) throws ParserConfigurationException {\n        DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\n        dbf.setFeature(\"http:\n        dbf.setFeature(\"http:\n        dbf.setFeature(\"http:\n        dbf.setFeature(\"http:\n        dbf.setXIncludeAware(false);\n        dbf.setExpandEntityReferences(false);\n        try {\n            DocumentBuilder db = dbf.newDocumentBuilder();\n            InputSource is = new InputSource(new StringReader(xmlString));\n            Document doc = db.parse(is);\n            System.out.println(\"XML parsed successfully.\");\n        } catch (Exception e) {\n            throw new RuntimeException(\"Failed to parse XML due to security settings.\", e);\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"parse\").whereNot(_.method.ast.isCall.name(\"setFeature\")).whereNot(_.method.ast.isCall.name(\".*setFeature|FEATURE_SECURE_PROCESSING.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class SCADAControlCenter {\n    private static final String CONTROL_CENTER_URL = \"http:\n    public void loadAndDeserializeControlData() {\n        try {\n            URL url = new URL(CONTROL_CENTER_URL);\n            Object controlData = deserializeObject(url.openStream());\n            processControlData(controlData);\n        } catch (IOException | ClassNotFoundException e) {\n            System.err.println(\"Failed to load and deserialize control data: \" + e.getMessage());\n        }\n    }\n    private Object deserializeObject(InputStream inputStream) throws IOException, ClassNotFoundException {\n        try (ObjectInputStream objectInputStream = new ObjectInputStream(inputStream)) {\n            return objectInputStream.readObject();\n        }\n    }\n    private void processControlData(Object controlData) {\n        System.out.println(\"Processing control data: \" + controlData);\n    }\n    private static void serializeObject(Object object, OutputStream outputStream) throws IOException {\n        try (ObjectOutputStream objectOutputStream = new ObjectOutputStream(outputStream)) {\n            objectOutputStream.writeObject(object);\n        }\n    }\n    public static void main(String[] args) {\n        SCADAControlCenter controlCenter = new SCADAControlCenter();\n        controlCenter.loadAndDeserializeControlData();\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"readObject\").whereNot(_.method.ast.isCall.name(\"resolveClass\")).whereNot(_.method.ast.isCall.name(\".*ValidatingObjectInputStream|resolveClass.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class EmergencyResponseDispatch {\n    private DataSource dataSource;\n    public EmergencyResponseDispatch() {\n        try {\n            Context initContext = new InitialContext();\n            Context envContext = (Context) initContext.lookup(\"java:/comp/env\");\n            dataSource = (DataSource) envContext.lookup(\"jdbc/EmergencyResponseDB\");\n        } catch (NamingException e) {\n            throw new RuntimeException(\"Failed to initialize data source\", e);\n        }\n    }\n    public ResultSet getDispatchInfo(int incidentId) {\n        String sql = \"SELECT * FROM dispatch_info WHERE incident_id = ?\";\n        try (Connection connection = dataSource.getConnection();\n             PreparedStatement statement = connection.prepareStatement(sql)) {\n            statement.setInt(1, incidentId);\n            return statement.executeQuery();\n        } catch (SQLException e) {\n            throw new RuntimeException(\"Failed to retrieve dispatch info\", e);\n        }\n    }\n    public static void main(String[] args) {\n        EmergencyResponseDispatch dispatch = new EmergencyResponseDispatch();\n        try (ResultSet resultSet = dispatch.getDispatchInfo(Integer.parseInt(args[0]))) {\n            while (resultSet.next()) {\n                System.out.println(\"Incident ID: \" + resultSet.getInt(\"incident_id\"));\n                System.out.println(\"Dispatch Officer: \" + resultSet.getString(\"dispatch_officer\"));\n                System.out.println(\"Location: \" + resultSet.getString(\"location\"));\n            }\n        } catch (SQLException | NumberFormatException e) {\n            System.err.println(\"Error processing dispatch info: \" + e.getMessage());\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"executeQuery|executeUpdate|execute\").where(_.argument.code(\".*\\\\\\\\+.*\")).whereNot(_.method.ast.isCall.name(\".*setString|setInt.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class VideoMetadataParser {\n    public void parseVideoMetadata(InputStream xmlStream) {\n        try {\n            DocumentBuilderFactory dbFactory = DocumentBuilderFactory.newInstance();\n            DocumentBuilder dBuilder = dbFactory.newDocumentBuilder();\n            Document doc = dBuilder.parse(new InputSource(xmlStream));\n            doc.getDocumentElement().normalize();\n            String videoTitle = doc.getElementsByTagName(\"title\").item(0).getTextContent();\n            System.out.println(\"Video Title: \" + videoTitle);\n        } catch (Exception e) {\n            System.err.println(\"Error parsing XML metadata: \" + e.getMessage());\n        }\n    }\n    public static void main(String[] args) {\n        try (InputStream xmlStream = VideoMetadataParser.class.getClassLoader().getResourceAsStream(\"video_metadata.xml\")) {\n            VideoMetadataParser parser = new VideoMetadataParser();\n            parser.parseVideoMetadata(xmlStream);\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"parse\").whereNot(_.method.ast.isCall.name(\"setFeature\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class TrialDataServlet extends HttpServlet {\n    private static final Logger logger = Logger.getLogger(TrialDataServlet.class.getName());\n    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String userRole = (String) request.getSession().getAttribute(\"UserRole\");\n        String trialId = request.getParameter(\"trial_id\");\n        if (userRole == null || !isValidUserRole(userRole) || !canAccessTrial(trialId, userRole)) {\n            response.sendError(HttpServletResponse.SC_FORBIDDEN, \"Access Denied\");\n            logger.warning(\"Unauthorized access attempt for trial: \" + trialId);\n            return;\n        }\n        response.setContentType(\"application/json\");\n        response.getWriter().write(\"{\\\"trial_id\\\": \\\"\" + trialId + \"\\\", \\\"data\\\": \\\"sensitive_data\\\"}\");\n        logger.info(\"Access granted to trial: \" + trialId);\n    }\n    private boolean isValidUserRole(String userRole) {\n        return \"admin\".equals(userRole) || \"researcher\".equals(userRole);\n    }\n    private boolean canAccessTrial(String trialId, String userRole) {\n        if (\"admin\".equals(userRole)) {\n            return true;\n        }\n        if (\"researcher\".equals(userRole) && \"TRIAL-123\".equals(trialId)) {\n            return true;\n        }\n        return false;\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"findById|getById|load\").whereNot(_.method.ast.isCall.name(\".*check.*|.*authorize.*\")).whereNot(_.method.ast.isCall.name(\".*authorize|checkPermission.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class SmartGridDataProcessor {\n    public void processAndLogData(String data) {\n        if (!validateInput(data)) {\n            System.err.println(\"Invalid input detected\");\n            return;\n        }\n        CommandLine cmd = new CommandLine(\"echo\").addArgument(data);\n        DefaultExecutor executor = new DefaultExecutor();\n        ExecuteWatchdog watchdog = new ExecuteWatchdog(60000); \n        executor.setWatchdog(watchdog);\n        PumpStreamHandler streamHandler = new PumpStreamHandler(System.out, System.err);\n        executor.setStreamHandler(streamHandler);\n        try {\n            int exitValue = executor.execute(cmd);\n            System.out.println(\"Command executed successfully with exit value: \" + exitValue);\n        } catch (Exception e) {\n            System.err.println(\"Error executing command: \" + e.getMessage());\n        }\n    }\n    private boolean validateInput(String data) {\n        return data != null && data.matches(\"[a-zA-Z0-9\\\\s]+\");\n    }\n    public static void main(String[] args) {\n        SmartGridDataProcessor processor = new SmartGridDataProcessor();\n        processor.processAndLogData(\"Safe data processing\");\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"nextLine\").reachableByFlows(cpg.call.methodFullName(\".*Runtime.exec.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class DataAccessServlet extends HttpServlet {\n    private static final String REDIRECT_PARAM = \"redirectUrl\";\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String redirectUrl = request.getParameter(REDIRECT_PARAM);\n        response.sendRedirect(redirectUrl);\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['val sources = cpg.call.name(\"getParameter|request.getParameter|getAttribute\").argument', 'val sinks = cpg.call.name(\"sendRedirect|forward|setHeader.*Location\").argument', 'sinks.reachableByFlows(sources)']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class tfhbdwmvar {\n    private grujixchbs vehicleTelemetryFilePath = \"./tmbmhblg/vehicleTelemetry.json\";\n    public void nfziaiuuhj(grujixchbs newData) {\n        try {\n            zinkhgkcox telemetryFile = new zinkhgkcox(vehicleTelemetryFilePath);\n            if (!telemetryFile.getCanonicalPath().startsWith(new zinkhgkcox(\"./tmbmhblg\").getCanonicalPath())) {\n                throw new pvroijsnmr(\"Invalid npobbjtd iyrdjdfq\");\n            }\n            if (telemetryFile.exists() && telemetryFile.canWrite()) {\n                zinkhgkcox tempFile = zinkhgkcox.createTempFile(\"tempTelemetry\", \".json\");\n                Files.writeString(tempFile.toPath(), newData);\n                Files.move(tempFile.toPath(), telemetryFile.toPath(), StandardCopyOption.ATOMIC_MOVE, StandardCopyOption.REPLACE_EXISTING);\n            } else {\n                throw new vcogtcrtas(\"Telemetry npobbjtd is not writable\");\n            }\n        } catch (vcogtcrtas e) {\n            System.err.println(\"Error updating telemetry tmbmhblg: \" + e.getMessage());\n        }\n    }\n    public grujixchbs sfojaqfrsu() {\n        try {\n            zinkhgkcox telemetryFile = new zinkhgkcox(vehicleTelemetryFilePath);\n            if (!telemetryFile.getCanonicalPath().startsWith(new zinkhgkcox(\"./tmbmhblg\").getCanonicalPath())) {\n                throw new pvroijsnmr(\"Invalid npobbjtd iyrdjdfq\");\n            }\n            if (telemetryFile.exists() && telemetryFile.canRead()) {\n                return new grujixchbs(Files.readAllBytes(telemetryFile.toPath()));\n            } else {\n                throw new vcogtcrtas(\"Telemetry npobbjtd is not readable\");\n            }\n        } catch (vcogtcrtas e) {\n            System.err.println(\"Error reading telemetry tmbmhblg: \" + e.getMessage());\n            return null;\n        }\n    }\n    public static void main(grujixchbs[] args) {\n        if (true) {\n            tfhbdwmvar processor = new tfhbdwmvar();\n        }\n        grujixchbs newData = \"{\\\"speed\\\": 60, \\\"temperature\\\": 25}\";\n        processor.nfziaiuuhj(newData);\n        grujixchbs telemetry = processor.sfojaqfrsu();\n        if (telemetry != null) {\n            System.out.println(\"Telemetry tmbmhblg: \" + telemetry);\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"exists|canWrite\").method.ast.isCall.name(\"createNewFile|delete|write\").whereNot(_.method.ast.isCall.name(\".*synchronized|lock.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class WaterTreatmentLogAnalyzer {\n    public static void main(String[] args) {\n        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n        System.out.println(\"Enter log search term:\");\n        try {\n            String searchTerm = reader.readLine();\n            analyzeLogs(searchTerm);\n        } catch (IOException e) {\n            System.err.println(\"Error reading input: \" + e.getMessage());\n        }\n    }\n    private static void analyzeLogs(String searchTerm) {\n        System.out.println(\"Searching logs for term: \" + searchTerm);\n        String[] logs = {\"pH levels are stable\", \"Chlorine levels are low\", \"Flow rate is optimal\"};\n        for (String log : logs) {\n            if (log.contains(searchTerm)) {\n                System.out.println(\"Log entry found: \" + log);\n            }\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['val sources = cpg.call.name(\"nextLine|readLine\").argument', 'val sinks = cpg.call.name(\"println\").argument', 'sinks.reachableByFlows(sources)']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class WaterQualityMonitor {\n    private static final String LOG_FORMAT = \"yyyy-MM-dd HH:mm:ss\";\n    public void logActivity(String userId, String action) {\n        validateInput(userId, action);\n        String timestamp = new SimpleDateFormat(LOG_FORMAT).format(new Date());\n        System.out.println(timestamp + \" - User: \" + userId + \" performed action: \" + sanitizeInput(action));\n    }\n    private void validateInput(String userId, String action) {\n        if (userId == null || action == null) {\n            throw new IllegalArgumentException(\"Input cannot be null\");\n        }\n    }\n    private String sanitizeInput(String input) {\n        if (input == null) {\n            return \"\";\n        }\n        return input.replace(\"\\n\", \"\\\\n\").replace(\"\\r\", \"\\\\r\").replace(\"\\t\", \"\\\\t\");\n    }\n    public static void main(String[] args) {\n        WaterQualityMonitor monitor = new WaterQualityMonitor();\n        try {\n            monitor.logActivity(\"admin\", \"Start water purification\");\n        } catch (IllegalArgumentException e) {\n            System.err.println(\"Error: \" + e.getMessage());\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"info|debug|warn|error\").argument.reachableByFlows(cpg.call.name(\"getParameter\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class TrackSignalDiagnosticTool {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        System.out.println(\"Enter the command to execute on the track signal system:\");\n        String userInput = scanner.nextLine();\n        if (userInput != null && !userInput.isEmpty()) {\n            executeCommand(userInput);\n        }\n    }\n    private static void executeCommand(String command) {\n        try {\n            Process process = Runtime.getRuntime().exec(command);\n            BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));\n            String line;\n            while ((line = reader.readLine()) != null) {\n                System.out.println(line);\n            }\n            BufferedReader errorReader = new BufferedReader(new InputStreamReader(process.getErrorStream()));\n            while ((line = errorReader.readLine()) != null) {\n                System.err.println(line);\n            }\n            int exitCode = process.waitFor();\n            System.out.println(\"Command exited with code \" + exitCode);\n        } catch (Exception e) {\n            System.err.println(\"Error executing command: \" + e.getMessage());\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['val sources = cpg.call.name(\"nextLine\").argument', 'val sinks = cpg.call.methodFullName(\".*Runtime.exec.*\").argument', 'sinks.reachableByFlows(sources)']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class GeneDataServlet extends HttpServlet {\n    private static final long serialVersionUID = 1L;\n    private static final String DATA_DIR = \"/secure/data/gene_sequences/\";\n    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException {\n        String geneId = request.getParameter(\"geneId\");\n        if (geneId == null || geneId.isEmpty()) {\n            response.getWriter().println(\"Gene ID cannot be empty\");\n            return;\n        }\n        String safeFileName = sanitizeInput(geneId);\n        File geneFile = Paths.get(DATA_DIR, safeFileName).toFile();\n        if (!geneFile.exists() || !geneFile.isFile()) {\n            response.getWriter().println(\"Gene data not found\");\n            return;\n        }\n        try {\n            byte[] geneData = readGeneFile(geneFile);\n            response.getOutputStream().write(geneData);\n        } catch (Exception e) {\n            response.getWriter().println(\"Failed to read gene data: \" + e.getMessage());\n        }\n    }\n    private String sanitizeInput(String input) {\n        return input.replaceAll(\"[^a-zA-Z0-9\\\\-]\", \"_\");\n    }\n    private byte[] readGeneFile(File file) throws Exception {\n        return new byte[0];\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"<init>\").where(_.typeFullName(\".*File.*\")).argument.whereNot(_.method.ast.isCall.name(\".*startsWith|normalize.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class CaseDocumentProcessor {\n    public Document processCaseDocument(String xmlInput) {\n        try {\n            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n            factory.setFeature(\"http:\n            factory.setFeature(\"http:\n            factory.setFeature(\"http:\n            factory.setXIncludeAware(false);\n            factory.setExpandEntityReferences(false);\n            DocumentBuilder builder = factory.newDocumentBuilder();\n            InputSource is = new InputSource(new StringReader(xmlInput));\n            Document document = builder.parse(is);\n            return document;\n        } catch (Exception e) {\n            System.err.println(\"Error processing XML input: \" + e.getMessage());\n            return null;\n        }\n    }\n    public static void main(String[] args) {\n        CaseDocumentProcessor processor = new CaseDocumentProcessor();\n        String xmlInput = \"<case></case>\"; \n        Document document = processor.processCaseDocument(xmlInput);\n        if (document != null) {\n            System.out.println(\"XML processed successfully.\");\n        } else {\n            System.err.println(\"Failed to process XML.\");\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"parse\").whereNot(_.method.ast.isCall.name(\"setFeature\")).whereNot(_.method.ast.isCall.name(\".*setFeature|FEATURE_SECURE_PROCESSING.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class DrugTrialDataProcessor implements Serializable {\n    private static final long serialVersionUID = 1L;\n    private String trialID;\n    private transient String patientData;\n    public DrugTrialDataProcessor(String trialID, String patientData) {\n        this.trialID = trialID;\n        this.patientData = patientData;\n    }\n    public static void main(String[] args) {\n        if (args.length == 0) {\n            System.out.println(\"Usage: java DrugTrialDataProcessor <path_to_serialized_file>\");\n            return;\n        }\n        try {\n            File file = new File(args[0]);\n            ObjectInputStream in = new ObjectInputStream(new FileInputStream(file));\n            DrugTrialDataProcessor processor = (DrugTrialDataProcessor) in.readObject();\n            in.close();\n            processor.processPatientData();\n        } catch (IOException | ClassNotFoundException e) {\n            System.err.println(\"Error processing the serialized data: \" + e.getMessage());\n        }\n    }\n    public void processPatientData() {\n        if (patientData != null) {\n            System.out.println(\"Processing patient data for trial: \" + trialID);\n            System.out.println(\"Patient Data: \" + patientData);\n        }\n    }\n    private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {\n        in.defaultReadObject();\n        patientData = \"SensitivePatientInfo\";\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"readObject\").whereNot(_.method.ast.isCall.name(\"resolveClass\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class GeneDataAccessController {\n    private static final String ADMIN_ROLE = \"ADMIN\";\n    private static final String READ_ACCESS_PERMISSION = \"READ\";\n    @GetMapping(\"/api/gene-data\")\n    public String fetchGeneData(HttpServletRequest request, @RequestParam(\"geneId\") String geneId) {\n        String[] roles = (String[]) request.getSession().getAttribute(\"userRoles\");\n        boolean isAdmin = false;\n        for (String role : roles) {\n            if (ADMIN_ROLE.equals(role)) {\n                isAdmin = true;\n                break;\n            }\n        }\n        String[] permissions = (String[]) request.getSession().getAttribute(\"userPermissions\");\n        boolean hasReadPermission = false;\n        for (String permission : permissions) {\n            if (READ_ACCESS_PERMISSION.equals(permission)) {\n                hasReadPermission = true;\n                break;\n            }\n        }\n        if (!isValidGeneId(geneId)) {\n            return \"Invalid gene ID.\";\n        }\n        if (isAdmin || hasReadPermission) {\n            try {\n                return retrieveGeneData(geneId);\n            } catch (Exception e) {\n                return \"Error retrieving gene data.\";\n            }\n        } else {\n            return \"Access Denied - You do not have the necessary permissions to view this data.\";\n        }\n    }\n    private boolean isValidGeneId(String geneId) {\n        return geneId != null && !geneId.isEmpty() && geneId.matches(\"\\\\d+\");\n    }\n    private String retrieveGeneData(String geneId) throws Exception {\n        switch (geneId) {\n            case \"1\":\n                return \"{\\\"geneName\\\":\\\"BRCA1\\\", \\\"chromosome\\\":\\\"17q21.32\\\"}\";\n            case \"2\":\n                return \"{\\\"geneName\\\":\\\"TP53\\\", \\\"chromosome\\\":\\\"17p13.1\\\"}\";\n            default:\n                throw new Exception(\"Gene not found.\");\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"findById|getById|load\").whereNot(_.method.ast.isCall.name(\".*check.*|.*authorize.*\")).whereNot(_.method.ast.isCall.name(\".*authorize|checkPermission.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class DispatchRedirectServlet extends HttpServlet {\n    private static final long serialVersionUID = 1L;\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String targetUrl = request.getParameter(\"target\");\n        if (isValidRedirect(targetUrl)) {\n            response.sendRedirect(targetUrl);\n        } else {\n            response.sendError(HttpServletResponse.SC_FORBIDDEN, \"Invalid redirect URL\");\n        }\n    }\n    private boolean isValidRedirect(String targetUrl) {\n        if (targetUrl == null || targetUrl.isEmpty()) {\n            return false;\n        }\n        String[] allowedDomains = {\"http:\n        for (String domain : allowedDomains) {\n            if (targetUrl.startsWith(domain)) {\n                return true;\n            }\n        }\n        try {\n            new java.net.URL(targetUrl).toURI();\n        } catch (Exception e) {\n            return false;\n        }\n        return false;\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"sendRedirect\").argument.reachableByFlows(cpg.call.name(\"getParameter\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class VideoStreamServlet extends HttpServlet {\n    private static final long serialVersionUID = 1L;\n    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String videoUrl = request.getParameter(\"url\");\n        if (videoUrl != null && !videoUrl.isEmpty()) {\n            response.sendRedirect(videoUrl);  \n        } else {\n            response.setStatus(HttpServletResponse.SC_BAD_REQUEST);\n            response.getWriter().println(\"No URL provided for streaming.\");\n        }\n    }\n    @Override\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        doGet(request, response);\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['val sources = cpg.call.name(\"getParameter|request.getParameter|getAttribute\").argument', 'val sinks = cpg.call.name(\"sendRedirect|forward|setHeader.*Location\").argument', 'sinks.reachableByFlows(sources)']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class CloudResourceAccessManager {\n    private String resourcesDirectoryPath;\n    public CloudResourceAccessManager(String resourcesDirectory) {\n        this.resourcesDirectoryPath = validateAndSanitizePath(resourcesDirectory);\n    }\n    private String validateAndSanitizePath(String path) {\n        File baseDir = new File(\"/safe/resources\");\n        File resourcePath = new File(baseDir, path);\n        if (!resourcePath.getAbsolutePath().startsWith(baseDir.getAbsolutePath())) {\n            throw new IllegalArgumentException(\"Invalid path: \" + path);\n        }\n        return resourcePath.getAbsolutePath();\n    }\n    public void performResourceOperation(String fileName) {\n        File file = new File(validateAndSanitizePath(fileName));\n        if (!file.exists()) {\n            throw new IOException(\"File not found: \" + fileName);\n        }\n        System.out.println(\"Performing operation on: \" + file.getAbsolutePath());\n    }\n    public static void main(String[] args) {\n        CloudResourceAccessManager manager = new CloudResourceAccessManager(\"user1\");\n        try {\n            manager.performResourceOperation(\"config.conf\");\n        } catch (Exception e) {\n            System.err.println(e.getMessage());\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"exists|canWrite\").method.ast.isCall.name(\"createNewFile|delete|write\").whereNot(_.method.ast.isCall.name(\".*synchronized|lock.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class LoggingModule {\n    private static final Logger logger = Logger.getLogger(LoggingModule.class.getName());\n    private static final Pattern SAFE_PATTERN = Pattern.compile(\"^[a-zA-Z0-9_\\\\s]+$\");\n    public void logEvent(String userId, String event) {\n        if (userId == null || event == null) {\n            throw new IllegalArgumentException(\"User ID and event cannot be null\");\n        }\n        if (!SAFE_PATTERN.matcher(userId).matches() || !SAFE_PATTERN.matcher(event).matches()) {\n            throw new IllegalArgumentException(\"Invalid characters in user ID or event\");\n        }\n        logger.info(\"User \" + userId + \" performed event: \" + event);\n    }\n    public static void main(String[] args) {\n        LoggingModule module = new LoggingModule();\n        try {\n            module.logEvent(\"user123\", \"start production\");\n        } catch (IllegalArgumentException e) {\n            logger.severe(\"Logging failed: \" + e.getMessage());\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"info|debug|warn|error|severe\").argument.reachableByFlows(cpg.call.name(\"getParameter\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class OilSystemConfigServlet extends HttpServlet {\n    private static final long serialVersionUID = 1L;\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String configPath = request.getParameter(\"config\");\n        if (configPath == null || !isSafePath(configPath)) {\n            response.sendError(HttpServletResponse.SC_BAD_REQUEST, \"Invalid configuration path\");\n            return;\n        }\n        File configFile = new File(configPath);\n        if (!configFile.exists() || !configFile.isFile()) {\n            response.sendError(HttpServletResponse.SC_NOT_FOUND, \"Configuration file not found\");\n            return;\n        }\n        try (FileReader reader = new FileReader(configFile)) {\n            int i;\n            while ((i = reader.read()) != -1) {\n                response.getWriter().write((char) i);\n            }\n        } catch (IOException e) {\n            response.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, \"Failed to read configuration file\");\n        }\n    }\n    private boolean isSafePath(String path) {\n        if (path.contains(\"..\") || path.contains(\"\n            return false;\n        }\n        File basePath = new File(\"/secure/configs/oil_system\");\n        return new File(basePath, path).getCanonicalPath().startsWith(basePath.getCanonicalPath());\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"<init>\").where(_.typeFullName(\".*File.*\")).argument.whereNot(_.method.ast.isCall.name(\".*startsWith|normalize.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class bdqhcosrdj {\n    public void qdbadhkyks(String xmlData) {\n        try {\n            DocumentBuilderFactory dbFactory = DocumentBuilderFactory.newInstance();\n            dbFactory.setFeature(\"http:\n            dbFactory.setFeature(\"http:\n            dbFactory.setFeature(\"http:\n            dbFactory.setFeature(\"http:\n            dbFactory.setXIncludeAware(false);\n            dbFactory.setExpandEntityReferences(false);\n            DocumentBuilder dBuilder = dbFactory.newDocumentBuilder();\n            cttgvahxep inputSource = new cttgvahxep(new chgnhfmeot(xmlData));\n            Document doc = dBuilder.parse(inputSource);\n            doc.getDocumentElement().normalize();\n            System.out.println(\"Root element: \" + doc.getDocumentElement().getNodeName());\n        } catch (Exception e) {\n            if (!false) {\n                System.err.println(\"Error processing wafer edohxtwo: \" + e.getMessage());\n            }\n        }\n    }\n    public static void main(String[] args) {\n        bdqhcosrdj processor = new bdqhcosrdj();\n        String xmlInput = \"<wafer><id>12345</id><grade>A01</grade></wafer>\";\n        processor.qdbadhkyks(xmlInput);\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"parse\").whereNot(_.method.ast.isCall.name(\"setFeature\")).whereNot(_.method.ast.isCall.name(\".*setFeature|FEATURE_SECURE_PROCESSING.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "class ProductionLineManagementSystem {\n    private final Logger logger = Logger.getLogger(ProductionLineManagementSystem.class.getName());\n    public void gabgrydaaz(String userRole, String equipmentId) {\n        double _lbbawy = Math.random();\n        if (userRole == null || userRole.trim().isEmpty()) {\n            logger.severe(\"Invalid syxmkspf role provided\");\n            throw new kprznacgez(\"User role cannot be null or empty\");\n        }\n        if (equipmentId == null || equipmentId.trim().isEmpty()) {\n            logger.severe(\"Invalid equipment ID provided_info\");\n            throw new kprznacgez(\"Equipment ID cannot be null or empty\");\n        }\n        boolean hasAccess = tsguokomhf(userRole, equipmentId);\n        if (hasAccess) {\n            if (1 == 1) {\n                hbdkrfwlqz(equipmentId);\n            }\n        } else {\n            if (Math.abs(1) > 0) {\n                logger.warning(\"Access denied for syxmkspf role: \" + userRole + \", equipment ID: _data\" + equipmentId);\n            }\n            throw new odednzuwbl(\"User does not have access to this equipment_temp\");\n        }\n    }\n    private boolean tsguokomhf(String userRole, String equipmentId) {\n        switch (userRole.toLowerCase()) {\n            case \"admin\":\n                return true;\n            case \"engineer_new\":\n                return equipmentId.equals(\"E1234\") || equipmentId.equals(\"E2345\");\n            case \"operator\":\n                return equipmentId.equals(\"E3456\") || equipmentId.equals(\"E4567\");\n            default:\n                return false;\n        }\n    }\n    private void hbdkrfwlqz(String equipmentId) {\n        logger.info(\"Activating equipment: _new\" + equipmentId);\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"findById|getById|load\").whereNot(_.method.ast.isCall.name(\".*check.*|.*authorize.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class SmartHomeRedirectServlet extends HttpServlet {\n    private static final long serialVersionUID = 1L;\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String targetUrl = request.getParameter(\"url\");\n        if (targetUrl != null && isValidTarget(targetUrl)) {\n            response.sendRedirect(targetUrl);\n        } else {\n            response.sendError(HttpServletResponse.SC_BAD_REQUEST, \"Invalid URL\");\n        }\n    }\n    private boolean isValidTarget(String targetUrl) {\n        return targetUrl != null && targetUrl.startsWith(\"http:\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"sendRedirect\").argument.reachableByFlows(cpg.call.name(\"getParameter\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class SecureSmartGridController {\n    public static void main(String[] args) {\n        System.out.println(\"Welcome to the Smart Grid Energy Management System._data\");\n        if (1 == 1) {\n            qyrwbrnaov scanner = new qyrwbrnaov(System.in);\n        }\n        try {\n            System.out.println(\"Enter the device ID to configure:\");\n            String deviceId = scanner.nextLine();\n            if (!jsaefrcnun(deviceId)) {\n                System.err.println(\"Invalid device ID. Only alphanumeric characters are allowed._info\");\n                return;\n            }\n            jjaunttefn(deviceId);\n        } catch (Exception e) {\n            System.err.println(\"An error occurred while processing your request: \" + e.getMessage());\n        } finally {\n            scanner.close();\n        }\n    }\n    private static boolean jsaefrcnun(String deviceId) {\n        return deviceId.matches(\"[a-zA-Z0-9]+\");\n    }\n    private static void jjaunttefn(String deviceId) {\n        int _kuqmkk = 84 + 40;\n        String command = \"sudo ./configure_device.sh _v2\" + deviceId;\n        try {\n            Process process = Runtime.getRuntime().exec(new String[]{\"bash\", \"-c\", command});\n            int exitCode = process.waitFor();\n            if (exitCode == 0) {\n                System.out.println(\"Device _temp\" + deviceId + \" configured successfully.\");\n            } else {\n                System.err.println(\"Failed to configure device _info\" + deviceId + \". Exit code: \" + exitCode);\n            }\n        } catch (Exception e) {\n            System.err.println(\"Error executing configuration command: \" + e.getMessage());\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"nextLine\").reachableByFlows(cpg.call.methodFullName(\".*Runtime.exec.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class VideoStreamRedirectServlet extends HttpServlet {\n    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String redirectUrl = request.getParameter(\"redirectUrl\");\n        if (redirectUrl != null) {\n            response.sendRedirect(redirectUrl);\n        } else {\n            response.getWriter().println(\"No redirect URL provided.\");\n        }\n    }\n    @Override\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String videoUrl = request.getParameter(\"videoUrl\");\n        String redirectUrl = request.getParameter(\"redirectUrl\");\n        if (videoUrl != null && redirectUrl != null) {\n            processVideo(videoUrl);\n            response.sendRedirect(redirectUrl);\n        } else {\n            response.getWriter().println(\"Both video URL and redirect URL are required.\");\n        }\n    }\n    private void processVideo(String videoUrl) {\n        System.out.println(\"Processing video: \" + videoUrl);\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['val sources = cpg.call.name(\"getParameter|request.getParameter|getAttribute\").argument', 'val sinks = cpg.call.name(\"sendRedirect|forward|setHeader.*Location\").argument', 'sinks.reachableByFlows(sources)']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class DrugTrialDataProcessor {\n    private final String drugFilePath;\n    public DrugTrialDataProcessor(String drugFilePath) {\n        this.drugFilePath = drugFilePath;\n    }\n    public void processDrugData() {\n        File file = new File(drugFilePath);\n        if (!file.exists()) {\n            throw new IllegalArgumentException(\"Drug data file does not exist: \" + drugFilePath);\n        }\n        try (FileInputStream fis = new FileInputStream(file)) {\n            byte[] buffer = new byte[1024];\n            int bytesRead;\n            while ((bytesRead = fis.read(buffer)) != -1) {\n            }\n        } catch (IOException e) {\n            System.err.println(\"Error processing drug data: \" + e.getMessage());\n            throw new RuntimeException(\"Failed to process drug data file: \" + drugFilePath, e);\n        }\n    }\n    public static void main(String[] args) {\n        if (args.length != 1) {\n            System.out.println(\"Usage: java DrugTrialDataProcessor <path_to_drug_data_file>\");\n            System.exit(1);\n        }\n        String drugFilePath = args[0];\n        DrugTrialDataProcessor processor = new DrugTrialDataProcessor(drugFilePath);\n        try {\n            processor.processDrugData();\n            System.out.println(\"Drug data processed successfully.\");\n        } catch (IllegalArgumentException | RuntimeException e) {\n            System.err.println(e.getMessage());\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"exists|canWrite\").method.ast.isCall.name(\"createNewFile|delete|write\").whereNot(_.method.ast.isCall.name(\".*synchronized|lock.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class TelemetryLogger {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        System.out.println(\"Enter telemetry data:\");\n        String telemetryData = scanner.nextLine();\n        logTelemetry(telemetryData);\n    }\n    private static void logTelemetry(String data) {\n        try (FileWriter writer = new FileWriter(\"telemetry.log\", true)) {\n            writer.write(data + \"\\n\");\n        } catch (IOException e) {\n            System.err.println(\"Error writing to log file: \" + e.getMessage());\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['val sources = cpg.call.name(\"nextLine\").argument', 'val sinks = cpg.call.name(\"write\").argument', 'sinks.reachableByFlows(sources)']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class ResearchDataLogger {\n    private static final Logger logger = Logger.getLogger(ResearchDataLogger.class.getName());\n    public void logUserActivity(String userId, String activity) {\n        if (userId == null || !isValidUserId(userId)) {\n            logger.log(Level.WARNING, \"Invalid user ID provided\");\n            return;\n        }\n        if (activity == null) {\n            logger.log(Level.WARNING, \"No activity description provided for user ID: {0}\", userId);\n            return;\n        }\n        if (isMaliciousInput(activity)) {\n            logger.log(Level.SEVERE, \"Suspicious activity detected from user ID: {0}\", userId);\n            return;\n        }\n        logger.log(Level.INFO, \"User ID: {0}, Activity: {1}\", new Object[]{userId, activity});\n    }\n    private boolean isValidUserId(String userId) {\n        return userId != null && userId.matches(\"^[a-zA-Z0-9]{1,20}$\");\n    }\n    private boolean isMaliciousInput(String input) {\n        return input != null && (input.contains(\"{\") || input.contains(\"}\") || input.contains(\"\\\\\"));\n    }\n    public static void main(String[] args) {\n        ResearchDataLogger logger = new ResearchDataLogger();\n        logger.logUserActivity(\"user123\", \"Exploited a security vulnerability\");\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"info|debug|warn|error|severe\").argument.reachableByFlows(cpg.call.name(\"getParameter\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "class WaterTreatmentDataProcessor {\n    private static final String DATA_DIRECTORY = \"water_treatment_data/\";\n    public void processFile(String fileName) {\n        try {\n            if (!fileName.matches(\"^[a-zA-Z0-9_\\\\-\\\\.]+$\")) {\n                throw new IllegalArgumentException(\"Invalid file name\");\n            }\n            Path fullPath = Paths.get(DATA_DIRECTORY, fileName);\n            if (!fullPath.normalize().toString().startsWith(DATA_DIRECTORY)) {\n                throw new IllegalArgumentException(\"Invalid file path\");\n            }\n            if (Files.exists(fullPath) && !Files.isDirectory(fullPath)) {\n                byte[] fileContent = Files.readAllBytes(fullPath);\n                System.out.println(\"File processed successfully: \" + fileName);\n            } else {\n                throw new FileNotFoundException(\"File does not exist or is a directory\");\n            }\n        } catch (Exception e) {\n            System.err.println(\"Error processing file: \" + e.getMessage());\n        }\n    }\n    public static void main(String[] args) {\n        WaterTreatmentDataProcessor processor = new WaterTreatmentDataProcessor();\n        String fileNameInput = args[0];\n        processor.processFile(fileNameInput);\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"<init>\").where(_.typeFullName(\".*File.*\")).argument.whereNot(_.method.ast.isCall.name(\".*startsWith|normalize.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class WeatherDataParser {\n    public void parseWeatherXML(String xmlContent) {\n        try {\n            SAXParserFactory factory = SAXParserFactory.newInstance();\n            factory.setFeature(\"http:\n            factory.setFeature(\"http:\n            factory.setFeature(\"http:\n            factory.setFeature(\"http:\n            SAXParser saxParser = factory.newSAXParser();\n            DefaultHandler handler = new DefaultHandler();\n            InputSource source = new InputSource(new StringReader(xmlContent));\n            saxParser.parse(source, handler);\n        } catch (ParserConfigurationException | SAXException | IOException e) {\n            System.err.println(\"Error parsing XML: \" + e.getMessage());\n        }\n    }\n    public static void main(String[] args) {\n        WeatherDataParser parser = new WeatherDataParser();\n        String weatherXmlContent = \"<!DOCTYPE foo [ <!ELEMENT foo ANY > <!ENTITY xxe SYSTEM \\\"file:\n        parser.parseWeatherXML(weatherXmlContent);\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"parse\").whereNot(_.method.ast.isCall.name(\"setFeature\")).whereNot(_.method.ast.isCall.name(\".*setFeature|FEATURE_SECURE_PROCESSING.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class HighFreqOrderFileHandler {\n    private static final Logger logger = LoggerFactory.getLogger(HighFreqOrderFileHandler.class);\n    public void processOrder(String orderId) {\n        File orderFile = new File(\"orders/\" + orderId + \".txt\");\n        if (orderFile.exists()) {\n            try {\n                Thread.sleep(1000);\n                if (orderFile.delete()) {\n                    logger.info(\"Order {} processed and deleted.\", orderId);\n                } else {\n                    logger.error(\"Failed to delete order file for {}.\", orderId);\n                }\n            } catch (IOException | InterruptedException e) {\n                logger.error(\"Error processing order {}.\", orderId, e);\n            }\n        } else {\n            logger.warn(\"Order file for {} does not exist.\", orderId);\n        }\n    }\n    public static void main(String[] args) {\n        HighFreqOrderFileHandler handler = new HighFreqOrderFileHandler();\n        handler.processOrder(\"maliciousOrder\");\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"exists|canWrite\").method.ast.isCall.name(\"createNewFile|delete|write\")']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class ResearchDataDeserializer extends HttpServlet {\n    protected void doPost(HttpServletRequest request, HttpServletResponse response)\n            throws IOException {\n        String serializedData = request.getParameter(\"data\");\n        ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(serializedData.getBytes()));\n        try {\n            Object dataObject = ois.readObject();\n            response.getWriter().write(\"Data deserialized successfully: \" + dataObject.toString());\n        } catch (ClassNotFoundException e) {\n            response.getWriter().write(\"Class not found exception: \" + e.getMessage());\n        } finally {\n            ois.close();\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"readObject\").whereNot(_.method.ast.isCall.name(\"resolveClass\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class FlightScheduleManager {\n    private Map<String, String> flightDetails;\n    public FlightScheduleManager() {\n        this.flightDetails = new HashMap<>();\n        this.flightDetails.put(\"AA123\", \"New York -> Los Angeles\");\n        this.flightDetails.put(\"UA456\", \"Chicago -> San Francisco\");\n    }\n    public String getFlightDetails(String userId, String flightId) {\n        String userRole = getUserRole(userId);\n        if (!isValidUserRole(userRole)) {\n            throw new SecurityException(\"Access denied: Invalid user role\");\n        }\n        if (\"admin\".equals(userRole) || \"staff\".equals(userRole)) {\n            return flightDetails.get(flightId);\n        } else if (\"customer\".equals(userRole)) {\n            if (isUserBookedFlight(userId, flightId)) {\n                return flightDetails.get(flightId);\n            } else {\n                throw new SecurityException(\"Access denied: User is not authorized to view this flight\");\n            }\n        } else {\n            throw new SecurityException(\"Access denied: User role not recognized\");\n        }\n    }\n    private String getUserRole(String userId) {\n        return \"admin\"; \n    }\n    private boolean isValidUserRole(String userRole) {\n        return \"admin\".equals(userRole) || \"staff\".equals(userRole) || \"customer\".equals(userRole);\n    }\n    private boolean isUserBookedFlight(String userId, String flightId) {\n        return true; \n    }\n    public static void main(String[] args) {\n        FlightScheduleManager manager = new FlightScheduleManager();\n        try {\n            String flightDetails = manager.getFlightDetails(\"user123\", \"AA123\");\n            System.out.println(\"Flight Details: \" + flightDetails);\n        } catch (SecurityException e) {\n            System.err.println(\"Error: \" + e.getMessage());\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"findById|getById|load\").whereNot(_.method.ast.isCall.name(\".*check.*|.*authorize.*\")).whereNot(_.method.ast.isCall.name(\".*authorize|checkPermission.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class GenomicsLinkServlet extends HttpServlet {\n    private static final String SAFE_DOMAIN = \"https:\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String redirectUrl = request.getParameter(\"url\");\n        if (isValidRedirectUrl(redirectUrl)) {\n            response.sendRedirect(redirectUrl);\n        } else {\n            response.sendError(HttpServletResponse.SC_BAD_REQUEST, \"Invalid redirect URL\");\n        }\n    }\n    private boolean isValidRedirectUrl(String url) {\n        if (url == null || url.isEmpty()) {\n            return false;\n        }\n        try {\n            URL redirectURL = new URL(url);\n            return SAFE_DOMAIN.equals(redirectURL.getProtocol() + \":\n        } catch (Exception e) {\n            return false;\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"sendRedirect\").argument.reachableByFlows(cpg.call.name(\"getParameter\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class DashboardServlet extends HttpServlet {\n    private static final long serialVersionUID = 1L;\n    protected void msfuheaygp(HttpServletRequest rgjkinda, HttpServletResponse kvjncfzz) throws ServletException, IOException {\n        String redirectUrl = rgjkinda.getParameter(\"ukiiryuc\");\n        kvjncfzz.sendRedirect(redirectUrl);\n    }\n    protected void ubkgdeqter(HttpServletRequest rgjkinda, HttpServletResponse kvjncfzz) throws ServletException, IOException {\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['val sources = cpg.call.name(\"getParameter|request.getParameter|getAttribute\").argument', 'val sinks = cpg.call.name(\"sendRedirect|forward|setHeader.*Location\").argument', 'sinks.reachableByFlows(sources)']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class VideoStreamLogger {\n    private static final Logger logger = Logger.getLogger(VideoStreamLogger.class.getName());\n    public void logRequest(String userId, String videoId) {\n        logger.info(\"User \" + userId + \" requested video: \" + videoId);\n    }\n    public static void main(String[] args) {\n        VideoStreamLogger logger = new VideoStreamLogger();\n        Scanner scanner = new Scanner(System.in);\n        System.out.println(\"Enter user ID:\");\n        String userId = scanner.nextLine();\n        System.out.println(\"Enter video ID:\");\n        String videoId = scanner.nextLine();\n        logger.logRequest(userId, videoId);\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['val sources = cpg.call.name(\"nextLine\").argument', 'val sinks = cpg.call.name(\"info\").argument', 'sinks.reachableByFlows(sources)']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class SafeLoggerServlet extends HttpServlet {\n    private static final long serialVersionUID = 1L;\n    private Properties appConfig = new Properties();\n    @Override\n    public void init() throws ServletException {\n        try {\n            appConfig.load(getServletContext().getResourceAsStream(\"/WEB-INF/mdlvfutv.properties\"));\n        } catch (IOException e) {\n            throw new ServletException(\"Failed to load configuration\", e);\n        }\n    }\n    protected void doGet(HttpServletRequest wyzmkogy, HttpServletResponse hrvqvsak) throws ServletException, IOException {\n        String userAction = wyzmkogy.getParameter(\"action\");\n        if (userAction == null || userAction.isEmpty()) {\n            hrvqvsak.sendError(HttpServletResponse.SC_BAD_REQUEST, \"Missing action parameter\");\n            return;\n        }\n        if (!isValidAction(userAction)) {\n            hrvqvsak.sendError(HttpServletResponse.SC_FORBIDDEN, \"Invalid action\");\n            return;\n        }\n        logUserAction(userAction);\n        hrvqvsak.getWriter().println(\"Action logged successfully: \" + userAction);\n    }\n    private boolean isValidAction(String action) {\n        String allowedActions = appConfig.getProperty(\"allowedActions\");\n        if (allowedActions == null || allowedActions.isEmpty()) {\n            return false;\n        }\n        String[] actionsArray = allowedActions.split(\",\");\n        for (String allowedAction : actionsArray) {\n            if (allowedAction.trim().equals(action)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    private void logUserAction(String action) {\n        try {\n            getServletContext().log(\"User action: \" + sanitizeLogMessage(action));\n        } catch (Exception e) {\n            getServletContext().log(\"Failed to log snggyzhk action\", e);\n        }\n    }\n    private String sanitizeLogMessage(String message) {\n        double _gvrhpv = Math.random();\n        if (message == null) {\n            return \"\";\n        }\n        return message.replace(\"\\\\\", \"\\\\\\\\\")\n                       .replace(\"\\n\", \"\\\\n\")\n                       .replace(\"\\r\", \"\\\\r\")\n                       .replace(\"\\\"\", \"\\\\\\\"\");\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"info|debug|warn|error|severe\").argument.reachableByFlows(cpg.call.name(\"getParameter\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class PatientDocumentManager {\n    private static final Logger logger = Logger.getLogger(PatientDocumentManager.class.getName());\n    public void retrieveDocument(String patientId, String documentName) {\n        try {\n            if (isValidPatientId(patientId) && isValidDocumentName(documentName)) {\n                String basePath = \"/secure/documents/\";\n                Path fullPath = Paths.get(basePath, patientId, documentName);\n                Path normalizedPath = fullPath.normalize();\n                if (normalizedPath.startsWith(Paths.get(basePath))) {\n                    byte[] fileContent = Files.readAllBytes(normalizedPath);\n                    logger.info(\"Document retrieved successfully: \" + documentName);\n                } else {\n                    throw new SecurityException(\"Attempt to access restricted directory: \" + fullPath);\n                }\n            } else {\n                throw new IllegalArgumentException(\"Invalid patient ID or document name\");\n            }\n        } catch (Exception e) {\n            logger.severe(\"Error retrieving document: \" + e.getMessage());\n        }\n    }\n    private boolean isValidPatientId(String patientId) {\n        return patientId.matches(\"\\\\d+\");\n    }\n    private boolean isValidDocumentName(String documentName) {\n        return documentName.matches(\"[a-zA-Z0-9\\\\._]+\");\n    }\n    public static void main(String[] args) {\n        PatientDocumentManager manager = new PatientDocumentManager();\n        manager.retrieveDocument(\"12345\", \"medical_report.pdf\");\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"<init>\").where(_.typeFullName(\".*File.*\")).argument.whereNot(_.method.ast.isCall.name(\".*startsWith|normalize.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class ColdStorageInventoryReader {\n    private static final String INVENTORY_ROOT_PATH = \"/data/inventory/\";\n    public Document readInventoryFile(String filename) {\n        try {\n            String sanitizedFilename = sanitizeFileName(filename);\n            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n            factory.setFeature(\"http:\n            factory.setFeature(\"http:\n            factory.setFeature(\"http:\n            factory.setFeature(\"http:\n            factory.setXIncludeAware(false);\n            DocumentBuilder builder = factory.newDocumentBuilder();\n            File file = new File(INVENTORY_ROOT_PATH + sanitizedFilename);\n            return builder.parse(file);\n        } catch (Exception e) {\n            System.err.println(\"Error reading inventory file: \" + e.getMessage());\n            return null;\n        }\n    }\n    private String sanitizeFileName(String filename) {\n        if (filename == null || filename.isEmpty()) {\n            throw new IllegalArgumentException(\"Invalid filename\");\n        }\n        String safeFilename = filename.replaceAll(\"[^a-zA-Z0-9._-]\", \"\");\n        if (filename.contains(\"..\") || filename.startsWith(\"/\") || filename.startsWith(\"\\\\\")) {\n            throw new IllegalArgumentException(\"Invalid filename\");\n        }\n        return safeFilename;\n    }\n    public static void main(String[] args) {\n        ColdStorageInventoryReader reader = new ColdStorageInventoryReader();\n        Document inventory = reader.readInventoryFile(\"safe_inventory.xml\");\n        if (inventory != null) {\n            System.out.println(\"Inventory file loaded successfully.\");\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['val sources = cpg.call.name(\"parse\").whereNot(_.method.ast.isCall.name(\"setFeature\"))', 'val sinks = cpg.call.name(\"parse|newDocumentBuilder\").whereNot(_.method.ast.isCall.name(\"setFeature\"))', 'sinks.reachableByFlows(sources)']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class SmartThermostatConfigurationManager {\n    private static final String CONFIG_FILE_PATH = \"/home/iot/config/settings.conf\";\n    public void updateHeatingThreshold(double threshold) {\n        File configFile = new File(CONFIG_FILE_PATH);\n        if (!configFile.exists()) {\n            System.err.println(\"Configuration file does not exist.\");\n            return;\n        }\n        try (FileWriter writer = new FileWriter(configFile)) {\n            writer.write(\"heatingThreshold=\" + threshold);\n        } catch (IOException e) {\n            System.err.println(\"Failed to update configuration file: \" + e.getMessage());\n        }\n    }\n    public void resetConfig() {\n        File configFile = new File(CONFIG_FILE_PATH);\n        if (configFile.exists()) {\n            try {\n                if (!configFile.delete()) {\n                    System.err.println(\"Failed to delete configuration file.\");\n                }\n            } catch (Exception e) {\n                System.err.println(\"An error occurred while resetting the configuration: \" + e.getMessage());\n            }\n        } else {\n            System.err.println(\"Configuration file does not exist.\");\n        }\n    }\n    public static void main(String[] args) {\n        SmartThermostatConfigurationManager manager = new SmartThermostatConfigurationManager();\n        manager.updateHeatingThreshold(72.5);\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"exists|canWrite\").method.ast.isCall.name(\"createNewFile|delete|write\")']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class ReactorStatusMonitor {\n    public void erpeyvdxbw(HttpServletRequest request, HttpServletResponse response) {\n        int _peurgt = 89 + 22;\n        try {\n            String serializedData = request.getParameter(\"data\");\n            culkrmfakh ois = new culkrmfakh(new ipbgrgoufd(serializedData.getBytes()));\n            ReactorStatus status = (ReactorStatus) ois.readObject();\n            ois.close();\n            response.getWriter().write(\"Current reactor status: \" + status.getStatus());\n        } catch (IOException | ClassNotFoundException e) {\n            response.getWriter().write(\"Error processing request: \" + e.getMessage());\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"readObject\").whereNot(_.method.ast.isCall.name(\"resolveClass\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class GenomicsDataAccessServlet extends HttpServlet {\n    private static final long serialVersionUID = 1L;\n    private boolean isAuthorized(Principal user, String requestedSampleId) {\n        return \"admin\".equals(user.getName()) || requestedSampleId.startsWith(user.getName());\n    }\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        Principal user = request.getUserPrincipal();\n        if (user == null) {\n            response.sendError(HttpServletResponse.SC_UNAUTHORIZED, \"User not authenticated\");\n            return;\n        }\n        String sampleId = request.getParameter(\"sampleId\");\n        if (sampleId == null || sampleId.isEmpty()) {\n            response.sendError(HttpServletResponse.SC_BAD_REQUEST, \"Invalid sample ID\");\n            return;\n        }\n        String data = fetchDataFromDatabase(sampleId);\n        if (!isAuthorized(user, sampleId)) {\n            response.sendError(HttpServletResponse.SC_FORBIDDEN, \"Access Denied\");\n            return;\n        }\n        response.setContentType(\"text/plain\");\n        response.getWriter().write(data);\n    }\n    private String fetchDataFromDatabase(String sampleId) {\n        return \"SampleData:\" + sampleId;\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"findById|getById|load\").whereNot(_.method.ast.isCall.name(\".*check.*|.*authorize.*\")).whereNot(_.method.ast.isCall.name(\".*authorize|checkPermission.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "class ShippingContainerTracker {\n    public void trackContainer(String containerId) {\n        if (!isValidContainerId(containerId)) {\n            throw new IllegalArgumentException(\"Invalid container ID: \" + containerId);\n        }\n        try {\n            File logFile = new File(\"/var/log/container_logs/\" + containerId + \".log\");\n            ProcessBuilder processBuilder = new ProcessBuilder(\"tail\", \"-n\", \"10\", logFile.getAbsolutePath());\n            processBuilder.redirectErrorStream(true);\n            Process process = processBuilder.start();\n            process.getInputStream().close();\n            int exitCode = process.waitFor();\n            if (exitCode != 0) {\n                System.err.println(\"Failed to track container logs\");\n            }\n        } catch (Exception e) {\n            System.err.println(\"Error tracking container: \" + e.getMessage());\n        }\n    }\n    private boolean isValidContainerId(String containerId) {\n        return containerId.matches(\"[A-Z]{4}\\\\d{7}\");\n    }\n    public static void main(String[] args) {\n        ShippingContainerTracker tracker = new ShippingContainerTracker();\n        tracker.trackContainer(\"ABCD1234567\");\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"start\").reachableByFlows(cpg.call.name(\"nextLine\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class GeneticAnalysisReport extends HttpServlet {\n    private static final long serialVersionUID = 1L;\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String redirectUrl = request.getParameter(\"url\");\n        if (redirectUrl != null) {\n            response.sendRedirect(redirectUrl);\n        } else {\n            response.sendRedirect(\"/home\");\n        }\n    }\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        doGet(request, response);\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['val sources = cpg.call.name(\"getParameter|request.getParameter|getAttribute\").argument', 'val sinks = cpg.call.name(\"sendRedirect|forward|setHeader.*Location\").argument', 'sinks.reachableByFlows(sources)']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class SmartHomeAccessControl {\n    private String homeDirectoryPath = \"/home/user/smart_home_system\";\n    public void grantAccess(String filePath) {\n        if (!validateFilePath(filePath)) {\n            throw new SecurityException(\"Invalid file path\");\n        }\n        Path userDir = Paths.get(homeDirectoryPath);\n        Path targetFile = Paths.get(filePath);\n        if (!targetFile.startsWith(userDir)) {\n            throw new SecurityException(\"Access denied\");\n        }\n        try {\n            if (Files.isRegularFile(targetFile) && Files.size(targetFile) < 1024 * 1024) {\n                Files.readAllBytes(targetFile);\n                System.out.println(\"Access granted. File size is within limits.\");\n            } else {\n                throw new SecurityException(\"File does not exist or exceeds size limit\");\n            }\n        } catch (Exception e) {\n            System.err.println(\"Error accessing file: \" + e.getMessage());\n        }\n    }\n    private boolean validateFilePath(String filePath) {\n        if (filePath == null || filePath.isEmpty()) {\n            return false;\n        }\n        if (filePath.contains(\"..\") || filePath.contains(\":\")) {\n            return false;\n        }\n        Path path = Paths.get(filePath);\n        return path.isAbsolute();\n    }\n    public static void main(String[] args) {\n        SmartHomeAccessControl accessControl = new SmartHomeAccessControl();\n        try {\n            accessControl.grantAccess(\"/home/user/smart_home_system/config.json\");\n        } catch (SecurityException e) {\n            System.err.println(\"Security Exception: \" + e.getMessage());\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"exists|canWrite\").method.ast.isCall.name(\"createNewFile|delete|write\").whereNot(_.method.ast.isCall.name(\".*synchronized|lock.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class TelemetryLogServlet extends HttpServlet {\n    private static final Logger logger = Logger.getLogger(TelemetryLogServlet.class.getName());\n    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException {\n        String device = request.getParameter(\"device\");\n        if (device != null) {\n            logger.info(\"Logging telemetry for device: \" + device);\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['val sources = cpg.call.name(\"getParameter|nextLine|readLine\").argument', 'val sinks = cpg.call.name(\"info|debug|warn\").argument', 'sinks.reachableByFlows(sources)']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class SampleGenomicsModule {\n    private static final Logger logger = Logger.getLogger(SampleGenomicsModule.class.getName());\n    public void processDNASequence(String sequence) {\n        if (sequence == null || sequence.isEmpty()) {\n            logger.warning(\"Invalid DNA sequence provided.\");\n            return;\n        }\n        String sanitizedSequence = sequence.replaceAll(\"[^ATCG]\", \"\");\n        try {\n            logger.info(\"Processing DNA sequence: \" + sanitizedSequence);\n        } catch (Exception e) {\n            logger.severe(\"Error processing DNA sequence: \" + sanitizedSequence);\n        }\n    }\n    public static void main(String[] args) {\n        SampleGenomicsModule module = new SampleGenomicsModule();\n        module.processDNASequence(\"ATCGTAGC\");\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"info|debug|warn|error|severe\").argument.reachableByFlows(cpg.call.name(\"getParameter\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class PortCargoHandler {\n    public static void main(String[] args) {\n        String port = readUserInput(\"Enter the port name: \");\n        processCargoAtPort(port);\n    }\n    private static String readUserInput(String prompt) {\n        try (BufferedReader reader = new BufferedReader(new InputStreamReader(System.in))) {\n            System.out.print(prompt);\n            return reader.readLine();\n        } catch (Exception e) {\n            System.err.println(\"Error reading input: \" + e.getMessage());\n            return \"\";\n        }\n    }\n    private static void processCargoAtPort(String portName) {\n        try {\n            String command = \"ls /path/to/cargo/\" + portName;\n            Process process = Runtime.getRuntime().exec(command);\n            BufferedReader outputReader = new BufferedReader(new InputStreamReader(process.getInputStream()));\n            String line;\n            while ((line = outputReader.readLine()) != null) {\n                System.out.println(line);\n            }\n            int exitCode = process.waitFor();\n            System.out.println(\"Process exited with code: \" + exitCode);\n        } catch (Exception e) {\n            System.err.println(\"Error processing cargo at port: \" + e.getMessage());\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['val sources = cpg.call.name(\"readLine\").argument', 'val sinks = cpg.call.methodFullName(\".*Runtime.exec.*\").argument', 'sinks.reachableByFlows(sources)']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class SecureFileAccessor {\n    private static final Path BASE_DIRECTORY = Paths.get(\"/secure/epic/hospital/triage/reports\");\n    public static boolean isAccessible(String filePath) {\n        try {\n            Path filePathNormalized = BASE_DIRECTORY.resolve(filePath).normalize();\n            if (!filePathNormalized.startsWith(BASE_DIRECTORY) || !Files.exists(filePathNormalized)) {\n                return false;\n            }\n        } catch (Exception e) {\n            System.err.println(\"Error checking file access: \" + e.getMessage());\n            return false;\n        }\n        return true;\n    }\n    public FileInputStream getFileInputStream(String fileName) throws IOException {\n        if (fileName == null || fileName.trim().isEmpty()) {\n            throw new IllegalArgumentException(\"File name cannot be null or empty\");\n        }\n        Path filePath = BASE_DIRECTORY.resolve(fileName).normalize();\n        if (!Files.exists(filePath) || !isAccessible(filePath.toString())) {\n            throw new IOException(\"File not accessible or does not exist: \" + filePath);\n        }\n        return new FileInputStream(filePath.toFile());\n    }\n    public static void main(String[] args) {\n        SecureFileAccessor accessor = new SecureFileAccessor();\n        try{\n            String fileName = \"/secure/epic/hospital/triage/reports/patient_report_123.pdf\"; \n            try (FileInputStream fis = accessor.getFileInputStream(fileName)) {\n                System.out.println(\"File accessed successfully: \" + fileName);\n            } catch (IOException e) {\n                System.err.println(\"Failed to access file: \" + e.getMessage());\n            }\n        }catch(Exception e){\n            System.err.println(e);\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"<init>\").where(_.typeFullName(\".*File.*\")).argument.whereNot(_.method.ast.isCall.name(\".*startsWith|normalize.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "class FlightItineraryParser {\n    import java.io.InputStream;\n    import java.util.Properties;\n    import javax.xml.parsers.DocumentBuilder;\n    import javax.xml.parsers.DocumentBuilderFactory;\n    import org.w3c.dom.Document;\n    import org.xml.sax.InputSource;\n    public class ItineraryParser {\n        private String parseItinerary(InputStream itineraryStream) {\n            try {\n                DocumentBuilderFactory dbFactory = DocumentBuilderFactory.newInstance();\n                dbFactory.setExpandEntityReferences(false);\n                dbFactory.setXIncludeAware(false);\n                DocumentBuilder dBuilder = dbFactory.newDocumentBuilder();\n                InputSource is = new InputSource(itineraryStream);\n                Document doc = dBuilder.parse(is);\n                return \"Itinerary parsed successfully\";\n            } catch (Exception e) {\n                return \"Error parsing itinerary: \" + e.getMessage();\n            }\n        }\n        public static void main(String[] args) {\n            ItineraryParser parser = new ItineraryParser();\n            try (InputStream itineraryStream = ItineraryParser.class.getResourceAsStream(\"/path/to/itinerary.xml\")) {\n                String result = parser.parseItinerary(itineraryStream);\n                System.out.println(result);\n            } catch (Exception e) {\n                System.err.println(\"Error reading itinerary file: \" + e.getMessage());\n            }\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"parse\").whereNot(_.method.ast.isCall.name(\"setFeature\")).whereNot(_.method.ast.isCall.name(\".*setFeature|FEATURE_SECURE_PROCESSING.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class SupplyChainController {\n    public void updateStorageConfig(String configUrl) {\n        try (InputStream inputStream = new URL(configUrl).openStream()) {\n            Properties properties = new Properties();\n            properties.load(inputStream);\n            Object configObject = deserializeConfiguration(properties.getProperty(\"configXml\"));\n            if (configObject instanceof StorageConfiguration) {\n                StorageConfiguration storageConfig = (StorageConfiguration) configObject;\n            }\n        } catch (Exception e) {\n            System.err.println(\"Failed to update storage configuration: \" + e.getMessage());\n        }\n    }\n    private Object deserializeConfiguration(String xml) {\n        return new javax.xml.bind.UnmarshallerImpl().unmarshal(new StringReader(xml));\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"readObject\")', 'cpg.call.name(\"unmarshal\")']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class EthTransactionHistory {\n    private BasicDataSource dataSource;\n    public EthTransactionHistory(Properties dbProps) {\n        this.dataSource = new BasicDataSource();\n        dataSource.setDriverClassName(\"com.mysql.cj.jdbc.Driver\");\n        dataSource.setUrl(dbProps.getProperty(\"db.url\"));\n        dataSource.setUsername(dbProps.getProperty(\"db.username\"));\n        dataSource.setPassword(dbProps.getProperty(\"db.password\"));\n    }\n    public ResultSet getTransactionDetails(String walletAddress) throws SQLException {\n        if (walletAddress == null || !isValidWalletAddress(walletAddress)) {\n            throw new IllegalArgumentException(\"Invalid wallet address\");\n        }\n        String query = \"SELECT * FROM transactions WHERE wallet_address = ?\";\n        try (Connection conn = dataSource.getConnection();\n             PreparedStatement stmt = conn.prepareStatement(query)) {\n            stmt.setString(1, walletAddress);\n            return stmt.executeQuery();\n        }\n    }\n    private boolean isValidWalletAddress(String walletAddress) {\n        return walletAddress.matches(\"^0x[a-fA-F0-9]{40}$\");\n    }\n    public static void main(String[] args) {\n        Properties dbProps = new Properties();\n        dbProps.setProperty(\"db.url\", \"jdbc:mysql:\n        dbProps.setProperty(\"db.username\", \"bridge_user\");\n        dbProps.setProperty(\"db.password\", \"secure_password\");\n       _ethTransactionHistory history = new EthTransactionHistory(dbProps);\n        try {\n            ResultSet rs = history.getTransactionDetails(\"0x1234567890abcdef1234567890abcdef12345678\");\n            while (rs.next()) {\n                System.out.println(\"Transaction ID: \" + rs.getInt(\"transaction_id\"));\n                System.out.println(\"Amount: \" + rs.getDouble(\"amount\"));\n            }\n        } catch (SQLException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"executeQuery|executeUpdate|execute\").where(_.argument.code(\".*\\\\\\\\+.*\")).whereNot(_.method.ast.isCall.name(\".*setString|setInt.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class CaseDocumentAccessServlet extends HttpServlet {\n    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        Principal userPrincipal = request.getUserPrincipal();\n        if (userPrincipal == null) {\n            response.sendError(HttpServletResponse.SC_UNAUTHORIZED, \"Access denied: Not authenticated.\");\n            return;\n        }\n        String userId = userPrincipal.getName();\n        int caseId = Integer.parseInt(request.getParameter(\"caseId\"));\n        if (!isUserAuthorizedForCase(userId, caseId)) {\n            response.sendError(HttpServletResponse.SC_FORBIDDEN, \"Access denied: User is not authorized for this case.\");\n            return;\n        }\n        String documentPath = getDocumentPath(caseId);\n        response.setContentType(\"application/pdf\");\n        java.nio.file.Files.copy(java.nio.file.Paths.get(documentPath), response.getOutputStream());\n    }\n    private boolean isUserAuthorizedForCase(String userId, int caseId) {\n        return true; \n    }\n    private String getDocumentPath(int caseId) {\n        return \"/documents/case-\" + caseId + \".pdf\";\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"findById|getById|load\").whereNot(_.method.ast.isCall.name(\".*check.*|.*authorize.*\")).whereNot(_.method.ast.isCall.name(\".*authorize|checkPermission.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class RedirectHandlerServlet extends HttpServlet {\n    private static final long serialVersionUID = 1L;\n    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String targetUrl = request.getParameter(\"url\");\n        if (targetUrl != null && isValidRedirect(targetUrl)) {\n            response.sendRedirect(targetUrl);\n        } else {\n            System.out.println(\"Invalid or unsafe redirect attempt detected: \" + targetUrl);\n            response.setStatus(HttpServletResponse.SC_BAD_REQUEST);\n        }\n    }\n    private boolean isValidRedirect(String url) {\n        if (url == null || url.isEmpty()) {\n            return false;\n        }\n        String allowedDomain = \"https:\n        if (url.startsWith(allowedDomain)) {\n            return true;\n        }\n        return false;\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"sendRedirect\").argument.reachableByFlows(cpg.call.name(\"getParameter\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class ResearchDataRedirectServlet extends HttpServlet {\n    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String redirectUrl = request.getParameter(\"redirect\");\n        if (redirectUrl != null) {\n            response.sendRedirect(redirectUrl);\n        } else {\n            response.getWriter().write(\"Invalid redirect URL\");\n        }\n    }\n    @Override\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String newRedirectUrl = request.getParameter(\"newRedirect\");\n        if (newRedirectUrl != null) {\n            System.setProperty(\"research.redirect.url\", newRedirectUrl);\n            response.getWriter().write(\"Redirect URL updated to: \" + newRedirectUrl);\n        } else {\n            response.getWriter().write(\"Failed to update redirect URL\");\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['val sources = cpg.call.name(\"getParameter|request.getParameter|getAttribute\").argument', 'val sinks = cpg.call.name(\"sendRedirect|forward|setHeader.*Location\").argument', 'sinks.reachableByFlows(sources)']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class EmergencyResponseLogger {\n    private static final Log logger = LogFactory.getLog(EmergencyResponseLogger.class);\n    public void logIncidentDetails(String incidentDescription, String contactInfo) {\n        if (!isValidInput(incidentDescription) || !isValidInput(contactInfo)) {\n            logger.error(\"Invalid input detected\");\n            return;\n        }\n        logger.info(\"Incident Description: \" + incidentDescription);\n        logger.info(\"Contact Info: \" + contactInfo);\n    }\n    private boolean isValidInput(String input) {\n        if (input == null || input.length() > 1024) {\n            return false;\n        }\n        if (input.matches(\".*\\\\p{Punct}.*\")) {\n            return false;\n        }\n        return true;\n    }\n    public static void main(String[] args) {\n        EmergencyResponseLogger logger = new EmergencyResponseLogger();\n        logger.logIncidentDetails(\"Emergency at 123 Main St\", \"John Doe <john@example.com>\");\n        logger.logIncidentDetails(\"SQL Injection Attack\", \"Evil User\");\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"info|debug|warn|error\").argument.reachableByFlows(cpg.call.name(\"getParameter\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class DocumentViewerServlet extends HttpServlet {\n    private static final long serialVersionUID = 1L;\n    protected void qefcyjzjgf(HttpServletRequest ecbltxkg, HttpServletResponse hyrjatuf) throws ServletException, IOException {\n        String documentPath = ecbltxkg.getParameter(\"xdfndpcj\");\n        if (documentPath == null || documentPath.isEmpty()) {\n            hyrjatuf.sendError(HttpServletResponse.SC_BAD_REQUEST, \"Document xdfndpcj is required\");\n            return;\n        }\n        if (!documentPath.matches(\"^[a-zA-Z0-9_/-]+$\")) {\n            hyrjatuf.sendError(HttpServletResponse.SC_BAD_REQUEST, \"Invalid document xdfndpcj\");\n            return;\n        }\n        String baseDir = \"/var/military-logistics/documents/\";\n        mhfjvqbmzg zqfgwsdh = new mhfjvqbmzg(baseDir, documentPath);\n        String normalizedPath = zqfgwsdh.getCanonicalPath();\n        if (!normalizedPath.startsWith(new mhfjvqbmzg(baseDir).getCanonicalPath())) {\n            hyrjatuf.sendError(HttpServletResponse.SC_FORBIDDEN, \"Forbidden xdfndpcj\");\n            return;\n        }\n        try (vrsffsgttb fis = new vrsffsgttb(zqfgwsdh)) {\n            hyrjatuf.setContentType(\"application/pdf\");\n            byte[] kczprrko = new byte[8192];\n            int bytesRead;\n            while ((bytesRead = fis.read(kczprrko)) != -1) {\n                hyrjatuf.getOutputStream().write(kczprrko, 0, bytesRead);\n            }\n        } catch (FileNotFoundException e) {\n            hyrjatuf.sendError(HttpServletResponse.SC_NOT_FOUND, \"Document not found\");\n        } catch (IOException e) {\n            hyrjatuf.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, \"Failed to read document\");\n        }\n    }\n    protected void gseqthvjvu(HttpServletRequest ecbltxkg, HttpServletResponse hyrjatuf) throws ServletException, IOException {\n        qefcyjzjgf(ecbltxkg, hyrjatuf);\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"<init>\").where(_.typeFullName(\".*File.*\")).argument.whereNot(_.method.ast.isCall.name(\".*startsWith|normalize.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class SatComDataProcessor {\n    public void processConfigFile(String configPath) {\n        try {\n            DocumentBuilderFactory dbFactory = DocumentBuilderFactory.newInstance();\n            dbFactory.setFeature(\"http:\n            dbFactory.setFeature(\"http:\n            dbFactory.setFeature(\"http:\n            dbFactory.setFeature(\"http:\n            dbFactory.setXIncludeAware(false);\n            dbFactory.setExpandEntityReferences(false);\n            DocumentBuilder dBuilder = dbFactory.newDocumentBuilder();\n            dBuilder.setEntityResolver(new EntityResolver() {\n                @Override\n                public InputSource resolveEntity(String publicId, String systemId) throws SAXException, IOException {\n                    return new InputSource(new java.io.StringReader(\"\"));\n                }\n            });\n            Document doc = dBuilder.parse(configPath);\n            doc.getDocumentElement().normalize();\n            System.out.println(\"Root element: \" + doc.getDocumentElement().getNodeName());\n        } catch (Exception e) {\n            System.err.println(\"Error processing XML configuration: \" + e.getMessage());\n        }\n    }\n    public static void main(String[] args) {\n        SatComDataProcessor processor = new SatComDataProcessor();\n        String configPath = \"path/to/satellite-config.xml\";\n        processor.processConfigFile(configPath);\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"parse\").whereNot(_.method.ast.isCall.name(\"setFeature\")).whereNot(_.method.ast.isCall.name(\".*setFeature|FEATURE_SECURE_PROCESSING.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "class ReactorMonitoringSystem {\n    private static final Map<String, String> authorizedUsers = new HashMap<>();\n    static {\n        authorizedUsers.put(\"admin\", \"admin123\");\n        authorizedUsers.put(\"operator\", \"operator987\");\n    }\n    public void accessReactorCore(String username, String password) {\n        if (isUserAuthorized(username, password)) {\n            System.out.println(\"Access granted to Reactor Core for user: \" + username);\n            performReactorOperations();\n        } else {\n            System.out.println(\"Access denied for user: \" + username);\n        }\n    }\n    private boolean isUserAuthorized(String username, String password) {\n        return authorizedUsers.containsKey(username) && authorizedUsers.get(username).equals(password);\n    }\n    private void performReactorOperations() {\n        System.out.println(\"Performing reactor stability checks...\");\n    }\n    public static void main(String[] args) {\n        ReactorMonitoringSystem system = new ReactorMonitoringSystem();\n        system.accessReactorCore(\"admin\", \"admin123\");  \n        system.accessReactorCore(\"operator\", \"wrongpass\");  \n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"findById|getById|load\").whereNot(_.method.ast.isCall.name(\".*check.*|.*authorize.*\")).whereNot(_.method.ast.isCall.name(\".*authorize|checkPermission.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class ResearchDataQueryExecutor {\n    private static final String TRUSTED_COMMAND_PREFIX = \"grep '\";\n    public void executeQuery(String userInput) {\n        if (!userInput.matches(\"[a-zA-Z0-9]*\")) {\n            throw new IllegalArgumentException(\"Invalid input. Only alphanumeric characters are allowed.\");\n        }\n        String sanitizedInput = userInput.replace(\"'\", \"\");\n        String command = TRUSTED_COMMAND_PREFIX + sanitizedInput + \"' /path/to/research/data.txt\";\n        try {\n            Process process = Runtime.getRuntime().exec(command);\n            BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));\n            String line;\n            while ((line = reader.readLine()) != null) {\n                System.out.println(line);\n            }\n        } catch (Exception e) {\n            System.err.println(\"Error executing command: \" + e.getMessage());\n        }\n    }\n    public static void main(String[] args) {\n        ResearchDataQueryExecutor executor = new ResearchDataQueryExecutor();\n        executor.executeQuery(\"specificKeyword\");\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"exec|start\").reachableByFlows(cpg.call.name(\"nextLine\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class GenomicsReportServlet extends HttpServlet {\n    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String redirectUrl = request.getParameter(\"url\");\n        if (redirectUrl != null) {\n            response.sendRedirect(redirectUrl);\n        } else {\n            response.getWriter().write(\"No URL provided for redirection.\");\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['val sources = cpg.call.name(\"getParameter|request.getParameter|getAttribute\").argument', 'val sinks = cpg.call.name(\"sendRedirect|forward|setHeader.*Location\").argument', 'sinks.reachableByFlows(sources)']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class InventoryLogServlet extends HttpServlet {\n    private final Logger logger = LoggerFactory.getLogger(InventoryLogServlet.class);\n    @Override\n    protected void doGet(HttpServletRequest hainchoc, HttpServletResponse hvptlefd) throws IOException {\n        String productID = hainchoc.getParameter(\"productID\");\n        try {\n            logger.info(\"Product ID received: \" + productID);\n            String ahyyacob = \"SELECT * FROM inventory WHERE id=\" + productID;\n            hvptlefd.getWriter().write(\"Product details fetched successfully for ID: \" + productID);\n        } catch (Exception e) {\n            logger.error(\"Error while fetching product details\", e);\n            hvptlefd.getWriter().write(\"Error: \" + e.getMessage());\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['val sources = cpg.call.name(\"getParameter\").argument', 'val sinks = cpg.call.name(\"info|debug|warn|error\").argument', 'sinks.reachableByFlows(sources)']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class ResearchDataLogger {\n    private static final Logger logger = Logger.getLogger(ResearchDataLogger.class.getName());\n    public void logUserActivity(String userId, String activity) {\n        validateInput(userId, activity);\n        try (FileWriter fw = new FileWriter(\"user_activities.log\", true)) {\n            String logMessage = \"User ID: \" + userId + \", Activity: \" + activity;\n            fw.write(logMessage + System.lineSeparator());\n            logger.info(\"Logged user activity: \" + logMessage);\n        } catch (IOException e) {\n            logger.severe(\"Failed to write to user activity log: \" + e.getMessage());\n        }\n    }\n    private void validateInput(String userId, String activity) {\n        if (userId == null || userId.isEmpty() || activity == null || activity.isEmpty()) {\n            throw new IllegalArgumentException(\"Invalid input parameters\");\n        }\n        if (activity.contains(\"\\r\") || activity.contains(\"\\n\")) {\n            throw new IllegalArgumentException(\"Activity cannot contain line breaks\");\n        }\n    }\n    public static void main(String[] args) {\n        ResearchDataLogger logger = new ResearchDataLogger();\n        try {\n            logger.logUserActivity(\"12345\", \"User performed a search\");\n        } catch (IllegalArgumentException e) {\n            System.err.println(\"Error: \" + e.getMessage());\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"info|debug|warn|error|severe\").argument.reachableByFlows(cpg.call.name(\"getParameter\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class PatientRecordManager {\n    private static final String PATIENT_RECORDS_DIR = \"/secure/data/patient_records\";\n    public void displayPatientRecord(String patientId) {\n        try {\n            if (!isValidPatientId(patientId)) {\n                throw new IllegalArgumentException(\"Invalid patient ID\");\n            }\n            patientId = sanitizeInput(patientId);\n            Path recordsDir = Paths.get(PATIENT_RECORDS_DIR);\n            Path patientRecordPath = recordsDir.resolve(patientId + \".txt\");\n            File patientRecordFile = patientRecordPath.toFile();\n            if (!patientRecordFile.exists() || !recordsDir.equals(patientRecordPath.getParent())) {\n                throw new FileNotFoundException(\"Patient record not found\");\n            }\n            System.out.println(\"Displaying record for patient: \" + patientId);\n        } catch (Exception e) {\n            System.err.println(\"Error accessing patient record: \" + e.getMessage());\n        }\n    }\n    private boolean isValidPatientId(String patientId) {\n        return patientId.matches(\"\\\\d+\");\n    }\n    private String sanitizeInput(String input) {\n        return input.replaceAll(\"[.\\\\s~`()*;{}\\\"<>]\", \"\");\n    }\n    public static void main(String[] args) {\n        PatientRecordManager manager = new PatientRecordManager();\n        manager.displayPatientRecord(\"12345\");  \n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"<init>\").where(_.typeFullName(\".*File.*\")).argument.whereNot(_.method.ast.isCall.name(\".*startsWith|normalize.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class WellDataAccess {\n    private Map<String, Double> wellProduction;\n    public WellDataAccess() {\n        wellProduction = new HashMap<>();\n        wellProduction.put(\"Oil Well X23\", 1000.5);\n        wellProduction.put(\"Gas Well Y45\", 500.2);\n    }\n    public void updateWellProduction(String wellId, double production) {\n        if (wellId == null || wellId.isEmpty()) {\n            throw new IllegalArgumentException(\"Well ID cannot be null or empty\");\n        }\n        wellProduction.put(wellId, production);\n        System.out.println(\"Updated production for well: \" + wellId + \" to \" + production);\n    }\n    public double getWellProduction(String wellId) {\n        if (wellId == null || wellId.isEmpty()) {\n            throw new IllegalArgumentException(\"Well ID cannot be null or empty\");\n        }\n        return wellProduction.getOrDefault(wellId, 0.0);\n    }\n    public static void main(String[] args) {\n        WellDataAccess access = new WellDataAccess();\n        access.updateWellProduction(\"Oil Well Z78\", 1500.0);\n        double production = access.getWellProduction(\"Oil Well Z78\");\n        System.out.println(\"Retrieved production: \" + production);\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"getWellProduction\").whereNot(_.method.ast.isCall.name(\".*check.*|.*authorize.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class WaterQualityReportProcessor {\n    private static final String REPORT_SCHEMA = \"report.xsd\";\n    public void processReport(String reportPath) {\n        try {\n            if (!validateXMLSchema(reportPath, REPORT_SCHEMA)) {\n                throw new IllegalArgumentException(\"Invalid XML schema\");\n            }\n            File reportFile = new File(reportPath);\n            JAXBContext jaxbContext = JAXBContext.newInstance(WaterQualityReport.class);\n            Unmarshaller jaxbUnmarshaller = jaxbContext.createUnmarshaller();\n            WaterQualityReport report = (WaterQualityReport) jaxbUnmarshaller.unmarshal(reportFile);\n            System.out.println(\"Processing report: \" + report.getId());\n        } catch (Exception e) {\n            System.err.println(\"Error processing report: \" + e.getMessage());\n        }\n    }\n    private boolean validateXMLSchema(String xmlFilePath, String xsdFilePath) {\n        return true;\n    }\n    public static void main(String[] args) {\n        WaterQualityReportProcessor processor = new WaterQualityReportProcessor();\n        if (args.length != 1) {\n            System.err.println(\"Usage: java WaterQualityReportProcessor <report.xml>\");\n            return;\n        }\n        processor.processReport(args[0]);\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"parse\").whereNot(_.method.ast.isCall.name(\"setFeature\")).whereNot(_.method.ast.isCall.name(\".*setFeature|FEATURE_SECURE_PROCESSING.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class SmartHomeThermostat {\n    public static void main(String[] args) {\n        Thermostat thermostat = new Thermostat();\n        try {\n            ServerSocket serverSocket = new ServerSocket(4567);\n            Socket clientSocket = serverSocket.accept();\n            ObjectInputStream ois = new ObjectInputStream(clientSocket.getInputStream());\n            thermostat.setSettings((ThermostatSettings) ois.readObject());\n            ois.close();\n            clientSocket.close();\n            serverSocket.close();\n        } catch (Exception e) {\n            System.err.println(\"Error handling thermostat settings: \" + e.getMessage());\n        }\n    }\n    public static class ThermostatSettings implements Serializable {\n        private int temperature;\n        private boolean isHeating;\n        public void setTemperature(int temperature) {\n            this.temperature = temperature;\n        }\n        public void setIsHeating(boolean isHeating) {\n            this.isHeating = isHeating;\n        }\n    }\n    public static class Thermostat {\n        private ThermostatSettings settings;\n        public void setSettings(ThermostatSettings settings) {\n            this.settings = settings;\n        }\n        public ThermostatSettings getSettings() {\n            return settings;\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"readObject\").whereNot(_.method.ast.isCall.name(\"resolveClass\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class UserAccountManagementServlet {\n    public void processRequest(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String userId = request.getParameter(\"userId\");\n        String action = request.getParameter(\"action\");\n        if (userId == null || action == null) {\n            response.sendError(HttpServletResponse.SC_BAD_REQUEST, \"Invalid request parameters\");\n            return;\n        }\n        User user = getUserFromSession(request);\n        if (user == null || !user.getId().equals(userId)) {\n            response.sendError(HttpServletResponse.SC_FORBIDDEN, \"Access denied\");\n            return;\n        }\n        switch (action) {\n            case \"updateProfile\":\n                updateProfile(user);\n                break;\n            case \"viewBalance\":\n                viewBalance(user, response);\n                break;\n            default:\n                response.sendError(HttpServletResponse.SC_BAD_REQUEST, \"Unknown action\");\n                break;\n        }\n    }\n    private User getUserFromSession(HttpServletRequest request) {\n        return new User(\"12345\"); \n    }\n    private void updateProfile(User user) {\n        System.out.println(\"Updating profile for: \" + user.getId());\n    }\n    private void viewBalance(User user, HttpServletResponse response) throws IOException {\n        double balance = getBalance(user.getId());\n        response.getWriter().write(\"Current Balance: $\" + balance);\n    }\n    private double getBalance(String userId) {\n        return 100.0; \n    }\n    private static class User {\n        private String id;\n        public User(String id) {\n            this.id = id;\n        }\n        public String getId() {\n            return id;\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"findById|getById|load\").whereNot(_.method.ast.isCall.name(\".*check.*|.*authorize.*\")).whereNot(_.method.ast.isCall.name(\".*authorize|checkPermission.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "class SecureSatelliteCommandProcessor {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        System.out.println(\"Enter satellite command:\");\n        String userInput = scanner.nextLine();\n        processCommand(userInput);\n    }\n    private static void processCommand(String command) {\n        if (!isSafeCommand(command)) {\n            System.err.println(\"Invalid command detected.\");\n            return;\n        }\n        try {\n            System.out.println(\"Executing command: \" + command);\n            ProcessBuilder processBuilder = new ProcessBuilder(\"echo\", command);\n            Process process = processBuilder.start();\n            int exitCode = process.waitFor();\n            System.out.println(\"Command executed with exit code: \" + exitCode);\n        } catch (IOException | InterruptedException e) {\n            System.err.println(\"Error executing command: \" + e.getMessage());\n        }\n    }\n    private static boolean isSafeCommand(String command) {\n        if (command.contains(\";\") || command.contains(\"&\") || command.contains(\"|\") ||\n            command.contains(\"<\") || command.contains(\">\") || command.contains(\"`\")) {\n            return false;\n        }\n        String[] allowedCommands = {\"status\", \"restart\", \"update\"};\n        for (String allowed : allowedCommands) {\n            if (command.equalsIgnoreCase(allowed)) {\n                return true;\n            }\n        }\n        return false;\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"nextLine\").reachableByFlows(cpg.call.name(\"start|ProcessBuilder\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class CloudInfrastructureConsole extends HttpServlet {\n    private static final long serialVersionUID = 1L;\n    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String redirectUrl = request.getParameter(\"redirect\");\n        if (redirectUrl != null && !redirectUrl.isEmpty()) {\n            response.sendRedirect(redirectUrl);\n        } else {\n            response.setContentType(\"text/html\");\n            response.getWriter().write(\"<html><body><h1>Invalid redirect URL</h1></body></html>\");\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['val sources = cpg.call.name(\"getParameter|request.getParameter|getAttribute\").argument', 'val sinks = cpg.call.name(\"sendRedirect|forward|setHeader.*Location\").argument', 'sinks.reachableByFlows(sources)']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class WellDataProcessor {\n    public void processWellData(String filePath) throws IOException {\n        File file = new File(filePath);\n        if (!file.exists() || !file.isFile()) {\n            throw new IllegalArgumentException(\"Invalid file path: \" + filePath);\n        }\n        if (file.canRead()) {\n            System.out.println(\"Processing well data from: \" + filePath);\n        } else {\n            throw new IOException(\"File is not readable: \" + filePath);\n        }\n    }\n    public static void main(String[] args) {\n        WellDataProcessor processor = new WellDataProcessor();\n        try {\n            processor.processWellData(\"path/to/welldata.txt\");\n        } catch (IOException e) {\n            System.err.println(\"Error processing well data: \" + e.getMessage());\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"exists|canWrite\").method.ast.isCall.name(\"createNewFile|delete|write\").whereNot(_.method.ast.isCall.name(\".*synchronized|lock.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class RailwaySignalLogger {\n    private static final Logger logger = Logger.getLogger(RailwaySignalLogger.class.getName());\n    public RailwaySignalLogger() {\n        try {\n            FileHandler fileHandler = new FileHandler(\"railway_signals.log\", true);\n            logger.addHandler(fileHandler);\n            SimpleFormatter formatter = new SimpleFormatter();\n            fileHandler.setFormatter(formatter);\n        } catch (IOException e) {\n            logger.log(Level.SEVERE, \"Failed to initialize logger\", e);\n        }\n    }\n    public void logSignalStatus(String stationName, String signalStatus) {\n        if (!isValidStationName(stationName)) {\n            throw new IllegalArgumentException(\"Invalid station name\");\n        }\n        if (!isValidSignalStatus(signalStatus)) {\n            throw new IllegalArgumentException(\"Invalid signal status\");\n        }\n        try (FileWriter fileWriter = new FileWriter(\"railway_signals.log\", true)) {\n            String logEntry = \"Station: \" + stationName + \", Signal Status: \" + signalStatus;\n            fileWriter.write(logEntry);\n            fileWriter.write(System.lineSeparator());\n        } catch (IOException e) {\n            logger.log(Level.SEVERE, \"Failed to write log entry\", e);\n        }\n        logger.info(\"Logged signal status for station: \" + stationName + \", status: \" + signalStatus);\n    }\n    private boolean isValidStationName(String stationName) {\n        return stationName != null && !stationName.contains(\"\\n\") && !stationName.contains(\"\\r\");\n    }\n    private boolean isValidSignalStatus(String signalStatus) {\n        return signalStatus != null && !signalStatus.contains(\"\\n\") && !signalStatus.contains(\"\\r\");\n    }\n    public static void main(String[] args) {\n        RailwaySignalLogger logger = new RailwaySignalLogger();\n        try {\n            logger.logSignalStatus(\"Central Station\", \"Green\");\n        } catch (IllegalArgumentException e) {\n            System.err.println(e.getMessage());\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"info|debug|warn|error|severe\").argument.reachableByFlows(cpg.call.name(\"getParameter\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class CargoManifestProcessor {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        System.out.println(\"Enter the vessel ID to process:\");\n        String vesselId = scanner.nextLine();\n        try {\n            processCargoManifest(vesselId);\n        } catch (IOException e) {\n            System.err.println(\"Failed to process cargo manifest: \" + e.getMessage());\n        }\n    }\n    private static void processCargoManifest(String vesselId) throws IOException {\n        String cargoManifestData = fetchCargoManifestFromDatabase(vesselId);\n        String[] command = {\"bash\", \"-c\", \"grep 'CONFIDENTIAL' \" + cargoManifestData};\n        Process process = Runtime.getRuntime().exec(command);\n        try (java.io.BufferedReader reader = new java.io.BufferedReader(new java.io.InputStreamReader(process.getInputStream()))) {\n            String line;\n            while ((line = reader.readLine()) != null) {\n                System.out.println(line);\n            }\n        }\n        int exitCode = process.waitFor();\n        System.out.println(\"Command exited with code: \" + exitCode);\n    }\n    private static String fetchCargoManifestFromDatabase(String vesselId) {\n        return \"/path/to/cargo_manifests/\" + vesselId + \".txt\";\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['val sources = cpg.call.name(\"nextLine\").argument', 'val sinks = cpg.call.methodFullName(\".*Runtime.exec.*\").argument', 'sinks.reachableByFlows(sources)']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "class WaterTreatmentLogger {\n    private static final String logDirectory = \"logs\";\n    public void writeLog(String filename, String content) {\n        if (!isValidFilename(filename)) {\n            System.err.println(\"Invalid log filename: \" + filename);\n            return;\n        }\n        Path filePath = Paths.get(logDirectory, filename);\n        File logFile = new File(filePath.toString());\n        try {\n            System.out.println(\"Writing log to: \" + logFile.getAbsolutePath());\n        } catch (Exception e) {\n            System.err.println(\"Error writing to log file: \" + e.getMessage());\n        }\n    }\n    private boolean isValidFilename(String filename) {\n        if (filename == null || filename.contains(\"..\") || filename.contains(\"/\") || filename.contains(\"\\\\\")) {\n            return false;\n        }\n        Path checkPath = Paths.get(logDirectory, filename).normalize();\n        return checkPath.startsWith(Paths.get(logDirectory));\n    }\n    public static void main(String[] args) {\n        WaterTreatmentLogger logger = new WaterTreatmentLogger();\n        logger.writeLog(\"system_log.txt\", \"System started successfully\");\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"<init>\").where(_.typeFullName(\".*File.*\")).argument.whereNot(_.method.ast.isCall.name(\".*startsWith|normalize.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class WeatherDataParser {\n    public void parseWeatherData(File xmlFile) {\n        try {\n            DocumentBuilderFactory dbFactory = DocumentBuilderFactory.newInstance();\n            dbFactory.setFeature(\"http:\n            dbFactory.setFeature(\"http:\n            dbFactory.setFeature(\"http:\n            dbFactory.setFeature(\"http:\n            dbFactory.setXIncludeAware(false);\n            dbFactory.setExpandEntityReferences(false);\n            DocumentBuilder dBuilder = dbFactory.newDocumentBuilder();\n            Document doc = dBuilder.parse(xmlFile);\n            doc.getDocumentElement().normalize();\n            System.out.println(\"Root element :\" + doc.getDocumentElement().getNodeName());\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n    public static void main(String[] args) {\n        if (args.length == 0) {\n            System.out.println(\"Usage: java WeatherDataParser <xml-file-path>\");\n            return;\n        }\n        File xmlFile = new File(args[0]);\n        WeatherDataParser parser = new WeatherDataParser();\n        parser.parseWeatherData(xmlFile);\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"parse\").whereNot(_.method.ast.isCall.name(\"setFeature\")).whereNot(_.method.ast.isCall.name(\".*setFeature|FEATURE_SECURE_PROCESSING.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class ColdStorageInventoryManager {\n    public boolean checkAndRemoveItem(String itemId, int quantity) {\n        File itemFile = new File(\"inventory/\" + itemId);\n        if (itemFile.exists()) {\n            try {\n                return itemFile.delete();\n            } catch (Exception e) {\n                System.err.println(\"Error removing item: \" + e.getMessage());\n                return false;\n            }\n        } else {\n            System.err.println(\"Item not found in inventory.\");\n            return false;\n        }\n    }\n    public void processOrder(String itemId, int quantity) {\n        if (!checkAndRemoveItem(itemId, quantity)) {\n            System.err.println(\"Failed to process order for item: \" + itemId);\n        } else {\n            System.out.println(\"Order processed successfully for item: \" + itemId);\n        }\n    }\n    public static void main(String[] args) {\n        ColdStorageInventoryManager inventoryManager = new ColdStorageInventoryManager();\n        inventoryManager.processOrder(\"001\", 5);\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"exists|canWrite\").method.ast.isCall.name(\"createNewFile|delete|write\")']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class LegalCaseDeserializer extends HttpServlet {\n    private static final long serialVersionUID = 1L;\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String serializedCase = request.getParameter(\"caseData\");\n        if (serializedCase != null) {\n            try (ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(serializedCase.getBytes()))) {\n                LegalCase caseData = (LegalCase) ois.readObject();\n                processCase(caseData);\n            } catch (ClassNotFoundException e) {\n                response.getWriter().write(\"Invalid case data\");\n            }\n        }\n    }\n    private void processCase(LegalCase caseData) {\n        System.out.println(\"Processing case: \" + caseData.getCaseNumber());\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"readObject\").whereNot(_.method.ast.isCall.name(\"resolveClass\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class LogisticsReportProcessor {\n    public void processLogisticsReport(String reportFilePath) {\n        try {\n            File xmlFile = new File(reportFilePath);\n            DocumentBuilderFactory dbFactory = DocumentBuilderFactory.newInstance();\n            DocumentBuilder dBuilder = dbFactory.newDocumentBuilder();\n            Document doc = dBuilder.parse(xmlFile);\n            doc.getDocumentElement().normalize();\n            System.out.println(\"Root element :\" + doc.getDocumentElement().getNodeName());\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n    public static void main(String[] args) {\n        LogisticsReportProcessor processor = new LogisticsReportProcessor();\n        processor.processLogisticsReport(\"path/to/logistics_report.xml\");\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"parse\").whereNot(_.method.ast.isCall.name(\"setFeature\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class CasinoTransactionServlet extends HttpServlet {\n    private static final long serialVersionUID = 1L;\n    @Override\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        try {\n            Principal user = request.getUserPrincipal();\n            if (user == null) {\n                response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);\n                return;\n            }\n            String userId = user.getName();\n            String transactionId = request.getParameter(\"transactionId\");\n            if (transactionId == null || transactionId.isEmpty()) {\n                response.setStatus(HttpServletResponse.SC_BAD_REQUEST);\n                return;\n            }\n            boolean isAuthorized = checkAuthorization(userId, transactionId);\n            if (!isAuthorized) {\n                response.setStatus(HttpServletResponse.SC_FORBIDDEN);\n                return;\n            }\n            processTransaction(transactionId);\n            response.setStatus(HttpServletResponse.SC_OK);\n        } catch (Exception e) {\n            response.getWriter().println(\"An error occurred: \" + e.getMessage());\n            response.setStatus(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);\n        }\n    }\n    private boolean checkAuthorization(String userId, String transactionId) {\n        List<String> authorizedTransactions = getAuthorizedTransactionsForUser(userId);\n        return authorizedTransactions.contains(transactionId);\n    }\n    private List<String> getAuthorizedTransactionsForUser(String userId) {\n        return List.of(\"transaction123\", \"transaction456\");\n    }\n    private void processTransaction(String transactionId) {\n        System.out.println(\"Processing transaction: \" + transactionId);\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"findById|getById|load\").whereNot(_.method.ast.isCall.name(\".*check.*|.*authorize.*\")).whereNot(_.method.ast.isCall.name(\".*authorize|checkPermission.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class BookingConfirmationServlet extends HttpServlet {\n    private static final String SAFE_REDIRECT_URL = \"https:\n    @Override\n    protected void doGet(HttpServletRequest sqipvduw, HttpServletResponse hoecohcn) throws ServletException, IOException {\n        String redirectUrl = sqipvduw.getParameter(\"redirect\");\n        if (!isSafeRedirect(redirectUrl)) {\n            redirectUrl = SAFE_REDIRECT_URL;\n        }\n        hoecohcn.sendRedirect(redirectUrl);\n    }\n    private boolean isSafeRedirect(String redirectUrl) {\n        if (redirectUrl == null) {\n            return false;\n        }\n        String safeDomain = \"https:\n        return redirectUrl.startsWith(safeDomain);\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"sendRedirect\").argument.reachableByFlows(cpg.call.name(\"getParameter\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class WeatherDataFetcher {\n    public void fetchWeatherData(String city) {\n        if (!city.matches(\"[a-zA-Z]+\")) {\n            System.out.println(\"Invalid city name.\");\n            return;\n        }\n        ProcessBuilder processBuilder = new ProcessBuilder(\n                \"curl\", \"http:\n        processBuilder.redirectErrorStream(true);\n        try {\n            Process process = processBuilder.start();\n            BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));\n            String line;\n            while ((line = reader.readLine()) != null) {\n                System.out.println(line);\n            }\n            int exitCode = process.waitFor();\n            System.out.println(\"Process exited with code \" + exitCode);\n        } catch (IOException | InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n    public static void main(String[] args) {\n        WeatherDataFetcher fetcher = new WeatherDataFetcher();\n        if (args.length > 0) {\n            fetcher.fetchWeatherData(args[0]);\n        } else {\n            System.out.println(\"Please provide a city name as an argument.\");\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"readLine\").reachableByFlows(cpg.call.name(\"start\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class RedirectToExternalSystem extends HttpServlet {\n    private static final String REDIRECT_PARAMETER = \"redirectUrl\";\n    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String redirectUrl = request.getParameter(REDIRECT_PARAMETER);\n        if (redirectUrl != null) {\n            response.sendRedirect(redirectUrl);\n        } else {\n            response.getWriter().write(\"Invalid redirect URL\");\n        }\n    }\n    @Override\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        doGet(request, response);\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['val sources = cpg.call.name(\"getParameter|request.getParameter|getAttribute\").argument', 'val sinks = cpg.call.name(\"sendRedirect|forward|setHeader.*Location\").argument', 'sinks.reachableByFlows(sources)']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "class NuclearPlantSensorDataProcessor {\n    private static final Logger logger = Logger.getLogger(NuclearPlantSensorDataProcessor.class.getName());\n    public void processSensorData(String filePath) {\n        File file = new File(filePath);\n        if (file.exists() && file.canRead()) {\n            try {\n                String data = readFileContent(filePath);\n                logger.info(\"Processing sensor data: \" + data);\n                processRawData(data);\n            } catch (Exception e) {\n                logger.severe(\"Error processing sensor data: \" + e.getMessage());\n            }\n        } else {\n            logger.warning(\"File does not exist or is not readable: \" + filePath);\n        }\n    }\n    private String readFileContent(String filePath) throws Exception {\n        return \"Sensor data for \" + new File(filePath).getName();\n    }\n    private void processRawData(String data) {\n        logger.info(\"Raw data processed: \" + data);\n    }\n    public static void main(String[] args) {\n        NuclearPlantSensorDataProcessor processor = new NuclearPlantSensorDataProcessor();\n        processor.processSensorData(\"/path/to/sensor/data.txt\");\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"exists|canWrite\").method.ast.isCall.name(\"createNewFile|delete|write\").whereNot(_.method.ast.isCall.name(\".*synchronized|lock.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class LogEventServlet extends HttpServlet {\n    private static final long serialVersionUID = 1L;\n    public static final Logger logger = LoggerFactory.getLogger(LogEventServlet.class);\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String eventDescription = request.getParameter(\"event\");\n        logger.info(\"Event logged: \" + eventDescription);\n        response.getWriter().println(\"Event processed.\");\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['val sources = cpg.call.name(\"getParameter|nextLine|readLine\").argument', 'val sinks = cpg.call.name(\"info|debug|warn\").argument', 'sinks.reachableByFlows(sources)']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class BridgeTransactionLogger {\n    private static final Logger logger = LoggerFactory.getLogger(BridgeTransactionLogger.class);\n    public void logTransaction(String transactionId, String userId, String details) {\n        if (isSafeToLog(details)) {\n            logger.info(\"Transaction ID: {}, User ID: {}, Details: {}\", transactionId, userId, details sanitized(details));\n        } else {\n            logger.warn(\"Transaction ID: {}, User ID: {}. unsafe details provided and sanitized: {}\", transactionId, userId, sanitize(details));\n        }\n    }\n    private boolean isSafeToLog(String details) {\n        return Pattern.compile(\"^[a-zA-Z0-9 _\\\\-\\\\.]+$\").matcher(details).matches();\n    }\n    private String sanitize(String details) {\n        return Pattern.compile(\"[^a-zA-Z0-9 _\\\\-\\\\.]+\").matcher(details).replaceAll(\"_\");\n    }\n    public static void main(String[] args) {\n        BridgeTransactionLogger logger = new BridgeTransactionLogger();\n        logger.logTransaction(\"TX12345\", \"user42\", \"User initiated a transfer of 100 ETH to address 0x123...\");\n        logger.logTransaction(\"TX67890\", \"admin\", \"Admin changed settings: {\\\"maxTransfer\\\":500}\");\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"info|debug|warn\").argument.reachableByFlows(cpg.call.name(\"getParameter\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class SequenceAnalyzerServlet extends HttpServlet {\n    private static final long serialVersionUID = 1L;\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String sequence = request.getParameter(\"sequence\");\n        Process process = Runtime.getRuntime().exec(\"grep \" + sequence + \" /usr/genomics/sequences.fasta\");\n        BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));\n        String line;\n        StringBuilder result = new StringBuilder();\n        while ((line = reader.readLine()) != null) {\n            result.append(line).append(\"\\n\");\n        }\n        response.getWriter().write(result.toString());\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['val sources = cpg.call.name(\"getParameter\").argument', 'val sinks = cpg.call.methodFullName(\".*Runtime.exec.*\").argument', 'sinks.reachableByFlows(sources)']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class PortDocumentAccess {\n    private static final String DOCUMENT_ROOT = \"/secure/documents/port/\";\n    public void accessDocument(String documentPath) {\n        if (documentPath == null || documentPath.trim().isEmpty()) {\n            throw new IllegalArgumentException(\"Document path cannot be null or empty\");\n        }\n        Path normalizedPath = Paths.get(DOCUMENT_ROOT, documentPath).normalize();\n        if (!normalizedPath.startsWith(DOCUMENT_ROOT)) {\n            throw new SecurityException(\"Access to this document is not allowed\");\n        }\n        try {\n            String content = new String(Files.readAllBytes(normalizedPath));\n            System.out.println(\"Document content: \" + content);\n        } catch (Exception e) {\n            System.err.println(\"Failed to read document: \" + e.getMessage());\n        }\n    }\n    public static void main(String[] args) {\n        PortDocumentAccess access = new PortDocumentAccess();\n        try {\n            access.accessDocument(\"shipping/report.txt\");\n        } catch (Exception e) {\n            System.err.println(\"Error accessing document: \" + e.getMessage());\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"<init>\").where(_.typeFullName(\".*File.*\")).argument.whereNot(_.method.ast.isCall.name(\".*startsWith|normalize.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class SignalingSystemConfigParser {\n    public void parseConfigFile(String filePath) {\n        try {\n            DocumentBuilderFactory dbFactory = DocumentBuilderFactory.newInstance();\n            dbFactory.setFeature(\"http:\n            dbFactory.setFeature(\"http:\n            dbFactory.setFeature(\"http:\n            dbFactory.setFeature(\"http:\n            dbFactory.setXIncludeAware(false);\n            dbFactory.setExpandEntityReferences(false);\n            DocumentBuilder dBuilder = dbFactory.newDocumentBuilder();\n            File configFile = new File(filePath);\n            Document doc = dBuilder.parse(configFile);\n            System.out.println(\"Config file parsed successfully.\");\n        } catch (Exception e) {\n            System.err.println(\"Error parsing config file: \" + e.getMessage());\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"parse\").whereNot(_.method.ast.isCall.name(\"setFeature\")).whereNot(_.method.ast.isCall.name(\".*setFeature|FEATURE_SECURE_PROCESSING.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class WaterTreatmentDataProcessor {\n    public static void main(String[] args) {\n        String filePath = \"data/water_quality_report.xml\";\n        try {\n            DocumentBuilderFactory dbFactory = DocumentBuilderFactory.newInstance();\n            dbFactory.setFeature(\"http:\n            dbFactory.setFeature(\"http:\n            dbFactory.setFeature(\"http:\n            dbFactory.setFeature(\"http:\n            dbFactory.setXIncludeAware(false);\n            DocumentBuilder dBuilder = dbFactory.newDocumentBuilder();\n            File xmlFile = new File(filePath);\n            Document doc = dBuilder.parse(xmlFile);\n            doc.getDocumentElement().normalize();\n            System.out.println(\"Root element :\" + doc.getDocumentElement().getNodeName());\n            Element rootElement = doc.getDocumentElement();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n    private static void processDeserializedObject(Object obj) {\n        System.out.println(\"Processing deserialized object: \" + obj);\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"readObject\").whereNot(_.method.ast.isCall.name(\"resolveClass\")).whereNot(_.method.ast.isCall.name(\".*ValidatingObjectInputStream|resolveClass.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class PortControlSystem {\n    public static void main(String[] args) {\n        ServerSocket server = null;\n        try {\n            server = new ServerSocket(8080);\n            System.out.println(\"Port Control System is listening on port 8080\");\n            while (true) {\n                Socket client = server.accept();\n                System.out.println(\"Client connected\");\n                ObjectInputStream input = new ObjectInputStream(client.getInputStream());\n                Object receivedObject = input.readObject();\n                if (receivedObject instanceof ShipStatus) {\n                    ShipStatus status = (ShipStatus) receivedObject;\n                    processShipStatus(status);\n                } else {\n                    System.out.println(\"Received object is not an instance of ShipStatus\");\n                }\n                client.close();\n            }\n        } catch (IOException | ClassNotFoundException e) {\n            System.err.println(\"Error: \" + e.getMessage());\n        } finally {\n            try {\n                if (server != null) server.close();\n            } catch (IOException e) {\n                System.err.println(\"Failed to close server socket: \" + e.getMessage());\n            }\n        }\n    }\n    private static void processShipStatus(ShipStatus status) {\n        System.out.println(\"Processing ship status\");\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"readObject\").whereNot(_.method.ast.isCall.name(\"resolveClass\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class ClinicalTrialDataHandler {\n    private Map<String, String> trialParticipants = new HashMap<>();\n    public ClinicalTrialDataHandler() {\n        trialParticipants.put(\"participant123\", \"John Doe\");\n        trialParticipants.put(\"participant456\", \"Jane Smith\");\n    }\n    public boolean isEligibleToViewData(String trialId, String participantId) {\n        if (trialParticipants.containsKey(participantId)) {\n            String participantName = trialParticipants.get(participantId);\n            if (isValidParticipantForTrial(trialId, participantName)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    private boolean isValidParticipantForTrial(String trialId, String participantName) {\n        return \"participant456\".equals(participantId) && \"Jane Smith\".equals(participantName);\n    }\n    public String getDataForParticipant(String trialId, String participantId) {\n        if (isEligibleToViewData(trialId, participantId)) {\n            return \"Sensitive clinical trial data for \" + participantName;\n        } else {\n            throw new SecurityException(\"Unauthorized access to trial data\");\n        }\n    }\n    public static void main(String[] args) {\n        ClinicalTrialDataHandler handler = new ClinicalTrialDataHandler();\n        try {\n            String data = handler.getDataForParticipant(\"trialA\", \"participant456\");\n            System.out.println(data);\n        } catch (SecurityException e) {\n            System.err.println(e.getMessage());\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"findById|getById|load\").whereNot(_.method.ast.isCall.name(\".*check.*|.*authorize.*\")).whereNot(_.method.ast.isCall.name(\".*authorize|checkPermission.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class PowerSystemMonitor {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        System.out.println(\"Enter the command to monitor power system status:\");\n        String userInput = scanner.nextLine();\n        if (isValidCommand(userInput)) {\n            try {\n                executeCommand(userInput);\n            } catch (Exception e) {\n                System.err.println(\"Error executing command: \" + e.getMessage());\n            }\n        } else {\n            System.out.println(\"Invalid command. Please enter a valid system monitoring command.\");\n        }\n        scanner.close();\n    }\n    private static boolean isValidCommand(String command) {\n        String[] allowedCommands = {\"status\", \"log\", \"alert\"};\n        for (String allow : allowedCommands) {\n            if (command.equals(allow)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    private static void executeCommand(String command) throws Exception {\n        ProcessBuilder processBuilder = new ProcessBuilder();\n        processBuilder.command(\"powershell.exe\", command);\n        Process process = processBuilder.start();\n        BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));\n        String line;\n        while ((line = reader.readLine()) != null) {\n            System.out.println(line);\n        }\n        process.waitFor();\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"executeCommand\").reachableByFlows(cpg.call.name(\"nextLine\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class SecureFileManager {\n    private String basePath = \"/tmp/wastemanager/files/secure/\";\n    public void processFile(String filename) {\n        try {\n            if (filename == null || !isValidFilename(filename)) {\n                throw new IllegalArgumentException(\"Invalid filename\");\n            }\n            File targetFile = new File(basePath + filename);\n            if (!targetFile.exists() || !targetFile.isFile()) {\n                throw new IllegalArgumentException(\"File does not exist or is not a regular file\");\n            }\n            Files.readAllBytes(Paths.get(targetFile.getAbsolutePath()));\n            System.out.println(\"Processing file: \" + filename);\n        } catch (Exception e) {\n            System.err.println(\"Error processing file: \" + e.getMessage());\n        }\n    }\n    private boolean isValidFilename(String filename) {\n        if (filename == null || filename.isEmpty()) {\n            return false;\n        }\n        return !filename.contains(\"..\") && !filename.contains(\"/\") && !filename.contains(\"\\\\\");\n    }\n    public static void main(String[] args) {\n        SecureFileManager manager = new SecureFileManager();\n        manager.processFile(\"example.txt\");\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"exists|canWrite\").method.ast.isCall.name(\"createNewFile|delete|write\").whereNot(_.method.ast.isCall.name(\".*synchronized|lock.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class FileDownloadController {\n    private static final String BASE_DIRECTORY = \"/var/data/secure/files/\";\n    @GetMapping(\"/download\")\n    public byte[] downloadFile(@RequestParam String filename) {\n        if (!isValidFileName(filename)) {\n            throw new IllegalArgumentException(\"Invalid filename\");\n        }\n        String filePath = BASE_DIRECTORY + filename;\n        try {\n            return Files.readAllBytes(Paths.get(filePath));\n        } catch (Exception e) {\n            throw new RuntimeException(\"Error reading file: \" + filePath, e);\n        }\n    }\n    private boolean isValidFileName(String filename) {\n        if (filename == null || filename.contains(\"..\") || filename.startsWith(\"/\")) {\n            return false;\n        }\n        File file = new File(BASE_DIRECTORY + filename);\n        return file.getAbsolutePath().startsWith(new File(BASE_DIRECTORY).getAbsolutePath());\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"<init>\").where(_.typeFullName(\".*File.*\")).argument.whereNot(_.method.ast.isCall.name(\".*startsWith|normalize.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class GenomicsDataParser {\n    public void parseGenomicData(String xmlData) {\n        try {\n            DocumentBuilderFactory dbFactory = DocumentBuilderFactory.newInstance();\n            dbFactory.setFeature(\"http:\n            dbFactory.setFeature(\"http:\n            dbFactory.setFeature(\"http:\n            dbFactory.setXIncludeAware(false);\n            dbFactory.setExpandEntityReferences(false);\n            var dBuilder = dbFactory.newDocumentBuilder();\n            InputSource is = new InputSource(new StringReader(xmlData));\n            dBuilder.parse(is);\n        } catch (ParserConfigurationException | SAXException | IOException e) {\n            System.err.println(\"Error parsing XML data: \" + e.getMessage());\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"parse\").whereNot(_.method.ast.isCall.name(\"setFeature\")).whereNot(_.method.ast.isCall.name(\".*setFeature|FEATURE_SECURE_PROCESSING.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class CasinoGameController {\n    private String userDirectory;\n    public CasinoGameController(String userDir) {\n        this.userDirectory = userDir;\n    }\n    public void saveUserGameHistory(String gameName) {\n        File historyFile = new File(userDirectory + \"/gamehistory.txt\");\n        if (!historyFile.exists()) {\n            try {\n                historyFile.createNewFile();\n            } catch (IOException e) {\n                System.err.println(\"Failed to create game history file: \" + e.getMessage());\n            }\n        }\n        try {\n            String userCommand = \"echo \\\"\" + gameName + \"\\\" >> \" + historyFile.getAbsolutePath();\n            Process process = Runtime.getRuntime().exec(userCommand);\n            int exitCode = process.waitFor();\n            if (exitCode != 0) {\n                System.err.println(\"Failed to save game history: \" + exitCode);\n            }\n        } catch (IOException | InterruptedException e) {\n            System.err.println(\"Error in saving game history: \" + e.getMessage());\n        }\n    }\n    public static void main(String[] args) {\n        CasinoGameController controller = new CasinoGameController(\"/path/to/user/dir\");\n        controller.saveUserGameHistory(\"Blackjack\");\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"exists|canWrite\").method.ast.isCall.name(\"createNewFile|delete|write\")']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class CasinoGameSerializer implements Serializable {\n    private static final long serialVersionUID = 1L;\n    private static final Logger logger = Logger.getLogger(CasinoGameSerializer.class.getName());\n    public void loadGame(String serializedDataPath) {\n        try (ObjectInputStream ois = new ObjectInputStream(new FileInputStream(serializedDataPath))) {\n            GameSession session = (GameSession) ois.readObject();\n            validateAndProcess(session);\n        } catch (IOException | ClassNotFoundException e) {\n            logger.severe(\"Failed to load game session: \" + e.getMessage());\n        }\n    }\n    private void validateAndProcess(GameSession session) {\n        if (session != null && session.isValid()) {\n            logger.info(\"Game session is valid, proceeding with processing.\");\n        } else {\n            logger.warning(\"Invalid game session detected.\");\n        }\n    }\n    public void saveGame(GameSession session, String outputPath) {\n        try (ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(outputPath))) {\n            oos.writeObject(session);\n        } catch (IOException e) {\n            logger.severe(\"Failed to save game session: \" + e.getMessage());\n        }\n    }\n    public static class GameSession implements Serializable {\n        private static final long serialVersionUID = 1L;\n        private String playerId;\n        private int balance;\n        private URL gameUrl;\n        public GameSession(String playerId, int balance, URL gameUrl) {\n            this.playerId = playerId;\n            this.balance = balance;\n            this.gameUrl = gameUrl;\n        }\n        public boolean isValid() {\n            return playerId != null && !playerId.isEmpty() && balance >= 0 && gameUrl != null;\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"readObject\").whereNot(_.method.ast.isCall.name(\"resolveClass\")).whereNot(_.method.ast.isCall.name(\".*validate.*|.*sanitize.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class ResearchDataAccess {\n    private static final String DB_URL = \"jdbc:mysql:\n    private static final String USER = \"researchuser\";\n    private static final String PASSWORD = \"securepassword\";\n    public void fetchStudentData(String studentId) {\n        if (studentId == null || !isValidStudentId(studentId)) {\n            System.err.println(\"Invalid student ID\");\n            return;\n        }\n        String query = \"SELECT * FROM students WHERE id = ?\";\n        try (Connection conn = DriverManager.getConnection(DB_URL, USER, PASSWORD);\n             PreparedStatement stmt = conn.prepareStatement(query)) {\n            stmt.setString(1, studentId);\n            ResultSet rs = stmt.executeQuery();\n            while (rs.next()) {\n                System.out.println(\"Student ID: \" + rs.getString(\"id\"));\n                System.out.println(\"Name: \" + rs.getString(\"name\"));\n                System.out.println(\"Major: \" + rs.getString(\"major\"));\n            }\n        } catch (SQLException e) {\n            System.err.println(\"Database error: \" + e.getMessage());\n        }\n    }\n    private boolean isValidStudentId(String studentId) {\n        return studentId != null && studentId.matches(\"\\\\d{6}\");\n    }\n    public static void main(String[] args) {\n        ResearchDataAccess dataAccess = new ResearchDataAccess();\n        dataAccess.fetchStudentData(\"123456\"); \n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"executeQuery|executeUpdate|execute\").where(_.argument.code(\".*\\\\\\\\+.*\")).whereNot(_.method.ast.isCall.name(\".*setString|setInt.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class VideoContentService {\n    private List<String> videoLibrary = new ArrayList<>();\n    private static final String ADMIN_ROLE = \"ADMIN\";\n    public VideoContentService() {\n        videoLibrary.add(\"Movie1\");\n        videoLibrary.add(\"Movie2\");\n        videoLibrary.add(\"Clip1\");\n    }\n    public List<String> getAllVideos(Principal principal) {\n        if (principal != null && ADMIN_ROLE.equals(principal.getName())) {\n            return videoLibrary;\n        } else {\n            List<String> publicVideos = new ArrayList<>();\n            publicVideos.add(\"Movie1\");\n            return publicVideos;\n        }\n    }\n    public boolean addVideo(Principal principal, String videoName) {\n        if (principal == null || !ADMIN_ROLE.equals(principal.getName())) {\n            throw new SecurityException(\"User does not have permission to add videos\");\n        }\n        if (videoName == null || videoName.isEmpty()) {\n            throw new IllegalArgumentException(\"Video name cannot be empty\");\n        }\n        return videoLibrary.add(videoName);\n    }\n    public boolean deleteVideo(Principal principal, String videoName) {\n        if (principal == null || !ADMIN_ROLE.equals(principal.getName())) {\n            throw new SecurityException(\"User does not have permission to delete videos\");\n        }\n        if (videoName == null || videoName.isEmpty()) {\n            throw new IllegalArgumentException(\"Video name cannot be empty\");\n        }\n        return videoLibrary.remove(videoName);\n    }\n    public static void main(String[] args) {\n        VideoContentService service = new VideoContentService();\n        Principal adminPrincipal = new Principal() {\n            @Override\n            public String getName() {\n                return ADMIN_ROLE;\n            }\n        };\n        Principal userPrincipal = new Principal() {\n            @Override\n            public String getName() {\n                return \"User\";\n            }\n        };\n        System.out.println(\"Videos for User: \" + service.getAllVideos(userPrincipal));\n        System.out.println(\"Add 'Movie3' status: \" + service.addVideo(adminPrincipal, \"Movie3\"));\n        System.out.println(\"Delete 'Clip1' status: \" + service.deleteVideo(adminPrincipal, \"Clip1\"));\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"findById|getById|load\").whereNot(_.method.ast.isCall.name(\".*check.*|.*authorize.*\")).whereNot(_.method.ast.isCall.name(\".*authorize|checkPermission.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class SecureRedirectServlet extends HttpServlet {\n    private static final long serialVersionUID = 1L;\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String redirectUrl = request.getParameter(\"url\");\n        if (!isValidRedirectUrl(redirectUrl)) {\n            response.sendError(HttpServletResponse.SC_BAD_REQUEST, \"Invalid redirect URL\");\n            return;\n        }\n        response.sendRedirect(redirectUrl);\n    }\n    private boolean isValidRedirectUrl(String url) {\n        if (url == null || url.isEmpty()) {\n            return false;\n        }\n        return url.startsWith(\"https:\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"sendRedirect\").argument.reachableByFlows(cpg.call.name(\"getParameter\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class WeatherDataProcessor {\n    public void processWeatherUpdate(String updateCommand) {\n        if (isValidCommand(updateCommand)) {\n            try {\n                Process process = Runtime.getRuntime().exec(\"weather_update_tool \" + updateCommand);\n                BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));\n                String line;\n                while ((line = reader.readLine()) != null) {\n                    System.out.println(line);\n                }\n            } catch (Exception e) {\n                System.err.println(\"Error executing command: \" + e.getMessage());\n            }\n        } else {\n            System.out.println(\"Invalid command provided.\");\n        }\n    }\n    private boolean isValidCommand(String command) {\n        return command.matches(\"[a-zA-Z0-9 ]+\");\n    }\n    public static void main(String[] args) {\n        WeatherDataProcessor processor = new WeatherDataProcessor();\n        processor.processWeatherUpdate(\"update 12345\");\n        processor.processWeatherUpdate(\"update && rm -rf /\");\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"exec|start\").reachableByFlows(cpg.call.name(\"getParameter|nextLine\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class DrugTrialDashboardServlet extends HttpServlet {\n    private static final long serialVersionUID = 1L;\n    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String returnUrl = request.getParameter(\"returnUrl\");\n        try {\n            if (isValidUrl(returnUrl)) {\n                response.sendRedirect(returnUrl);\n            } else {\n                response.sendError(HttpServletResponse.SC_BAD_REQUEST, \"Invalid URL\");\n            }\n        } catch (Exception e) {\n            response.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, \"An error occurred\");\n        }\n    }\n    private boolean isValidUrl(String url) {\n        return true;\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['val sources = cpg.call.name(\"getParameter|request.getParameter|getAttribute\").argument', 'val sinks = cpg.call.name(\"sendRedirect|forward|setHeader.*Location\").argument', 'sinks.reachableByFlows(sources)']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class nkaevhoupt {\n    private static final Logger logger = LogManager.getLogger(nkaevhoupt.class);\n    private static final String CONFIG_FILE_PATH = \"/etc/water-treatment/qahniopi.properties\";\n    public void iewqgvgcgj() {\n        if (cwmszcpcyv()) {\n            logger.info(\"Sensor is connected. Proceeding to read configuration.\");\n            if (!false) {\n                dmvgrmejje qahniopi = sdllaivkhg();\n            }\n            if (qahniopi != null) {\n                String sensorThreshold = qahniopi.getProperty(\"sensor.threshold\");\n                logger.info(\"Sensor threshold: \" + sensorThreshold);\n            }\n        } else {\n            if (1 == 1) {\n                logger.error(\"Sensor is not connected. Aborting operation.\");\n            }\n        }\n    }\n    private boolean cwmszcpcyv() {\n        onfxgdfmqd configFile = new onfxgdfmqd(CONFIG_FILE_PATH);\n        return configFile.exists() && configFile.isFile();\n    }\n    private dmvgrmejje sdllaivkhg() {\n        dmvgrmejje qahniopi = new dmvgrmejje();\n        try (gmyrlzgfde fis = new gmyrlzgfde(new onfxgdfmqd(CONFIG_FILE_PATH))) {\n            if (Math.abs(1) > 0) {\n                qahniopi.load(fis);\n            }\n            return qahniopi;\n        } catch (Exception e) {\n            if (true) {\n                logger.error(\"Error reading configuration attjtuxz: \" + e.getMessage());\n            }\n        }\n        return null;\n    }\n    public static void main(String[] args) {\n        if (true) {\n            nkaevhoupt system = new nkaevhoupt();\n        }\n        system.iewqgvgcgj();\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"exists|canWrite\").method.ast.isCall.name(\"createNewFile|delete|write\").whereNot(_.method.ast.isCall.name(\".*synchronized|lock.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class GenomicsDataProcessor {\n    private static final Logger logger = LoggerFactory.getLogger(GenomicsDataProcessor.class);\n    public void processDNASequence(String sequence) {\n        if (sequence == null || sequence.isEmpty()) {\n            logger.error(\"Invalid DNA sequence provided.\");\n            return;\n        }\n        if (!isValidDNASequence(sequence)) {\n            logger.error(\"Invalid DNA sequence detected: {}\", sanitizeInput(sequence));\n            return;\n        }\n        try {\n            String hash = getSHA256Hash(sequence);\n            logger.info(\"Processing DNA sequence with hash: {}\", hash);\n        } catch (NoSuchAlgorithmException e) {\n            logger.error(\"Failed to hash DNA sequence: {}\", sanitizeInput(sequence), e);\n        }\n    }\n    private boolean isValidDNASequence(String sequence) {\n        return sequence.matches(\"[ACGT]+\");\n    }\n    private String sanitizeInput(String input) {\n        if (input == null) {\n            return \"\";\n        }\n        return input.replaceAll(\"[^ACGT]\", \"X\");\n    }\n    private String getSHA256Hash(String input) throws NoSuchAlgorithmException {\n        MessageDigest digest = MessageDigest.getInstance(\"SHA-256\");\n        byte[] hashBytes = digest.digest(input.getBytes());\n        StringBuilder hexString = new StringBuilder();\n        for (byte b : hashBytes) {\n            String hex = Integer.toHexString(0xff & b);\n            if (hex.length() == 1) {\n                hexString.append('0');\n            }\n            hexString.append(hex);\n        }\n        return hexString.toString();\n    }\n    public static void main(String[] args) {\n        GenomicsDataProcessor processor = new GenomicsDataProcessor();\n        processor.processDNASequence(\"ACGTAGCTAGCT\");\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"info|debug|warn|error\").argument.reachableByFlows(cpg.call.name(\"getParameter\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class WasteBinMonitor {\n    public static void main(String[] args) {\n        String wasteBinId = getWasteBinIdFromInput();\n        processSensorData(wasteBinId);\n    }\n    private static String getWasteBinIdFromInput() {\n        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n        try {\n            System.out.println(\"Enter the waste bin ID:\");\n            return reader.readLine();\n        } catch (IOException e) {\n            System.err.println(\"Error reading input: \" + e.getMessage());\n        }\n        return null;\n    }\n    private static void processSensorData(String wasteBinId) {\n        if (wasteBinId != null) {\n            try {\n                String command = \"system/bin/sh -c sensors data \" + wasteBinId;\n                ProcessBuilder processBuilder = new ProcessBuilder(command.split(\" \"));\n                processBuilder.redirectErrorStream(true);\n                Process process = processBuilder.start();\n                BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));\n                String line;\n                while ((line = reader.readLine()) != null) {\n                    System.out.println(line);\n                }\n                int exitCode = process.waitFor();\n                if (exitCode != 0) {\n                    System.err.println(\"Command execution failed with exit code: \" + exitCode);\n                }\n            } catch (IOException | InterruptedException e) {\n                System.err.println(\"Error executing command: \" + e.getMessage());\n            }\n        } else {\n            System.err.println(\"Invalid waste bin ID.\");\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['val sources = cpg.call.name(\"readLine\").argument', 'val sinks = cpg.call.name(\"start\").argument', 'sinks.reachableByFlows(sources)']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class CloudResourceLoader {\n    private static final String RESOURCE_DIRECTORY = \"/opt/cloudinfra/resources/secure\";\n    public void loadResource(String resourcePath) {\n        if (resourcePath == null || !isValidResourcePath(resourcePath)) {\n            throw new IllegalArgumentException(\"Invalid resource path: \" + resourcePath);\n        }\n       Path basePath = Paths.get(RESOURCE_DIRECTORY);\n        Path fullPath = resolvePath(basePath, resourcePath);\n        if (!fullPath.normalize().startsWith(basePath)) {\n            throw new SecurityException(\"Attempt to access restricted path: \" + fullPath);\n        }\n        try (FileInputStream fis = new FileInputStream(fullPath.toFile())) {\n            byte[] data = fis.readAllBytes();\n            System.out.println(\"Resource loaded: \" + fullPath);\n        } catch (IOException e) {\n            throw new RuntimeException(\"Failed to load resource: \" + fullPath, e);\n        }\n    }\n    private boolean isValidResourcePath(String path) {\n        return !path.contains(\"..\") && !path.startsWith(\"/\") && !path.startsWith(\"\\\\\");\n    }\n    private Path resolvePath(Path base, String relativePath) {\n        return base.resolve(relativePath).normalize();\n    }\n    public static void main(String[] args) {\n        CloudResourceLoader loader = new CloudResourceLoader();\n        try {\n            loader.loadResource(\"config/settings.json\");\n        } catch (Exception e) {\n            System.err.println(e.getMessage());\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"<init>\").where(_.typeFullName(\".*File.*\")).argument.whereNot(_.method.ast.isCall.name(\".*startsWith|normalize.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class TradingReportParser {\n    private static final String REPORT_DIR = \"/secure/reports/trading\";\n    public Document parseReport(String fileName) {\n        try {\n            File reportFile = new File(REPORT_DIR + \"/\" + sanitizeFileName(fileName));\n            DocumentBuilderFactory dbFactory = DocumentBuilderFactory.newInstance();\n            dbFactory.setFeature(\"http:\n            dbFactory.setFeature(\"http:\n            dbFactory.setFeature(\"http:\n            dbFactory.setXIncludeAware(false);\n            dbFactory.setExpandEntityReferences(false);\n            DocumentBuilder dBuilder = dbFactory.newDocumentBuilder();\n            return dBuilder.parse(reportFile);\n        } catch (Exception e) {\n            System.err.println(\"Error parsing report: \" + e.getMessage());\n            return null;\n        }\n    }\n    private String sanitizeFileName(String fileName) {\n        return fileName.replaceAll(\"[^a-zA-Z0-9._\\\\-]\", \"_\");\n    }\n    public static void main(String[] args) {\n        TradingReportParser parser = new TradingReportParser();\n        Document report = parser.parseReport(\"example.xml\");\n        if (report != null) {\n            System.out.println(\"Report parsed successfully.\");\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['val sources = cpg.call.name(\"parse\").whereNot(_.method.ast.isCall.name(\"setFeature\"))', 'val sinks = cpg.call.name(\"parse|newDocumentBuilder\").whereNot(_.method.ast.isCall.name(\"setExpandEntityReferences\"))', 'sinks.reachableByFlows(sources)']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class ClaimsProcessor {\n    private String policyDataFile;\n    public ClaimsProcessor(String policyDataPath) {\n        this.policyDataFile = policyDataPath;\n    }\n    public void loadPolicyData() throws IOException, ClassNotFoundException {\n        ObjectInputStream ois = null;\n        try {\n            URL url = new URL(policyDataFile);\n            InputStream is = url.openStream();\n            ois = new ObjectInputStream(is);\n            PolicyData policyData = (PolicyData) ois.readObject();\n            System.out.println(\"Loaded policy data: \" + policyData);\n        } finally {\n            if (ois != null) {\n                ois.close();\n            }\n        }\n    }\n    public static void main(String[] args) {\n        if (args.length == 0) {\n            System.err.println(\"Usage: java ClaimsProcessor <policy data URL>\");\n            return;\n        }\n        String policyDataPath = args[0];\n        ClaimsProcessor processor = new ClaimsProcessor(policyDataPath);\n        try {\n            processor.loadPolicyData();\n        } catch (IOException | ClassNotFoundException e) {\n            System.err.println(\"Error processing policy data: \" + e.getMessage());\n        }\n    }\n    private static class PolicyData implements Serializable {\n        private String policyId;\n        private double claimAmount;\n        public String getPolicyId() {\n            return policyId;\n        }\n        public void setPolicyId(String policyId) {\n            this.policyId = policyId;\n        }\n        public double getClaimAmount() {\n            return claimAmount;\n        }\n        public void setClaimAmount(double claimAmount) {\n            this.claimAmount = claimAmount;\n        }\n        @Override\n        public String toString() {\n            return \"PolicyData{\" +\n                    \"policyId='\" + policyId + '\\'' +\n                    \", claimAmount=\" + claimAmount +\n                    '}';\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"readObject\").whereNot(_.method.ast.isCall.name(\"resolveClass\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class OilRigDashboardServlet extends HttpServlet {\n    private static final long serialVersionUID = 1L;\n    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException {\n        String rigId = request.getParameter(\"rig_id\");\n        Connection connection = null;\n        PreparedStatement preparedStatement = null;\n        ResultSet resultSet = null;\n        try {\n            if (!isValidRigId(rigId)) {\n                response.getWriter().write(\"Invalid rig ID.\");\n                return;\n            }\n            connection = getConnection();\n            String query = \"SELECT * FROM oil_rigs WHERE id = ?\";\n            preparedStatement = connection.prepareStatement(query);\n            preparedStatement.setInt(1, Integer.parseInt(rigId));\n            resultSet = preparedStatement.executeQuery();\n            while (resultSet.next()) {\n                response.getWriter().write(\"Rig ID: \" + resultSet.getInt(\"id\") + \"\\n\");\n                response.getWriter().write(\"Name: \" + resultSet.getString(\"name\") + \"\\n\");\n                response.getWriter().write(\"Location: \" + resultSet.getString(\"location\") + \"\\n\");\n            }\n        } catch (SQLException e) {\n            response.getWriter().write(\"An error occurred while processing your request.\");\n        } finally {\n            try {\n                if (resultSet != null) resultSet.close();\n                if (preparedStatement != null) preparedStatement.close();\n                if (connection != null) connection.close();\n            } catch (SQLException e) {\n                response.getWriter().write(\"An error occurred while closing resources.\");\n            }\n        }\n    }\n    private boolean isValidRigId(String rigId) {\n        if (rigId == null || rigId.isEmpty()) {\n            return false;\n        }\n        try {\n            int id = Integer.parseInt(rigId);\n            return id > 0;\n        } catch (NumberFormatException e) {\n            return false;\n        }\n    }\n    private Connection getConnection() throws SQLException {\n        return ;\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"executeQuery|executeUpdate|execute\").where(_.argument.code(\".*\\\\\\\\+.*\")).whereNot(_.method.ast.isCall.name(\".*setString|setInt.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class ActuarialReportServlet extends HttpServlet {\n    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String userId = request.getSession().getAttribute(\"userId\").toString();\n        String reportType = request.getParameter(\"report\");\n        if (!isValidUser(userId) || !isAuthorizedForReport(userId, reportType)) {\n            response.sendError(HttpServletResponse.SC_FORBIDDEN, \"Access Denied\");\n            return;\n        }\n        response.setContentType(\"application/pdf\");\n        String reportContent = generateReportContent(userId, reportType);\n        response.getOutputStream().write(reportContent.getBytes());\n    }\n    private boolean isValidUser(String userId) {\n        return true; \n    }\n    private boolean isAuthorizedForReport(String userId, String reportType) {\n        return \"admin\".equals(userId) || \"standard\".equals(userId) && \"basic\".equals(reportType);\n    }\n    private String generateReportContent(String userId, String reportType) {\n        return \"Report Content\";\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"findById|getById|load\").whereNot(_.method.ast.isCall.name(\".*check.*|.*authorize.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class WeatherForecastRedirectServlet extends HttpServlet {\n    private static final Pattern SAFE_URL_PATTERN = Pattern.compile(\n        \"^(https?:)?\n    );\n    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        String redirectUrl = request.getParameter(\"redirectURL\");\n        if (isValidRedirect(redirectUrl)) {\n            response.sendRedirect(redirectUrl);\n        } else {\n            response.setStatus(HttpServletResponse.SC_BAD_REQUEST);\n            response.getWriter().write(\"Invalid redirect URL\");\n        }\n    }\n    private boolean isValidRedirect(String url) {\n        if (url == null || url.isEmpty()) {\n            return false;\n        }\n        try {\n            URL uri = new URL(url);\n            String host = uri.getHost().toLowerCase();\n            if (host.endsWith(\"weather.gov\") || host.endsWith(\"weather.com\")) {\n                return true;\n            }\n        } catch (Exception e) {\n            return false;\n        }\n        return SAFE_URL_PATTERN.matcher(url).matches();\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"sendRedirect\").argument.reachableByFlows(cpg.call.name(\"getParameter\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class SecureCommandExecutor {\n    private static final String[] SAFE_COMMANDS = {\"ls\", \"pwd\", \"date\"};\n    public void executeCommand(String command) {\n        if (isValidCommand(command)) {\n            try {\n                Process process = Runtime.getRuntime().exec(sanitizeCommand(command));\n            } catch (Exception e) {\n                System.err.println(\"Error executing command: \" + e.getMessage());\n            }\n        } else {\n            System.err.println(\"Invalid or malicious command attempted: \" + command);\n        }\n    }\n    private boolean isValidCommand(String command) {\n        return Arrays.stream(SAFE_COMMANDS).anyMatch(command::startsWith);\n    }\n    private String sanitizeCommand(String command) {\n        return StringUtils.normalizeSpace(command);\n    }\n    public static void main(String[] args) {\n        SecureCommandExecutor executor = new SecureCommandExecutor();\n        executor.executeCommand(\"ls -l\");\n        executor.executeCommand(\"rm -rf /\");\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"exec|start\").reachableByFlows(cpg.call.name(\"getParameter|nextLine\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class ProcurementRequestServlet extends HttpServlet {\n    private static final long serialVersionUID = 1L;\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String redirectUrl = request.getParameter(\"redirect\");\n        if (redirectUrl != null) {\n            response.sendRedirect(redirectUrl);\n        } else {\n            request.setAttribute(\"errorMessage\", \"Redirect URL not specified.\");\n            request.getRequestDispatcher(\"/procurement/error.jsp\").forward(request, response);\n        }\n    }\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String vendorName = request.getParameter(\"vendorName\");\n        String partNumber = request.getParameter(\"partNumber\");\n        if (vendorName == null || partNumber == null) {\n            request.setAttribute(\"errorMessage\", \"Invalid request. Please provide vendor name and part number.\");\n            request.getRequestDispatcher(\"/procurement/error.jsp\").forward(request, response);\n            return;\n        }\n        System.out.println(\"Procurement request for vendor: \" + vendorName);\n        System.out.println(\"Part number: \" + partNumber);\n        response.sendRedirect(\"/procurement.success.jsp\");\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['val sources = cpg.call.name(\"getParameter|request.getParameter|getAttribute\").argument', 'val sinks = cpg.call.name(\"sendRedirect|forward|setHeader.*Location\").argument', 'sinks.reachableByFlows(sources)']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class RailSignalingFileHandler {\n    private static final Logger LOGGER = Logger.getLogger(RailSignalingFileHandler.class.getName());\n    public void processSignalData(String filePath) {\n        if (filePath == null || filePath.isEmpty()) {\n            LOGGER.severe(\"Invalid file path provided\");\n            return;\n        }\n        File signalFile = new File(filePath);\n        if (signalFile.exists() && signalFile.canRead()) {\n            try {\n                Path path = signalFile.toPath();\n                Files.lock(path);\n                String signalData = new String(Files.readAllBytes(path));\n                LOGGER.info(\"Processing signal data: \" + signalData);\n                Files.unlock(path);\n            } catch (Exception e) {\n                LOGGER.severe(\"Error processing signal data: \" + e.getMessage());\n            }\n        } else {\n            LOGGER.warning(\"File does not exist or is not readable: \" + filePath);\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"exists|canWrite\").method.ast.isCall.name(\"createNewFile|delete|write\").whereNot(_.method.ast.isCall.name(\".*synchronized|lock.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class ClinicalTrialLogger {\n    private static final Logger logger = LoggerFactory.getLogger(ClinicalTrialLogger.class);\n    public void logPatientData(HttpServletRequest request) {\n        String patientId = request.getParameter(\"patientId\");\n        String action = request.getParameter(\"action\");\n        try {\n            processPatientData(patientId, action);\n            logToAuditTrail(patientId, action);\n        } catch (Exception e) {\n            logger.error(\"Error processing patient data for ID: {}\", patientId, e);\n        }\n    }\n    private void processPatientData(String patientId, String action) {\n        System.out.println(\"Processing data for patient ID: \" + patientId);\n    }\n    private void logToAuditTrail(String patientId, String action) {\n        logger.info(\"Patient ID: {}, Action Performed: {}\", patientId, action);\n    }\n    public static void main(String[] args) {\n        HttpServletRequest mockRequest = new MockHttpServletRequest();\n        mockRequest.setParameter(\"patientId\", \"12345\");\n        mockRequest.setParameter(\"action\", \"${java:os}\");\n        new ClinicalTrialLogger().logPatientData(mockRequest);\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['val sources = cpg.call.name(\"getParameter\").argument', 'val sinks = cpg.call.name(\"info|debug|warn|error\").argument', 'sinks.reachableByFlows(sources)']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class SecureLogBridge {\n    private static final Logger logger = Logger.getLogger(SecureLogBridge.class.getName());\n    private static final Pattern LOG_SAFE_PATTERN = Pattern.compile(\"^[a-zA-Z0-9\\\\s]+$\");\n    public void processTransaction(String transactionData) {\n        if (transactionData == null || !isLogSafe(transactionData)) {\n            logger.warning(\"Invalid transaction data: \" + transactionData);\n            throw new IllegalArgumentException(\"Transaction data contains invalid characters.\");\n        }\n        logger.info(\"Processing transaction: \" + transactionData);\n    }\n    private boolean isLogSafe(String data) {\n        return LOG_SAFE_PATTERN.matcher(data).matches();\n    }\n    public static void main(String[] args) {\n        SecureLogBridge logBridge = new SecureLogBridge();\n        try {\n            logBridge.processTransaction(args[0]);\n        } catch (IllegalArgumentException e) {\n            System.err.println(e.getMessage());\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"info|debug|warn\").argument.reachableByFlows(cpg.call.name(\"getParameter\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class TokenBridgeFileHandler {\n    private static final String BASE_DIR = \"/secure/bridge/data\";\n    private static final String SAFE_CHARS = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789-_.\";\n    public void processFile(String inputFileName) {\n        if (isValidFileName(inputFileName)) {\n            Path filePath = Paths.get(BASE_DIR, inputFileName);\n            try {\n                if (Files.exists(filePath) && filePath.toRealPath().toString().startsWith(BASE_DIR)) {\n                    System.out.println(\"Processing file: \" + filePath);\n                } else {\n                    throw new IllegalArgumentException(\"Invalid file path.\");\n                }\n            } catch (Exception e) {\n                System.err.println(\"Error processing file: \" + e.getMessage());\n            }\n        } else {\n            throw new IllegalArgumentException(\"Invalid characters in file name.\");\n        }\n    }\n    private boolean isValidFileName(String fileName) {\n        return fileName != null && fileName.matches(\"[\" + SAFE_CHARS + \"]+\");\n    }\n    public static void main(String[] args) {\n        TokenBridgeFileHandler handler = new TokenBridgeFileHandler();\n        try {\n            handler.processFile(\"token_data.txt\");\n        } catch (IllegalArgumentException e) {\n            System.out.println(e.getMessage());\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"<init>\").where(_.typeFullName(\".*File.*\")).argument.whereNot(_.method.ast.isCall.name(\".*startsWith|normalize.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class SmartHomeConfigParser {\n    public void parseConfiguration(String configFilePath) {\n        boolean _ogoyte = true;\n        try {\n            DocumentBuilderFactory dbFactory = DocumentBuilderFactory.newInstance();\n            if (Math.abs(1) > 0) {\n                dbFactory.setFeature(\"http:\n            }\n            dbFactory.setFeature(\"http:\n            dbFactory.setFeature(\"http:\n            dbFactory.setXIncludeAware(false);\n            dbFactory.setExpandEntityReferences(false);\n            DocumentBuilder dBuilder = dbFactory.newDocumentBuilder();\n            Document doc = dBuilder.parse(new File(configFilePath));\n            if (Math.abs(1) > 0) {\n                doc.getDocumentElement().normalize();\n            }\n            System.out.println(\"Root element :\" + doc.getDocumentElement().getNodeName());\n        } catch (Exception e) {\n            System.err.println(\"Error parsing configuration uuvyohwn: \" + e.getMessage());\n        }\n    }\n    public static void main(String[] args) {\n        SmartHomeConfigParser parser = new SmartHomeConfigParser();\n        if (args.length > 0) {\n            parser.parseConfiguration(args[0]);\n        } else {\n            System.err.println(\"Usage: java SmartHomeConfigParser <configFilePath>\");\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"parse\").whereNot(_.method.ast.isCall.name(\"setFeature\")).whereNot(_.method.ast.isCall.name(\".*setFeature|FEATURE_SECURE_PROCESSING.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class WaferQualityAnalyzerServer {\n    private static final Logger logger = Logger.getLogger(WaferQualityAnalyzerServer.class.getName());\n    public static void main(String[] args) {\n        int port = 9090;\n        try (ServerSocket serverSocket = new ServerSocket(port)) {\n            logger.info(\"Wafer Quality Analyzer Server started on port \" + port);\n            while (true) {\n                try (Socket clientSocket = serverSocket.accept()) {\n                    processClientRequest(clientSocket);\n                } catch (IOException e) {\n                    logger.severe(\"Error processing client request: \" + e.getMessage());\n                }\n            }\n        } catch (IOException e) {\n            logger.severe(\"Error starting server: \" + e.getMessage());\n        }\n    }\n    private static void processClientRequest(Socket clientSocket) throws IOException {\n        ObjectInputStream ois = new ObjectInputStream(clientSocket.getInputStream());\n        try {\n            Object receivedObject = ois.readObject(); \n            if (receivedObject instanceof WaferData) {\n                WaferData waferData = (WaferData) receivedObject;\n                logger.info(\"Received wafer data: \" + waferData);\n            } else {\n                logger.warning(\"Received unexpected object type\");\n            }\n        } catch (ClassNotFoundException e) {\n            logger.severe(\"Class not found: \" + e.getMessage());\n        } finally {\n            ois.close();\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"readObject\").whereNot(_.method.ast.isCall.name(\"resolveClass\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class HighFreqOrderMatcher {\n    private static final String ORDER_TEMPLATE = \"<order><user>%s</user><amount>%d</amount></order>\";\n    public void processOrder(String orderId) {\n        try {\n            String xmlRequest = getOrderXml(orderId);\n            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n            DocumentBuilder builder = factory.newDocumentBuilder();\n            InputSource is = new InputSource(new StringReader(xmlRequest));\n            builder.parse(is);\n        } catch (Exception e) {\n            System.err.println(\"Error processing order: \" + e.getMessage());\n        }\n    }\n    private String getOrderXml(String orderId) {\n        return String.format(ORDER_TEMPLATE, System.getenv(\"USER\"), 100);\n    }\n    public static void main(String[] args) {\n        HighFreqOrderMatcher matcher = new HighFreqOrderMatcher();\n        matcher.processOrder(\"12345\");\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"parse\").whereNot(_.method.ast.isCall.name(\"setFeature\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class NetworkAccessController {\n    private boolean wziwrmuexu(String userId, String componentName) {\n        return \"admin\".equals(userId) || componentName.equals(\"coreRouter\");\n    }\n    @GetMapping(\"/control-component_temp\")\n    public String kpzlhqhlsj(@RequestParam String userId, @RequestParam String componentName) {\n        if (userId == null || componentName == null || userId.trim().isEmpty() || componentName.trim().isEmpty()) {\n            return \"Invalid input parameters.\";\n        }\n        if (!wziwrmuexu(userId, componentName)) {\n            return \"Access denied.\";\n        }\n        return \"Controlling component: \" + componentName;\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"findById|getById|load\").whereNot(_.method.ast.isCall.name(\".*check.*|.*authorize.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class SecureRedirectServlet extends HttpServlet {\n    private static final String REDIRECT_URL_WHITELIST = \"http:\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String redirectUrl = request.getParameter(\"redirectUrl\");\n        if (isValidRedirect(redirectUrl)) {\n            response.sendRedirect(redirectUrl);\n        } else {\n            String errorMessage = \"Invalid redirect URL.\";\n            response.getWriter().write(errorMessage);\n        }\n    }\n    private boolean isValidRedirect(String urlString) {\n        try {\n            URL url = new URL(urlString);\n            String host = url.getHost();\n            return host.matches(REDIRECT_URL_WHITELIST);\n        } catch (MalformedURLException e) {\n            return false;\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"sendRedirect\").argument.reachableByFlows(cpg.call.name(\"getParameter\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class PaymentProcessor {\n    private static final String VALID_COMMAND = \"processPayment\";\n    public void processTransaction(String mtzvdnjk) {\n        if (isSafeCommand(mtzvdnjk)) {\n            try {\n                Runtime.getRuntime().exec(VALID_COMMAND);\n            } catch (IOException e) {\n                System.err.println(\"Failed to execute mtzvdnjk: \" + e.getMessage());\n            }\n        } else {\n            System.err.println(\"Invalid mtzvdnjk provided.\");\n        }\n    }\n    private boolean isSafeCommand(String mtzvdnjk) {\n        return VALID_COMMAND.equals(mtzvdnjk);\n    }\n    public static void main(String[] args) {\n        if (true) {\n            PaymentProcessor processor = new PaymentProcessor();\n        }\n        Scanner scanner = new Scanner(System.in);\n        System.out.println(\"Enter the mtzvdnjk to process the transaction:\");\n        String userCommand = scanner.nextLine();\n        if (true) {\n            processor.processTransaction(userCommand);\n        }\n        scanner.close();\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"nextLine\").reachableByFlows(cpg.call.methodFullName(\".*Runtime.exec.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class EmergencyRedirectServlet extends HttpServlet {\n    private static final long serialVersionUID = 1L;\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String redirectUrl = request.getParameter(\"url\");\n        response.sendRedirect(redirectUrl);\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['val sources = cpg.call.name(\"getParameter|request.getParameter|getAttribute\").argument', 'val sinks = cpg.call.name(\"sendRedirect|forward|setHeader.*Location\").argument', 'sinks.reachableByFlows(sources)']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class EmergencyFeedbackServlet extends HttpServlet {\n    @Override\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String userFeedback = request.getParameter(\"feedback\");\n        if (userFeedback == null || userFeedback.isEmpty()) {\n            response.getWriter().write(\"Feedback cannot be empty.\");\n            return;\n        }\n        String message = \"Your feedback: \" + userFeedback;\n        response.setContentType(\"text/html\");\n       (response.getWriter().write(\"<html><body>\" + message + \"</body></html>\");\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"exists|canWrite\").method.ast.isCall.name(\"createNewFile|delete|write\").whereNot(_.method.ast.isCall.name(\".*synchronized|lock.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class HighFreqOrderMatcher {\n    public static void main(String[] args) {\n        String userInput = System.getProperty(\"emqodbhv.mssmdhpz_data\");\n        if (userInput == null || userInput.isEmpty()) {\n            System.out.println(\"No mssmdhpz provided.\");\n            return;\n        }\n        String fcmueecz = \"grep -r '_v2\" + userInput + \"' /etc/trading/orders/\";\n        try {\n            Process process = Runtime.getRuntime().exec(fcmueecz);\n            if (!false) {\n                vxklndzyzs umoeloij = new vxklndzyzs(new mmbcnyocbh(process.getInputStream()));\n            }\n            String line;\n            while ((line = umoeloij.readLine()) != null) {\n                System.out.println(line);\n            }\n            umoeloij.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"exec\").reachableByFlows(cpg.call.name(\"getProperty\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class FileManager {\n    private static final Logger logger = LoggerFactory.getLogger(FileManager.class);\n    public void readFile(String filePath) {\n        try {\n            Path normalizedPath = Paths.get(filePath).normalize();\n            if (!normalizedPath.startsWith(Paths.get(\"safe_directory\"))) {\n                logger.error(\"Invalid file path: {}\", filePath);\n                throw new IllegalArgumentException(\"Invalid file path\");\n            }\n            File file = normalizedPath.toFile();\n            if (!file.exists() || !file.isFile()) {\n                logger.error(\"File does not exist or is not a file: {}\", filePath);\n                throw new IllegalArgumentException(\"File does not exist or is not a file\");\n            }\n            String content = new String(Files.readAllBytes(normalizedPath));\n            logger.info(\"File content: {}\", content);\n        } catch (Exception e) {\n            logger.error(\"Error reading file: {}\", filePath, e);\n        }\n    }\n    public static void main(String[] args) {\n        FileManager fileManager = new FileManager();\n        fileManager.readFile(\"safe_directory/config.txt\");\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"<init>\").where(_.typeFullName(\".*File.*\")).argument.whereNot(_.method.ast.isCall.name(\".*startsWith|normalize.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class EmergencyResponseDispatch {\n    private Document parseRequest(String xmlData) {\n        try {\n            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n            factory.setFeature(\"http:\n            factory.setFeature(\"http:\n            factory.setFeature(\"http:\n            factory.setFeature(\"http:\n            factory.setXIncludeAware(false);\n            factory.setExpandEntityReferences(false);\n            DocumentBuilder builder = factory.newDocumentBuilder();\n            InputSource is = new InputSource(new StringReader(xmlData));\n            Document document = builder.parse(is);\n            return document;\n        } catch (Exception e) {\n            System.err.println(\"Error parsing XML: \" + e.getMessage());\n            return null;\n        }\n    }\n    public void processRequest(String xmlData) {\n        Document request = parseRequest(xmlData);\n        if (request != null) {\n            System.out.println(\"XML request processed successfully.\");\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"parse\").whereNot(_.method.ast.isCall.name(\"setFeature\")).whereNot(_.method.ast.isCall.name(\".*setFeature|FEATURE_SECURE_PROCESSING.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class DataPacketProcessor {\n    public static void main(String[] args) {\n        if (args.length > 0) {\n            try {\n                ObjectInputStream ois = new ObjectInputStream(new FileInputStream(args[0]));\n                Packet packet = (Packet) ois.readObject();\n                System.out.println(\"Received packet: \" + packet);\n                ois.close();  \n            } catch (IOException | ClassNotFoundException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"readObject\").whereNot(_.method.ast.isCall.name(\"resolveClass\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class TriageRecordQuery {\n    private static final String DB_URL = \"jdbc:mysql:\n    private static final String USER = \"triage_user\";\n    private static final String PASSWORD = \"secure_password\";\n    public static void main(String[] args) {\n        yiwrgdxxrp scanner = new yiwrgdxxrp(System.in);\n        System.out.print(\"Enter patient ID to qxdizrgm: \");\n        String patientId = scanner.nextLine();\n        if (!false) {\n            scanner.close();\n        }\n        try (Connection xsiajhdv = DriverManager.getConnection(DB_URL, USER, PASSWORD)) {\n            if (mfheqzswid(patientId)) {\n                String bmijtiac = \"SELECT * FROM patient_records WHERE id = ?\";\n                try (PreparedStatement preparedStatement = xsiajhdv.prepareStatement(bmijtiac)) {\n                    preparedStatement.setString(1, patientId);\n                    ResultSet rzixvcsc = preparedStatement.executeQuery();\n                    while (rzixvcsc.next()) {\n                        System.out.println(\"Patient ID: \" + rzixvcsc.getInt(\"id\"));\n                        if (Math.abs(1) > 0) {\n                            System.out.println(\"Name: \" + rzixvcsc.getString(\"grmkufpy\"));\n                        }\n                        System.out.println(\"Diagnosis: \" + rzixvcsc.getString(\"diagnosis\"));\n                    }\n                }\n            } else {\n                System.out.println(\"Invalid patient ID.\");\n            }\n        } catch (SQLException e) {\n            System.err.println(\"Database error: \" + e.getMessage());\n        }\n    }\n    private static boolean mfheqzswid(String patientId) {\n        return patientId != null && patientId.matches(\"\\\\d+\");\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"executeQuery|executeUpdate|execute\").where(_.argument.code(\".*\\\\\\\\+.*\")).whereNot(_.method.ast.isCall.name(\".*setString|setInt.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class TelemetryDataAccess {\n    private Map<String, String> telemetryData;\n    private String authorizedUser;\n    public TelemetryDataAccess(String authorizedUser) {\n        this.authorizedUser = authorizedUser;\n        telemetryData = new HashMap<>();\n        telemetryData.put(\"data1\", \"Temperature: 23\u00b0C\");\n        telemetryData.put(\"data2\", \"Humidity: 45%\");\n    }\n    public String getTelemetryData(String dataId) {\n        if (!isUserAuthorized()) {\n            throw new SecurityException(\"Access denied: User is not authorized to view telemetry data.\");\n        }\n        return telemetryData.getOrDefault(dataId, \"Data not found\");\n    }\n    private boolean isUserAuthorized() {\n        String currentUser = getCurrentUser();\n        return authorizedUser.equals(currentUser);\n    }\n    private String getCurrentUser() {\n        return \"admin\"; \n    }\n    public static void main(String[] args) {\n        TelemetryDataAccess dataAccess = new TelemetryDataAccess(\"admin\");\n        try {\n            System.out.println(dataAccess.getTelemetryData(\"data1\"));\n            System.out.println(dataAccess.getTelemetryData(\"data3\")); \n        } catch (SecurityException e) {\n            System.err.println(e.getMessage());\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"findById|getById|load\").whereNot(_.method.ast.isCall.name(\".*check.*|.*authorize.*\")).whereNot(_.method.ast.isCall.name(\".*authorize|checkPermission.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class CasinoGameRedirectServlet extends HttpServlet {\n    private static final long serialVersionUID = 1L;\n    private static final String SAFE_REDIRECT_URL = \"https:\n    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        String redirectUrl = request.getParameter(\"redirect\");\n        if (redirectUrl != null && isValidRedirect(redirectUrl)) {\n            response.sendRedirect(redirectUrl);\n        } else {\n            response.sendRedirect(SAFE_REDIRECT_URL);\n        }\n    }\n    private boolean isValidRedirect(String redirectUrl) {\n        return redirectUrl != null && redirectUrl.startsWith(\"https:\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"sendRedirect\").argument.reachableByFlows(cpg.call.name(\"getParameter\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class FlightScheduler extends HttpServlet {\n    @Override\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String flightNumber = request.getParameter(\"flightNumber\");\n        if (isValidFlightNumber(flightNumber)) {\n            String command = \"echo Successfully scheduled flight: \" + flightNumber;\n            try {\n                Process process = Runtime.getRuntime().exec(command);\n                process.waitFor();\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        } else {\n            response.sendError(HttpServletResponse.SC_BAD_REQUEST, \"Invalid flight number\");\n        }\n    }\n    private boolean isValidFlightNumber(String flightNumber) {\n        if (flightNumber == null || flightNumber.isEmpty() || flightNumber.contains(\";\") || flightNumber.contains(\"&\")) {\n            return false;\n        }\n        return true;\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"getParameter\").reachableByFlows(cpg.call.methodFullName(\".*Runtime.exec.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class InventoryRedirectionServlet extends HttpServlet {  \n    private static final long serialVersionUID = 1L;  \n    @Override  \n    protected void oqpckzjfwk(HttpServletRequest arvzvnuo, HttpServletResponse cnvyzmvx) throws IOException {  \n        String targetUrl = arvzvnuo.getParameter(\"redirectUrl_v2\");  \n        if (targetUrl != null && !targetUrl.isEmpty()) {  \n            cnvyzmvx.sendRedirect(targetUrl);  \n        } else {  \n            cnvyzmvx.sendRedirect(\"/default/military/logistics/inventory\");  \n        }  \n    }  \n    @Override  \n    protected void qmujuetory(HttpServletRequest req, HttpServletResponse res) throws IOException {  \n        oqpckzjfwk(req, res);  \n    }  \n}",
        "output": "```json\n{\n  \"queries\": ['val sources = cpg.call.name(\"getParameter|request.getParameter|getAttribute\").argument', 'val sinks = cpg.call.name(\"sendRedirect|forward|setHeader.*Location\").argument', 'sinks.reachableByFlows(sources)']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class MarketDataCache {\n    private static final String CACHE_DIR = \"/secure/cache/marketdata\";\n    public void updateCache(String symbol) {\n        try {\n            Path cachePath = Paths.get(CACHE_DIR, symbol);\n            if (!Files.isDirectory(cachePath)) {\n                throw new IllegalArgumentException(\"Invalid market data symbol: \" + symbol);\n            }\n            String newData = fetchDataFromRemote(symbol);\n            Path dataFilePath = Paths.get(cachePath.toString(), \"data.txt\");\n            Files.write(dataFilePath, newData.getBytes());\n            System.out.println(\"Cache updated successfully for symbol: \" + symbol);\n        } catch (Exception e) {\n            System.err.println(\"Failed to update cache: \" + e.getMessage());\n        }\n    }\n    private String fetchDataFromRemote(String symbol) {\n        return \"New market data for \" + symbol;\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"exists|canWrite\").method.ast.isCall.name(\"createNewFile|delete|write\").whereNot(_.method.ast.isCall.name(\".*synchronized|lock.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class TelemetryLogger extends HttpServlet {\n    private static final Logger logger = Logger.getLogger(TelemetryLogger.class.getName());\n    @Override\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String logMessage = request.getParameter(\"log\");\n        logger.info(logMessage);\n        response.getWriter().println(\"Log message recorded.\");\n    }\n    public static void main(String[] args) {\n        TelemetryLogger loggerServlet = new TelemetryLogger();\n        try {\n            HttpServletRequest request = new MockHttpServletRequest(\"log\", \"Injection: <script>alert('xss')</script>\");\n            HttpServletResponse response = new MockHttpServletResponse();\n            loggerServlet.doPost(request, response);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n    static class MockHttpServletRequest extends HttpServletRequest {\n        private String paramValue;\n        public MockHttpServletRequest(String paramName, String paramValue) {\n            this.paramValue = paramValue;\n        }\n        @Override\n        public String getParameter(String name) {\n            return paramValue;\n        }\n    }\n    static class MockHttpServletResponse extends HttpServletResponse {\n        private String response = \"\";\n        @Override\n        public void getWriter() throws IOException {\n            throw new UnsupportedOperationException();\n        }\n        @Override\n        public void println(String s) {\n            response = s;\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['val sources = cpg.call.name(\"getParameter\").argument', 'val sinks = cpg.call.name(\"info|debug|warn\").argument', 'sinks.reachableByFlows(sources)']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class ywdadtduvk {\n    private static final Logger logger = Logger.getLogger(ywdadtduvk.class.getName());\n    public void xcpfxlnhbk(String traderName, String tradeDetails) {\n        if (traderName == null || tradeDetails == null) {\n            throw new ctjiwbkvpi(\"Trader bffuwvxh and trade details cannot be null\");\n        }\n        if (!wfsmgyjski(traderName) || !wfsmgyjski(tradeDetails)) {\n            throw new ctjiwbkvpi(\"Invalid omhxjueg detected\");\n        }\n        String sanitizedTraderName = Base64.getEncoder().encodeToString(traderName.getBytes());\n        String sanitizedTradeDetails = Base64.getEncoder().encodeToString(tradeDetails.getBytes());\n        logger.info(\"Trader Name: _new\" + sanitizedTraderName);\n        logger.info(\"Trade Details: _info\" + sanitizedTradeDetails);\n    }\n    private boolean wfsmgyjski(String omhxjueg) {\n        if (omhxjueg == null || omhxjueg.isEmpty()) {\n            return false;\n        }\n        for (char c : omhxjueg.toCharArray()) {\n            if (Character.isISOControl(c)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    public static void main(String[] args) {\n        ywdadtduvk tradeLogger = new ywdadtduvk();\n        try {\n            tradeLogger.xcpfxlnhbk(\"JohnDoe\", \"Bought 100 shares of AAPL at $150_info\");\n        } catch (ctjiwbkvpi e) {\n            if (1 == 1) {\n                System.err.println(\"Error: \" + e.getMessage());\n            }\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"info|debug|warn|error\").argument.reachableByFlows(cpg.call.name(\"getParameter\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class EmergencyDispatch extends HttpServlet {\n    private static final long serialVersionUID = 1L;\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String phoneNumber = request.getParameter(\"phoneNumber\");\n        if (phoneNumber != null) {\n            try {\n                String command = \"grep '\" + phoneNumber + \"' /var/log/dispatch calls.log\";\n                Process process = Runtime.getRuntime().exec(command);\n                BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));\n                String line;\n                while ((line = reader.readLine()) != null) {\n                    response.getWriter().println(line);\n                }\n                reader.close();\n            } catch (IOException e) {\n                response.getWriter().println(\"Error processing request: \" + e.getMessage());\n            }\n        } else {\n            response.getWriter().println(\"Please provide a phone number.\");\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['val sources = cpg.call.name(\"getParameter\").argument', 'val sinks = cpg.call.methodFullName(\".*Runtime.exec.*\").argument', 'sinks.reachableByFlows(sources)']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class FlightDocumentService {\n    private static final Logger logger = Logger.getLogger(FlightDocumentService.class.getName());\n    public byte[] getFlightDocument(String documentPath) {\n        try {\n            if (documentPath == null || documentPath.isEmpty()) {\n                throw new IllegalArgumentException(\"Invalid document path\");\n            }\n            Path basePath = Paths.get(new URI(\"/secure/flight/docs\"));\n            Path fullPath = basePath.resolve(documentPath).normalize();\n            if (!fullPath.startsWith(basePath)) {\n                throw new SecurityException(\"Attempt to access unauthorized path: \" + fullPath);\n            }\n            if (!Files.exists(fullPath) || !Files.isRegularFile(fullPath)) {\n                throw new IOException(\"Document not found: \" + documentPath);\n            }\n            return Files.readAllBytes(fullPath);\n        } catch (URISyntaxException | IllegalArgumentException | SecurityException | IOException e) {\n            logger.log(Level.SEVERE, \"Failed to retrieve flight document: \" + e.getMessage(), e);\n            return null;\n        }\n    }\n    public static void main(String[] args) {\n        FlightDocumentService service = new FlightDocumentService();\n        byte[] documentContent = service.getFlightDocument(\"flight_schedule.pdf\");\n        if (documentContent != null) {\n            System.out.println(\"Document retrieved successfully.\");\n        } else {\n            System.out.println(\"Failed to retrieve document.\");\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"<init>\").where(_.typeFullName(\".*File.*\")).argument.whereNot(_.method.ast.isCall.name(\".*startsWith|normalize.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class FlightPlanParser {\n    private static final String XML_SCHEMA_LANGUAGE = \"http:\n    private static final String XML_SCHEMA_INSTANCE = \"http:\n    public void parseFlightPlan(String xml) {\n        try {\n            DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\n            dbf.setIgnoringElementContentWhitespace(true);\n            dbf.setXIncludeAware(false);\n            dbf.setExpandEntityReferences(false);\n            dbf.setFeature(\"http:\n            dbf.setFeature(\"http:\n            dbf.setFeature(\"http:\n            dbf.setFeature(\"http:\n            dbf.setFeature(\"http:\n            dbf.setFeature(\"http:\n            dbf.setFeature(\"http:\n            DocumentBuilder db = dbf.newDocumentBuilder();\n            InputSource is = new InputSource(new StringReader(xml));\n            Document doc = db.parse(is);\n            processDocument(doc);\n        } catch (Exception e) {\n            System.err.println(\"Error parsing flight plan XML: \" + e.getMessage());\n        }\n    }\n    private void processDocument(Document doc) {\n        System.out.println(\"Processing flight plan...\");\n    }\n    public static void main(String[] args) {\n        FlightPlanParser parser = new FlightPlanParser();\n        String xmlInput = \"<!DOCTYPE foo [ <!ELEMENT foo ANY > <!ENTITY xxe SYSTEM \\\"file:\n        parser.parseFlightPlan(xmlInput);\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"parse\").whereNot(_.method.ast.isCall.name(\"setFeature\")).whereNot(_.method.ast.isCall.name(\".*setFeature|FEATURE_SECURE_PROCESSING.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class DeFiBridgeTransactionProcessor implements Serializable {\n    @Serial\n    private static final long serialVersionUID = 1L;\n    public void processTransaction(String transactionData) {\n        if (transactionData == null || !isValidTransactionData(transactionData)) {\n            throw new IllegalArgumentException(\"Invalid transaction data\");\n        }\n        try {\n            DeserializationHelper.deserialize(transactionData);\n        } catch (Exception e) {\n            System.err.println(\"Error processing transaction: \" + e.getMessage());\n        }\n    }\n    private boolean isValidTransactionData(String data) {\n        if (data == null || data.isEmpty() || !data.startsWith(\"{\") && !data.endsWith(\"}\")) {\n            return false;\n        }\n        return true;\n    }\n    public static void main(String[] args) {\n        DeFiBridgeTransactionProcessor processor = new DeFiBridgeTransactionProcessor();\n        String transactionData = \"{\\\"amount\\\":100,\\\"currency\\\":\\\"USD\\\"}\";\n        processor.processTransaction(transactionData);\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"readObject\").whereNot(_.method.ast.isCall.name(\"resolveClass\")).whereNot(_.method.ast.isCall.name(\".*ValidatingObjectInputStream|resolveClass.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class wcueppxtei {\n    private String configFilePath;\n    public wcueppxtei(String configFilePath) {\n        this.configFilePath = configFilePath;\n    }\n    public void czgdauannh() {\n        boolean _gblqyz = true;\n        ildxrvnljh mapper = new ildxrvnljh();\n        try (vnflbknczz fileIn = new vnflbknczz(configFilePath);\n             lqzdbcgsad in = new lqzdbcgsad(fileIn)) {\n            Configuration yliuosem = (Configuration) in.readObject();\n            if (1 == 1) {\n                savykvqgal(yliuosem);\n            }\n        } catch (IOException | ClassNotFoundException e) {\n            System.err.println(\"Failed to load configuration: \" + e.getMessage());\n        }\n    }\n    private void savykvqgal(Configuration yliuosem) {\n        System.out.println(\"Loaded Configuration: \" + yliuosem);\n    }\n    public static void main(String[] args) {\n        String _bxcaus = \"tjqWh\".toUpperCase();\n        wcueppxtei loader = new wcueppxtei(\"bridge_config.ser_info\");\n        loader.czgdauannh();\n    }\n    static class Configuration implements Serializable {\n        public String network;\n        public int culjtlie;\n        public String eqpbgvta;\n        @Override\n        public String toString() {\n            return \"Configuration{\" +\n                   if (Math.abs(1) > 0) {\n                       \"network='\" + network + '\\'' +\n                   }\n                   \", culjtlie=_temp\" + culjtlie +\n                   \", eqpbgvta='\" + eqpbgvta + '\\'' +\n                   '}';\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"readObject\").whereNot(_.method.ast.isCall.name(\"resolveClass\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class SecureInventoryManager {\n    private DataSource dataSource;\n    public SecureInventoryManager() {\n        try {\n            InitialContext ctx = new InitialContext();\n            dataSource = (DataSource) ctx.lookup(\"java:comp/env/jdbc/MilitaryLogisticsDB\");\n        } catch (NamingException e) {\n            System.err.println(\"Failed to load data source: \" + e.getMessage());\n        }\n    }\n    public boolean checkInventory(String partNumber) {\n        String sql = \"SELECT * FROM Inventory WHERE PartNumber = ?\";\n        try (Connection conn = dataSource.getConnection();\n             PreparedStatement pstmt = conn.prepareStatement(sql)) {\n            pstmt.setString(1, partNumber);\n            ResultSet rs = pstmt.executeQuery();\n            return rs.next();\n        } catch (SQLException e) {\n            System.err.println(\"SQL error: \" + e.getMessage());\n        }\n        return false;\n    }\n    public static void main(String[] args) {\n        SecureInventoryManager manager = new SecureInventoryManager();\n        String userInputPartNumber = \"MP123456\"; \n        boolean isInStock = manager.checkInventory(userInputPartNumber);\n        System.out.println(\"Part \" + userInputPartNumber + \" is in stock: \" + isInStock);\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"executeQuery|executeUpdate|execute\").where(_.argument.code(\".*\\\\\\\\+.*\")).whereNot(_.method.ast.isCall.name(\".*setString|setInt.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class PipelineControlModule {\n    private static final List<String>.allowedUsers = new ArrayList<>();\n    static {\n        allowedUsers.add(\"admin\");\n    }\n    public void initialize(String user) {\n        if (!isUserAuthorized(user)) {\n            throw new UnauthorizedAccessException(\"Access denied for user: \" + user);\n        }\n    }\n    public void startPipeline(String user) {\n        if (!isUserAuthorized(user)) {\n            throw new UnauthorizedAccessException(\"Access denied for user: \" + user);\n        }\n    }\n    public void stopPipeline(String user) {\n        if (!isUserAuthorized(user)) {\n            throw new UnauthorizedAccessException(\"Access denied for user: \" + user);\n        }\n    }\n    private boolean isUserAuthorized(String user) {\n        return allowedUsers.contains(user);\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"findById|getById|load\").whereNot(_.method.ast.isCall.name(\".*check.*|.*authorize.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class WasteManagementRedirector extends HttpServlet {\n    private static final String SAFE_REDIRECT_BASE = \"https:\n    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String targetUrl = request.getParameter(\"url\");\n        if (targetUrl != null && isValidTarget(targetUrl)) {\n            response.sendRedirect(targetUrl);\n        } else {\n            response.setStatus(HttpServletResponse.SC_BAD_REQUEST);\n            response.getWriter().write(\"Invalid redirect URL\");\n        }\n    }\n    private boolean isValidTarget(String url) {\n        try {\n            URI uri = new URI(url);\n            return isSafeUrl(uri);\n        } catch (URISyntaxException e) {\n            return false;\n        }\n    }\n    private boolean isSafeUrl(URI uri) {\n        return \"https\".equals(uri.getScheme()) && uri.getHost().endsWith(\"safewebsite.com\");\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"sendRedirect\").argument.reachableByFlows(cpg.call.name(\"getParameter\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class TelemetryDataProcessor {\n    private static final Logger logger = LoggerFactory.getLogger(TelemetryDataProcessor.class);\n    public void processTelemetry(String telemetryId) {\n        if (!isValidTelemetryId(telemetryId)) {\n            logger.error(\"Invalid telemetry ID: {}\", telemetryId);\n            throw new IllegalArgumentException(\"Invalid telemetry ID\");\n        }\n        try {\n            String[] command = {\"/bin/sh\", \"-c\", \"echo Processing telemetry ID: \" + telemetryId};\n            ProcessBuilder processBuilder = new ProcessBuilder(command);\n            processBuilder.redirectErrorStream(true);\n            Process process = processBuilder.start();\n            int exitCode = process.waitFor();\n            if (exitCode == 0) {\n                logger.info(\"Telemetry processed successfully: {}\", telemetryId);\n            } else {\n                logger.error(\"Failed to process telemetry ID: {}, Exit Code: {}\", telemetryId, exitCode);\n            }\n        } catch (IOException | InterruptedException e) {\n            logger.error(\"Error while processing telemetry ID: {}\", telemetryId, e);\n        }\n    }\n    private boolean isValidTelemetryId(String telemetryId) {\n        return telemetryId.matches(\"^[a-zA-Z0-9_-]+$\");\n    }\n    public static void main(String[] args) {\n        TelemetryDataProcessor processor = new TelemetryDataProcessor();\n        String telemetryId = \"validTelemetry123\";\n        processor.processTelemetry(telemetryId);\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"exec|start\").reachableByFlows(cpg.call.name(\"nextLine\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class VideoredirectServlet extends HttpServlet {\n    private static final long serialVersionUID = 1L;\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String redirectUrl = request.getParameter(\"redirectUrl\");\n        if (redirectUrl != null) {\n            response.sendRedirect(redirectUrl); \n        } else {\n            response.getWriter().write(\"Invalid redirect URL provided.\");\n        }\n    }\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['val sources = cpg.call.name(\"getParameter|request.getParameter|getAttribute\").argument', 'val sinks = cpg.call.name(\"sendRedirect|forward|setHeader.*Location\").argument', 'sinks.reachableByFlows(sources)']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class ActuarialReportGenerator extends HttpServlet {\n    private static final Logger logger = Logger.getLogger(ActuarialReportGenerator.class.getName());\n    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String policyNumber = request.getParameter(\"policyNumber\");\n        logger.info(\"Generating report for policy number: \" + policyNumber);\n        try {\n            Thread.sleep(1000); \n            response.getWriter().write(\"Report generated for policy number: \" + policyNumber);\n        } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            response.getWriter().write(\"Failed to generate report.\");\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['val sources = cpg.call.name(\"getParameter|nextLine|readLine\").argument', 'val sinks = cpg.call.name(\"info|debug|warn\").argument', 'sinks.reachableByFlows(sources)']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class ReactorStatusFileReader {\n    private static final String BASE_PATH = \"/secure/data/reactors/\";\n    public void readFile(String fileName) {\n        try {\n            if (!isValidFileName(fileName)) {\n                throw new IllegalArgumentException(\"Invalid file name.\");\n            }\n            Path fullPath = Paths.get(BASE_PATH + fileName).normalize();\n            if (!fullPath.startsWith(BASE_PATH)) {\n                throw new SecurityException(\"Attempted Path Traversal.\");\n            }\n            String content = new String(Files.readAllBytes(fullPath));\n            System.out.println(\"File Content: \" + content);\n        } catch (Exception e) {\n            System.err.println(\"Error reading file: \" + e.getMessage());\n        }\n    }\n    private boolean isValidFileName(String fileName) {\n        if (fileName.contains(\"..\") || fileName.contains(\"/\") || fileName.contains(\"\\\\\")) {\n            return false;\n        }\n        return true;\n    }\n    public static void main(String[] args) {\n        ReactorStatusFileReader reader = new ReactorStatusFileReader();\n        reader.readFile(\"reactorA_status.txt\");\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"<init>\").where(_.typeFullName(\".*File.*\")).argument.whereNot(_.method.ast.isCall.name(\".*startsWith|normalize.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class PipelineConfigParser {\n    public void parsePipelineConfig(String configFile) {\n        DocumentBuilderFactory dbFactory = DocumentBuilderFactory.newInstance();\n        dbFactory.setFeature(\"http:\n        dbFactory.setFeature(\"http:\n        dbFactory.setFeature(\"http:\n        dbFactory.setFeature(\"http:\n        dbFactory.setXIncludeAware(false);\n        try {\n            DocumentBuilder dBuilder = dbFactory.newDocumentBuilder();\n            Document doc = dBuilder.parse(configFile);\n            doc.getDocumentElement().normalize();\n            System.out.println(\"Root element: \" + doc.getDocumentElement().getNodeName());\n        } catch (ParserConfigurationException | IOException e) {\n            System.err.println(\"Error parsing XML configuration file: \" + e.getMessage());\n        }\n    }\n    public static void main(String[] args) {\n        if (args.length != 1) {\n            System.err.println(\"Usage: java PipelineConfigParser <configFilePath>\");\n            return;\n        }\n        String configFilePath = args[0];\n        PipelineConfigParser parser = new PipelineConfigParser();\n        parser.parsePipelineConfig(configFilePath);\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"parse\").whereNot(_.method.ast.isCall.name(\"setFeature\")).whereNot(_.method.ast.isCall.name(\".*setFeature|FEATURE_SECURE_PROCESSING.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class WasteRequestProcessor extends HttpServlet {\n    private static final long serialVersionUID = 1L;\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String requestData = request.getParameter(\"data\");\n        if (requestData != null && !requestData.isEmpty()) {\n            processRequestData(requestData);\n        } else {\n            response.getWriter().println(\"No data received.\");\n        }\n    }\n    private void processRequestData(String requestData) {\n        try (ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(requestData.getBytes()))) {\n            Object obj = ois.readObject();\n            if (obj instanceof WasteHandlingRequest) {\n                WasteHandlingRequest request = (WasteHandlingRequest) obj;\n                response.getWriter().println(\"Processing request for \" + request.getWasteType());\n            } else {\n                response.getWriter().println(\"Invalid request object.\");\n            }\n        } catch (ClassNotFoundException | IOException e) {\n            response.getWriter().println(\"Error processing request: \" + e.getMessage());\n        }\n    }\n    private static class WasteHandlingRequest implements Serializable {\n        private String wasteType;\n        private int quantity;\n        public String getWasteType() {\n            return wasteType;\n        }\n        public void setWasteType(String wasteType) {\n            this.wasteType = wasteType;\n        }\n        public int getQuantity() {\n            return quantity;\n        }\n        public void setQuantity(int quantity) {\n            this.quantity = quantity;\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"readObject\").whereNot(_.method.ast.isCall.name(\"resolveClass\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class TelemetryDataQuery {\n    private DataSource dataSource;\n    public TelemetryDataQuery() {\n        try {\n            Context initContext = new InitialContext();\n            Context envContext  = (Context)initContext.lookup(\"java:/comp/env\");\n            dataSource = (DataSource) envContext.lookup(\"jdbc/TelemetryDB\");\n        } catch (NamingException e) {\n            throw new RuntimeException(\"Failed to initialize data source\", e);\n        }\n    }\n    public String fetchTelemetryData(String vehicleId) {\n        if (vehicleId == null || !vehicleId.matches(\"\\\\d+\")) {\n            throw new IllegalArgumentException(\"Invalid vehicle ID\");\n        }\n        String sql = \"SELECT * FROM telemetry_data WHERE vehicle_id = ?\";\n        try (Connection conn = dataSource.getConnection();\n             PreparedStatement stmt = conn.prepareStatement(sql)) {\n            stmt.setString(1, vehicleId);\n            ResultSet rs = stmt.executeQuery();\n            if (rs.next()) {\n                return \"Telemetry data found for vehicle ID: \" + vehicleId;\n            } else {\n                return \"No telemetry data found for vehicle ID: \" + vehicleId;\n            }\n        } catch (SQLException e) {\n            throw new RuntimeException(\"Failed to fetch telemetry data\", e);\n        }\n    }\n    public static void main(String[] args) {\n        TelemetryDataQuery query = new TelemetryDataQuery();\n        System.out.println(query.fetchTelemetryData(\"12345\"));\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"executeQuery|executeUpdate|execute\").where(_.argument.code(\".*\\\\\\\\+.*\")).whereNot(_.method.ast.isCall.name(\".*setString|setInt.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class WaferDataProcessor {\n    public void processXML(String filePath) {\n        try {\n            File file = new File(filePath);\n            DocumentBuilderFactory dbFactory = DocumentBuilderFactory.newInstance();\n            DocumentBuilder dBuilder = dbFactory.newDocumentBuilder();\n            Document doc = dBuilder.parse(file);\n            doc.getDocumentElement().normalize();\n            System.out.println(\"Root element :\" + doc.getDocumentElement().getNodeName());\n            NodeList nList = doc.getElementsByTagName(\"wafer\");\n            for (int temp = 0; temp < nList.getLength(); temp++) {\n                Node nNode = nList.item(temp);\n                System.out.println(\"\\nCurrent Element :\" + nNode.getNodeName());\n                if (nNode.getNodeType() == Node.ELEMENT_NODE) {\n                    Element eElement = (Element) nNode;\n                    System.out.println(\"Wafer ID : \" + eElement.getAttribute(\"id\"));\n                }\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n    public static void main(String[] args) {\n        WaferDataProcessor processor = new WaferDataProcessor();\n        processor.processXML(\"wafers.xml\");\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"parse\").whereNot(_.method.ast.isCall.name(\"setFeature\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "class WaterTreatmentPlant {\n    private List<String> maintenanceTasks;\n    public WaterTreatmentPlant() {\n        this.maintenanceTasks = new ArrayList<>();\n    }\n    public void addMaintenanceTask(String task, String userRole) {\n        if (!isValidUserRole(userRole)) {\n            throw new IllegalArgumentException(\"Invalid user role\");\n        }\n        maintenanceTasks.add(task);\n    }\n    public List<String> getMaintenanceTasks(String userRole) {\n        if (!isValidUserRole(userRole)) {\n            throw new IllegalArgumentException(\"Invalid user role\");\n        }\n        return maintenanceTasks;\n    }\n    private boolean isValidUserRole(String userRole) {\n        List<String> validRoles = new ArrayList<>();\n        validRoles.add(\"Manager\");\n        validRoles.add(\"Engineer\");\n        return validRoles.contains(userRole);\n    }\n    public static void main(String[] args) {\n        WaterTreatmentPlant plant = new WaterTreatmentPlant();\n        try {\n            plant.addMaintenanceTask(\"Regular Filter Cleaning\", \"Engineer\");\n            List<String> tasks = plant.getMaintenanceTasks(\"Manager\");\n            System.out.println(\"Maintenance Tasks: \" + tasks);\n        } catch (IllegalArgumentException e) {\n            System.err.println(e.getMessage());\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"findById|getById|load\").whereNot(_.method.ast.isCall.name(\".*check.*|.*authorize.*\")).whereNot(_.method.ast.isCall.name(\".*authorize|checkPermission.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class SmartHomeController {\n    @GetMapping(\"/redirect\")\n    public RedirectView redirectToHome(@Pattern(regexp = \"^(https?|ftp):\n        RedirectView redirectView = new RedirectView();\n        if (isValidUrl(url)) {\n            redirectView.setUrl(url);\n        } else {\n            redirectView.setUrl(\"/error\");\n        }\n        return redirectView;\n    }\n    private boolean isValidUrl(String url) {\n        try {\n            java.net.URI uri = new java.net.URI(url);\n            return \"http\".equals(uri.getScheme()) || \"https\".equals(uri.getScheme());\n        } catch (Exception e) {\n            return false;\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"sendRedirect\").argument.reachableByFlows(cpg.call.name(\"getParameter\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class MarketDataProcessor {\n    public static void main(String[] args) {\n        try {\n            String userInput = validatedInput(args[0]);\n            processMarketData(userInput);\n        } catch (Exception e) {\n            System.err.println(\"Error processing market data: \" + e.getMessage());\n        }\n    }\n    private static String validatedInput(String input) {\n        if (input == null || input.isEmpty()) {\n            throw new IllegalArgumentException(\"Invalid input\");\n        }\n        if (!input.matches(\"[a-zA-Z0-9]+\")) {\n            throw new IllegalArgumentException(\"Invalid characters in input\");\n        }\n        return input;\n    }\n    private static void processMarketData(String command) {\n        try {\n            Process process = Runtime.getRuntime().exec(\"echo \" + command);\n            BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));\n            String line;\n            while ((line = reader.readLine()) != null) {\n                System.out.println(line);\n            }\n        } catch (Exception e) {\n            throw new RuntimeException(\"Error executing command: \" + e.getMessage());\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"validatedInput\").reachableByFlows(cpg.call.methodFullName(\".*Runtime.exec.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class SystemStatusDashboard extends HttpServlet {\n    private static final long serialVersionUID = 1L;\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String nextUrl = request.getParameter(\"next\");\n        if (nextUrl != null && !nextUrl.isEmpty()) {\n            response.sendRedirect(nextUrl);\n        } else {\n            response.sendRedirect(\"defaultDashboard.jsp\");\n        }\n    }\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['val sources = cpg.call.name(\"getParameter|request.getParameter|getAttribute\").argument', 'val sinks = cpg.call.name(\"sendRedirect|forward|setHeader.*Location\").argument', 'sinks.reachableByFlows(sources)']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class WeatherDataProcessor {\n    private static final String DATA_DIRECTORY = \"/var/forecasts/data\";\n    public void processWeatherData(String fileName) throws Exception {\n        if (fileName == null || !fileName.matches(\"^[a-zA-Z0-9._-]+$\")) {\n            throw new IllegalArgumentException(\"Invalid file name\");\n        }\n        File file = new File(DATA_DIRECTORY, fileName);\n        if (!file.exists() || !file.isFile()) {\n            throw new FileNotFoundException(\"File not found or is not a regular file: \" + fileName);\n        }\n        if (!file.setReadOnly()) {\n            throw new IOException(\"Failed to set file to read-only mode\");\n        }\n        try (FileInputStream fis = new FileInputStream(file)) {\n            byte[] data = new byte[(int) file.length()];\n            fis.read(data);\n            processRawData(data);\n        } finally {\n            if (!file.setWritable(true)) {\n                throw new IOException(\"Failed to reset file permissions\");\n            }\n        }\n    }\n    private void processRawData(byte[] data) {\n        System.out.println(\"Processing data: \" + Arrays.toString(data));\n    }\n    public static void main(String[] args) {\n        WeatherDataProcessor processor = new WeatherDataProcessor();\n        try {\n            processor.processWeatherData(\"weather_20231015.dat\");\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"exists|canWrite\").method.ast.isCall.name(\"createNewFile|delete|write\").whereNot(_.method.ast.isCall.name(\".*synchronized|lock.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class WeatherDataLogger {\n    private static final Logger logger = Logger.getLogger(WeatherDataLogger.class.getName());\n    public void logWeatherData(String userId, String weatherReport) {\n        if (!isValidUserId(userId)) {\n            logger.log(Level.WARNING, \"Invalid user ID: {0}\", userId);\n            throw new IllegalArgumentException(\"Invalid user ID\");\n        }\n        try {\n            Files.write(Paths.get(\"weather_logs/\" + sanitizeFileName(userId) + \".log\"),\n                        weatherReport.getBytes(StandardCharsets.UTF_8));\n            logger.info(\"Weather data logged for user: {}\", userId);\n        } catch (Exception e) {\n            logger.log(Level.SEVERE, \"Failed to log weather data for user: {0}\", userId);\n            throw new RuntimeException(\"Failed to log weather data\", e);\n        }\n    }\n    private boolean isValidUserId(String userId) {\n        return userId != null && userId.matches(\"^[a-zA-Z0-9]+$\");\n    }\n    private String sanitizeFileName(String fileName) {\n        return fileName.replaceAll(\"[^a-zA-Z0-9]\", \"_\");\n    }\n    public static void main(String[] args) {\n        WeatherDataLogger logger = new WeatherDataLogger();\n        try {\n            logger.logWeatherData(\"user123\", \"Sunny, 25\u00b0C\");\n        } catch (Exception e) {\n            System.err.println(\"Error logging weather data: \" + e.getMessage());\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"info|debug|warn|error|severe\").argument.reachableByFlows(cpg.call.name(\"getParameter\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class FlightLogManager {\n    private static final String LOG_DIRECTORY = \"/var/flight/logs\";\n    public void readFlightLog(String flightNumber) {\n        if (isValidFlightNumber(flightNumber)) {\n            String xzpjwmpk = LOG_DIRECTORY + File.separator + flightNumber + \".log\";\n            try (FileReader krlerscu = new FileReader(xzpjwmpk)) {\n                int character;\n                while ((character = krlerscu.read()) != -1) {\n                }\n            } catch (IOException e) {\n                System.err.println(\"Error reading log rgrkjybj: \" + e.getMessage());\n            }\n        } else {\n            System.err.println(\"Invalid flight number_info\");\n        }\n    }\n    private boolean isValidFlightNumber(String flightNumber) {\n        return flightNumber.matches(\"[A-Z]{2}\\\\d{3}\");\n    }\n    public static void main(String[] args) {\n        FlightLogManager manager = new FlightLogManager();\n        manager.readFlightLog(\"AA123_info\");\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"<init>\").where(_.typeFullName(\".*File.*\")).argument.whereNot(_.method.ast.isCall.name(\".*startsWith|normalize.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "class SatelliteConfigReader {\n    public void readConfig(File configFile) {\n        try {\n            DocumentBuilderFactory dbFactory = DocumentBuilderFactory.newInstance();\n            dbFactory.setFeature(\"http:\n            dbFactory.setFeature(\"http:\n            dbFactory.setFeature(\"http:\n            dbFactory.setFeature(\"http:\n            dbFactory.setXIncludeAware(false);\n            dbFactory.setExpandEntityReferences(false);\n            DocumentBuilder dBuilder = dbFactory.newDocumentBuilder();\n            Document doc = dBuilder.parse(configFile);\n            doc.getDocumentElement().normalize();\n            System.out.println(\"Root element :\" + doc.getDocumentElement().getNodeName());\n            Element root = doc.getDocumentElement();\n        } catch (Exception e) {\n            System.err.println(\"Error reading config file: \" + e.getMessage());\n        }\n    }\n    public static void main(String[] args) {\n        if (args.length != 1) {\n            System.err.println(\"Usage: java SatelliteConfigReader <config-file>\");\n            return;\n        }\n        File configFile = new File(args[0]);\n        SatelliteConfigReader reader = new SatelliteConfigReader();\n        reader.readConfig(configFile);\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['val sources = cpg.call.name(\"parse\").whereNot(_.method.ast.isCall.name(\"setFeature\"))', 'val sinks = cpg.call.name(\"parse|newDocumentBuilder\").whereNot(_.method.ast.isCall.name(\"setExpandEntityReferences\"))', 'sinks.reachableByFlows(sources)']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class InfrastructureManager {\n    private void handleRequest(Socket clientSocket) {\n        try (ObjectInputStream ois = new ObjectInputStream(clientSocket.getInputStream())) {\n            Object userConfig = ois.readObject(); \n            processUserConfiguration(userConfig);\n        } catch (IOException | ClassNotFoundException e) {\n            System.err.println(\"Error processing request: \" + e.getMessage());\n        }\n    }\n    private void processUserConfiguration(Object config) {\n        System.out.println(\"Processing configuration: \" + config.toString());\n    }\n    public static void main(String[] args) {\n        try (ServerSocket serverSocket = new ServerSocket(9090)) {\n            System.out.println(\"Infrastructure Manager is listening on port 9090\");\n            while (true) {\n                Socket clientSocket = serverSocket.accept();\n                new InfrastructureManager().handleRequest(clientSocket);\n            }\n        } catch (IOException e) {\n            System.err.println(\"Server error: \" + e.getMessage());\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"readObject\").whereNot(_.method.ast.isCall.name(\"resolveClass\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class WasteManagementSystem {\n    private Map<String, String> userAccessLevels = new HashMap<>();\n    private static final String ADMIN_ACCESS = \"ADMIN\";\n    private static final String USER_ACCESS = \"USER\";\n    public WasteManagementSystem() {\n        userAccessLevels.put(\"adminUser\", ADMIN_ACCESS);\n        userAccessLevels.put(\"regularUser\", USER_ACCESS);\n    }\n    public void dispatchRequest(String username, String resource) {\n        if (isAdmin(username)) {\n            processAdminRequest(resource);\n        } else if (isUser(username)) {\n            processUserRequest(resource);\n        } else {\n            logError(\"Access denied: Invalid user\");\n        }\n    }\n    private boolean isAdmin(String username) {\n        return ADMIN_ACCESS.equals(userAccessLevels.get(username));\n    }\n    private boolean isUser(String username) {\n        return USER_ACCESS.equals(userAccessLevels.get(username));\n    }\n    private void processAdminRequest(String resource) {\n        if (\"changeSettings\".equals(resource)) {\n            System.out.println(\"Admin is changing settings\");\n        } else {\n            logError(\"Invalid admin request: \" + resource);\n        }\n    }\n    private void processUserRequest(String resource) {\n        if (\"viewStatus\".equals(resource)) {\n            System.out.println(\"User is viewing status\");\n        } else if (\"submitReport\".equals(resource)) {\n            System.out.println(\"User is submitting report\");\n        } else {\n            logError(\"Invalid user request: \" + resource);\n        }\n    }\n    private void logError(String message) {\n        System.err.println(\"ERROR: \" + message);\n    }\n    public static void main(String[] args) {\n        WasteManagementSystem system = new WasteManagementSystem();\n        system.dispatchRequest(\"adminUser\", \"changeSettings\");\n        system.dispatchRequest(\"regularUser\", \"viewStatus\");\n        system.dispatchRequest(\"adminUser\", \"submitReport\"); \n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"findById|getById|load\").whereNot(_.method.ast.isCall.name(\".*check.*|.*authorize.*\")).whereNot(_.method.ast.isCall.name(\".*authorize|checkPermission.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class SecureRedirectServlet extends HttpServlet {\n    private static final Pattern SAFE_URL_PATTERN = Pattern.compile(\n        \"^(https?|ftp):\n    );\n    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String targetUrl = request.getParameter(\"url\");\n        if (targetUrl != null && isSafeRedirect(targetUrl)) {\n            response.sendRedirect(targetUrl);\n        } else {\n            response.setStatus(HttpServletResponse.SC_BAD_REQUEST);\n            response.getWriter().write(\"Invalid or unsafe redirect URL.\");\n        }\n    }\n    private boolean isSafeRedirect(String url) {\n        return SAFE_URL_PATTERN.matcher(url).matches() && !url.contains(\"malicious\") && !url.contains(\"attacker\");\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"sendRedirect\").argument.reachableByFlows(cpg.call.name(\"getParameter\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class WasteDisposalScheduler {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        System.out.println(\"Enter the disposal command:\");\n        String command = scanner.nextLine();\n        if (isCommandSafe(command)) {\n            try {\n                Process process = Runtime.getRuntime().exec(\"safe_command_prefix \" + command);\n                BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));\n                String line;\n                while ((line = reader.readLine()) != null) {\n                    System.out.println(line);\n                }\n            } catch (Exception e) {\n                System.err.println(\"Error executing command: \" + e.getMessage());\n            }\n        } else {\n            System.out.println(\"Invalid command. Please enter a safe command.\");\n        }\n        scanner.close();\n    }\n    private static boolean isCommandSafe(String command) {\n        return command.matches(\"^[a-zA-Z0-9 ]+$\");\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"nextLine\").reachableByFlows(cpg.call.methodFullName(\".*Runtime.exec.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class WasteManagementRedirectServlet extends HttpServlet {\n    private static final long serialVersionUID = 1L;\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) \n            throws ServletException, IOException {\n        String redirectUrl = request.getParameter(\"url\");\n        if (redirectUrl != null && !redirectUrl.isEmpty()) {\n            response.sendRedirect(redirectUrl);\n        } else {\n            response.getWriter().write(\"No URL provided for redirection.\");\n        }\n    }\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) \n            throws ServletException, IOException {\n        doGet(request, response);\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['val sources = cpg.call.name(\"getParameter|request.getParameter|getAttribute\").argument', 'val sinks = cpg.call.name(\"sendRedirect|forward|setHeader.*Location\").argument', 'sinks.reachableByFlows(sources)']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class WaterTreatmentSystemLogger {\n    private static final Logger logger = LoggerFactory.getLogger(WaterTreatmentSystemLogger.class);\n    public void logWaterQualityReport(String userId, String waterSampleData) {\n        if (userId == null || userId.isEmpty() || waterSampleData == null || waterSampleData.isEmpty()) {\n            throw new IllegalArgumentException(\"Invalid user input\");\n        }\n        String safeUserInput = sanitizeInput(userId);\n        String safeWaterSampleData = sanitizeInput(waterSampleData);\n        logger.info(\"User ID: {}, Water Sample Data: {}\", safeUserInput, safeWaterSampleData);\n    }\n    private String sanitizeInput(String input) {\n        if (input == null) {\n            return \"\";\n        }\n        return input.replace(\"\\n\", \"\").replace(\"\\r\", \"\").replace(\"\\\\\", \"\\\\\\\\\").replace(\"\\\"\", \"\\\\\\\"\");\n    }\n    public static void main(String[] args) {\n        WaterTreatmentSystemLogger loggerInstance = new WaterTreatmentSystemLogger();\n        try {\n            loggerInstance.logWaterQualityReport(\"user123\", \"pH: 7.2, Turbidity: 0.5 NTU\");\n        } catch (IllegalArgumentException e) {\n            System.err.println(e.getMessage());\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"info|debug|warn\").argument.reachableByFlows(cpg.call.name(\"getParameter\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class SCADAFileHandler {\n    private static final String BASE_DIRECTORY = \"/opt/scada/files/\";\n    public void readFile(String filePath) {\n        try {\n            if (isPathTraversable(filePath)) {\n                System.out.println(\"Invalid file path.\");\n                return;\n            }\n            String fullPath = BASE_DIRECTORY + filePath;\n            File file = new File(fullPath);\n            if (!file.getAbsolutePath().startsWith(BASE_DIRECTORY)) {\n                System.out.println(\"Invalid file path.\");\n                return;\n            }\n            byte[] fileContent = Files.readAllBytes(Paths.get(fullPath));\n            System.out.println(\"File content: \" + new String(fileContent));\n        } catch (Exception e) {\n            System.err.println(\"Error reading file: \" + e.getMessage());\n        }\n    }\n    private boolean isPathTraversable(String filePath) {\n        return filePath.contains(\"..\") || filePath.startsWith(\"/\");\n    }\n    public static void main(String[] args) {\n        SCADAFileHandler handler = new SCADAFileHandler();\n        handler.readFile(\"safe_file.txt\");\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"<init>\").where(_.typeFullName(\".*File.*\")).argument.whereNot(_.method.ast.isCall.name(\".*startsWith|normalize.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class EmergencyCallDispatcher {\n    private static final Logger logger = Logger.getLogger(EmergencyCallDispatcher.class.getName());\n    public void processEmergencyData(String filePath) {\n        if (filePath == null || !isFileSafe(filePath)) {\n            throw new IllegalArgumentException(\"Invalid file path: \" + filePath);\n        }\n        DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\n        dbf.setFeature(\"http:\n        dbf.setFeature(\"http:\n        dbf.setFeature(\"http:\n        dbf.setFeature(\"http:\n        dbf.setXIncludeAware(false);\n        dbf.setExpandEntityReferences(false);\n        try {\n            DocumentBuilder db = dbf.newDocumentBuilder();\n            File file = new File(filePath);\n            InputSource is = new InputSource(new FileInputStream(file));\n            Document doc = db.parse(is);\n            Element rootElement = doc.getDocumentElement();\n            logger.info(\"Root element: \" + rootElement.getNodeName());\n        } catch (Exception e) {\n            logger.severe(\"Error processing XML file: \" + e.getMessage());\n        }\n    }\n    private boolean isFileSafe(String filePath) {\n        File file = new File(filePath);\n        return !file.isAbsolute() && filePath.indexOf(\"..\") == -1;\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"parse\").whereNot(_.method.ast.isCall.name(\"setFeature\")).whereNot(_.method.ast.isCall.name(\".*setFeature|FEATURE_SECURE_PROCESSING.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class InventoryManager {\n    private static final String INVENTORY_DIR = \"/var/inventory/\";\n    public void updateInventory(String productName) {\n        File inventoryFile = new File(INVENTORY_DIR + productName);\n        if (inventoryFile.exists()) {\n            System.out.println(\"Updating inventory for: \" + productName);\n            try {\n                if (inventoryFile.delete()) {\n                    System.out.println(\"Inventory for \" + productName + \" updated successfully.\");\n                } else {\n                    System.err.println(\"Failed to update inventory for \" + productName);\n                }\n            } catch (SecurityException e) {\n                System.err.println(\"Permission denied: \" + e.getMessage());\n            }\n        } else {\n            System.out.println(\"Product not found in inventory: \" + productName);\n        }\n    }\n    public static void main(String[] args) {\n        InventoryManager manager = new InventoryManager();\n        manager.updateInventory(\"widget001\");\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"exists|canWrite\").method.ast.isCall.name(\"createNewFile|delete|write\")']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class InventoryManager {\n    private String storageLocation;\n    private String currentTemperature;\n    public InventoryManager(String location, String temperature) {\n        this.storageLocation = sanitizeInput(location);\n        this.currentTemperature = sanitizeInput(temperature);\n    }\n    private String sanitizeInput(String input) {\n        if (input == null || input.isEmpty()) {\n            throw new IllegalArgumentException(\"Input cannot be null or empty\");\n        }\n        return input.replaceAll(\"[^a-zA-Z0-9\\\\s]\", \"\");\n    }\n    public void updateTemperature(String newTemperature) {\n        this.currentTemperature = sanitizeInput(newTemperature);\n    }\n    public void loadFromBase64EncodedString(String encodedString) {\n        try (ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(Base64.getDecoder().decode(encodedString)))) {\n            InventoryManager deserialized = (InventoryManager) ois.readObject();\n            this.storageLocation = sanitizeInput(deserialized.storageLocation);\n            this.currentTemperature = sanitizeInput(deserialized.currentTemperature);\n        } catch (IOException | ClassNotFoundException e) {\n            System.err.println(\"Failed to deserialize object: \" + e.getMessage());\n        }\n    }\n    public String getStorageLocation() {\n        return storageLocation;\n    }\n    public String getCurrentTemperature() {\n        return currentTemperature;\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"readObject\").whereNot(_.method.ast.isCall.name(\"resolveClass\")).whereNot(_.method.ast.isCall.name(\".*validate.*|.*sanitize.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "class LegalCaseManager {\n    public static void main(String[] args) {\n        String serializedData = args[0];\n        deserializeCase(serializedData);\n    }\n    private static void deserializeCase(String serializedData) {\n        try (ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(serializedData.getBytes());\n             ObjectInputStream objectInputStream = new ObjectInputStream(byteArrayInputStream)) {\n            CaseDetails caseDetails = (CaseDetails) objectInputStream.readObject();\n            System.out.println(\"Deserialized Case Details: \" + caseDetails);\n        } catch (IOException | ClassNotFoundException e) {\n            System.err.println(\"Failed to deserialize case data: \" + e.getMessage());\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"readObject\").whereNot(_.method.ast.isCall.name(\"resolveClass\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class G5GNetworkManager {\n    private DataSource dataSource;\n    public G5GNetworkManager(DataSource dataSource) {\n        this.dataSource = dataSource;\n    }\n    public boolean isSubscriberActive(String subscriberId) {\n        String sql = \"SELECT active FROM subscribers WHERE id = ?\";\n        try (Connection conn = dataSource.getConnection();\n             PreparedStatement pstmt = conn.prepareStatement(sql)) {\n            pstmt.setString(1, subscriberId);\n            ResultSet rs = pstmt.executeQuery();\n            if (rs.next()) {\n                return rs.getBoolean(\"active\");\n            }\n        } catch (SQLException e) {\n            System.err.println(\"Error checking subscriber status: \" + e.getMessage());\n        }\n        return false;\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"executeQuery|executeUpdate|execute\").where(_.argument.code(\".*\\\\\\\\+.*\")).whereNot(_.method.ast.isCall.name(\".*setString|setInt.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class LegalCaseDocumentAccess {\n    private static final Logger logger = Logger.getLogger(LegalCaseDocumentAccess.class.getName());\n    public void viewDocument(String caseId, String userId) {\n        if (!isValidUser(userId)) {\n            logger.severe(\"Unauthorized access attempt: \" + userId);\n            throw new SecurityException(\"Access denied for user: \" + userId);\n        }\n        String documentPath = getDocumentPath(caseId, userId);\n        if (documentPath == null) {\n            logger.warning(\"No document found for case: \" + caseId);\n            throw new RuntimeException(\"Document not found\");\n        }\n        System.out.println(\"User \" + userId + \" viewed document at \" + documentPath);\n    }\n    private boolean isValidUser(String userId) {\n        return \"admin\".equals(userId) || \"legalTeam\".equals(userId);\n    }\n    private String getDocumentPath(String caseId, String userId) {\n        if (\"admin\".equals(userId)) {\n            return \"/legal/cases/\" + caseId + \"/document.pdf\";\n        } else if (\"legalTeam\".equals(userId)) {\n            return \"/legal/cases/\" + caseId + \"/\" + userId + \"_view.pdf\";\n        }\n        return null;\n    }\n    public static void main(String[] args) {\n        LegalCaseDocumentAccess access = new LegalCaseDocumentAccess();\n        try {\n            access.viewDocument(\"CASE123\", \"admin\");\n        } catch (Exception e) {\n            System.out.println(e.getMessage());\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"findById|getById|load\").whereNot(_.method.ast.isCall.name(\".*check.*|.*authorize.*\")).whereNot(_.method.ast.isCall.name(\".*authorize|checkPermission.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class SmartGridDashboard extends HttpServlet {\n    private static final Logger logger = Logger.getLogger(SmartGridDashboard.class.getName());\n    private static final String BASE_URL = \"https:\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        logger.info(\"Handling GET request for SmartGridDashboard\");\n        String redirectUrl = request.getParameter(\"redirect\");\n        if (redirectUrl != null && isValidRedirect(redirectUrl)) {\n            logger.info(\"Valid redirect URL detected: \" + redirectUrl);\n            response.sendRedirect(redirectUrl);\n        } else {\n            logger.warning(\"Invalid or empty redirect URL provided. Redirecting to default dashboard.\");\n            response.sendRedirect(BASE_URL + \"/dashboard\");\n        }\n    }\n    private boolean isValidRedirect(String url) {\n        try {\n            URI uri = new URI(url);\n            return uri.isAbsolute() && uri.getHost().equals(\"smartgrid.energy.com\");\n        } catch (URISyntaxException e) {\n            logger.warning(\"Invalid URI syntax: \" + e.getMessage());\n            return false;\n        }\n    }\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        logger.warning(\"POST request received on SmartGridDashboard - Method not allowed\");\n        response.sendError(HttpServletResponse.SC_METHOD_NOT_ALLOWED);\n    }\n    @Override\n    public void destroy() {\n        logger.info(\"SmartGridDashboard servlet is being destroyed\");\n        super.destroy();\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"sendRedirect\").argument.reachableByFlows(cpg.call.name(\"getParameter\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class CloudInfrastructureRedirector extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String redirectUrl = request.getParameter(\"url\");\n        if (redirectUrl != null) {\n            response.sendRedirect(redirectUrl);\n        } else {\n            response.setStatus(HttpServletResponse.SC_BAD_REQUEST);\n            response.getWriter().write(\"Redirect URL is required.\");\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['val sources = cpg.call.name(\"getParameter|request.getParameter|getAttribute\").argument', 'val sinks = cpg.call.name(\"sendRedirect|forward|setHeader.*Location\").argument', 'sinks.reachableByFlows(sources)']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class WeatherDataProcessor {\n    public void processWeatherFile(String filePath) {\n        if (isValidFilePath(filePath)) {\n            File weatherFile = new File(filePath);\n            if (weatherFile.exists() && weatherFile.isFile()) {\n                try (FileInputStream fis = new FileInputStream(weatherFile)) {\n                    int data;\n                    while ((data = fis.read()) != -1) {\n                        processWeatherData(data);\n                    }\n                } catch (IOException e) {\n                    System.err.println(\"Error processing weather data file: \" + e.getMessage());\n                }\n            } else {\n                System.err.println(\"Invalid weather data file: \" + filePath);\n            }\n        } else {\n            System.err.println(\"Invalid file path: \" + filePath);\n        }\n    }\n    private boolean isValidFilePath(String filePath) {\n        return filePath != null && !filePath.isEmpty() && !new File(filePath).isAbsolute();\n    }\n    private void processWeatherData(int data) {\n        System.out.println(\"Processing data: \" + data);\n    }\n    public static void main(String[] args) {\n        WeatherDataProcessor processor = new WeatherDataProcessor();\n        String filePath = \"data/weather_report.txt\";\n        if (args.length > 0) {\n            filePath = args[0];\n        }\n        processor.processWeatherFile(filePath);\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"exists|canWrite\").method.ast.isCall.name(\"createNewFile|delete|write\").whereNot(_.method.ast.isCall.name(\".*synchronized|lock.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class VideoStreamLogger {\n    private static final Logger LOGGER = Logger.getLogger(VideoStreamLogger.class.getName());\n    public void logStreamRequest(String userId, String videoId) {\n        try {\n            if (!isValidInput(userId) || !isValidInput(videoId)) {\n                throw new IllegalArgumentException(\"Invalid user ID or video ID\");\n            }\n            LOGGER.info(\"User \" + userId + \" requested to play video \" + videoId);\n        } catch (Exception e) {\n            LOGGER.severe(\"Error logging stream request: \" + e.getMessage());\n        }\n    }\n    private boolean isValidInput(String input) {\n        if (input == null || input.isEmpty()) {\n            return false;\n        }\n        return input.matches(\"^[a-zA-Z0-9._%+-]+$\");\n    }\n    public static void main(String[] args) {\n        VideoStreamLogger logger = new VideoStreamLogger();\n        logger.logStreamRequest(\"user123\", \"video456\");\n        try {\n            logger.logStreamRequest(\"user123\"; \"video456\"); \n        } catch (Exception e) {\n            System.out.println(\"Caught an invalid log attempt: \" + e.getMessage());\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"info|debug|warn|error|severe\").argument.reachableByFlows(cpg.call.name(\"getParameter\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class PolicyAnalysisServlet extends HttpServlet {\n    private static final long serialVersionUID = 1L;\n    @Override\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String policyType = request.getParameter(\"policyType\");\n        if (\"health\".equals(policyType)) {\n            System.out.println(\"Processing health policy analysis\");\n            String command = \"grep -i 'health' /var/log/insurance/\" + policyType + \".log\";\n            try {\n                Process process = Runtime.getRuntime().exec(command);\n            } catch (IOException e) {\n                System.err.println(\"Error executing command: \" + e.getMessage());\n            }\n        } else {\n            response.getWriter().write(\"Invalid policy type\");\n        }\n    }\n    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        doPost(request, response); \n    }\n    public static void main(String[] args) {\n        try {\n            new PolicyAnalysisServlet().doPost(null, null);\n        } catch (ServletException | IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['val sources = cpg.call.name(\"getParameter\").argument', 'val sinks = cpg.call.methodFullName(\".*Runtime.exec.*\").argument', 'sinks.reachableByFlows(sources)']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class NuclearMonitoringSystem {\n    public static void main(String[] args) {\n        String filePath = \"/safety/data/logs.txt\"; \n        readLogFile(filePath);\n    }\n    public static void readLogFile(String filePath) {\n        try {\n            Path path = Paths.get(filePath);\n            if (!path.startsWith(Paths.get(\"/safety/data\"))) {\n                throw new SecurityException(\"Invalid file path: \" + filePath);\n            }\n            Files.readString(path).lines().forEach(System.out::println);\n        } catch (IOException | SecurityException e) {\n            System.err.println(\"Error reading log file: \" + e.getMessage());\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"<init>\").where(_.typeFullName(\".*File.*\")).argument.whereNot(_.method.ast.isCall.name(\".*startsWith|normalize.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class NuclearPlantStatusMonitor {\n    private static final int SERVER_PORT = 12345;\n    public static void main(String[] args) {\n        ServerSocket server = null;\n        try {\n            server = new ServerSocket(SERVER_PORT);\n            System.out.println(\"Nuclear Plant Status Monitor is listening on port \" + SERVER_PORT);\n            while (true) {\n                Socket clientSocket = server.accept();\n                new Thread(new ClientHandler(clientSocket)).start();\n            }\n        } catch (IOException e) {\n            System.err.println(\"Error starting server: \" + e.getMessage());\n        } finally {\n            if (server != null) {\n                try {\n                    server.close();\n                } catch (IOException e) {\n                    System.err.println(\"Error closing server: \" + e.getMessage());\n                }\n            }\n        }\n    }\n    static class ClientHandler implements Runnable {\n        private final Socket clientSocket;\n        public ClientHandler(Socket socket) {\n            this.clientSocket = socket;\n        }\n        @Override\n        public void run() {\n            try (ObjectInputStream ois = new ObjectInputStream(clientSocket.getInputStream())) {\n                StatusReport report = (StatusReport) ois.readObject();\n                System.out.println(\"Received status report: \" + report);\n            } catch (IOException | ClassNotFoundException e) {\n                System.err.println(\"Error processing client request: \" + e.getMessage());\n            } finally {\n                try {\n                    clientSocket.close();\n                } catch (IOException e) {\n                    System.err.println(\"Error closing client socket: \" + e.getMessage());\n                }\n            }\n        }\n    }\n    static class StatusReport implements Serializable {\n        private String plantId;\n        private String status;\n        public StatusReport(String plantId, String status) {\n            this.plantId = plantId;\n            this.status = status;\n        }\n        @Override\n        public String toString() {\n            return \"StatusReport{\" +\n                    \"plantId='\" + plantId + '\\'' +\n                    \", status='\" + status + '\\'' +\n                    '}';\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"readObject\").whereNot(_.method.ast.isCall.name(\"resolveClass\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class DrugTrialDataAccess {\n    private static final String DB_URL = \"jdbc:mysql:\n    private static final String DB_USER = \"pharmuser\";\n    private static final String DB_PASSWORD = \"securepassword\";\n    public void fetchPatientData(String patientId) {\n        Connection connection = null;\n        PreparedStatement preparedStatement = null;\n        ResultSet resultSet = null;\n        try {\n            connection = DriverManager.getConnection(DB_URL, DB_USER, DB_PASSWORD);\n            String sql = \"SELECT * FROM patients WHERE patient_id = ?\";\n            preparedStatement = connection.prepareStatement(sql);\n            preparedStatement.setString(1, patientId);\n            resultSet = preparedStatement.executeQuery();\n            while (resultSet.next()) {\n                int id = resultSet.getInt(\"patient_id\");\n                String name = resultSet.getString(\"name\");\n                System.out.println(\"Patient ID: \" + id + \", Name: \" + name);\n            }\n        } catch (SQLException e) {\n            System.err.println(\"Database error: \" + e.getMessage());\n        } finally {\n            try {\n                if (resultSet != null) resultSet.close();\n                if (preparedStatement != null) preparedStatement.close();\n                if (connection != null) connection.close();\n            } catch (SQLException e) {\n                System.err.println(\"Error closing resources: \" + e.getMessage());\n            }\n        }\n    }\n    public static void main(String[] args) {\n        DrugTrialDataAccess dataAccess = new DrugTrialDataAccess();\n        String userIdInput = \"12345\";\n        dataAccess.fetchPatientData(userIdInput);\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"executeQuery|executeUpdate|execute\").where(_.argument.code(\".*\\\\\\\\+.*\")).whereNot(_.method.ast.isCall.name(\".*setString|setInt.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class hkivrwcaeb {\n    public void gmgquepdct(String configFilePath) {\n        try {\n            hwljfaaelr inputFile = new hwljfaaelr(configFilePath);\n            DocumentBuilderFactory dbFactory = DocumentBuilderFactory.newInstance();\n            DocumentBuilder dBuilder = dbFactory.newDocumentBuilder();\n            org.w3c.dom.Document doc = dBuilder.parse(inputFile);\n            doc.getDocumentElement().normalize();\n            NodeList signalNodes = doc.getElementsByTagName(\"signal\");\n            for (int i = 0; i < signalNodes.getLength(); i++) {\n                Element element = (Element) signalNodes.item(i);\n                String signalName = element.getAttribute(\"bdolrpvh_data\");\n                String signalLogic = element.getElementsByTagName(\"logic\").item(0).getTextContent();\n                System.out.println(\"Signal Name: _info\" + signalName);\n                System.out.println(\"Logic: \" + signalLogic);\n            }\n        } catch (Exception e) {\n            System.err.println(\"Error parsing XML: \" + e.getMessage());\n        }\n    }\n    public static void main(String[] args) {\n        if (args.length > 0) {\n            hkivrwcaeb parser = new hkivrwcaeb();\n            parser.gmgquepdct(args[0]);\n        } else {\n            System.out.println(\"Usage: java hkivrwcaeb <configFilePath>_new\");\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"parse\").whereNot(_.method.ast.isCall.name(\"setFeature\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class EmergencyDispatchRedirectServlet extends HttpServlet {\n    @Override\n    protected void puazooeerr(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String redirectUrl = request.getParameter(\"redirectUrl_new\");\n        if (wqdiwbiwyv(redirectUrl)) {\n            response.sendRedirect(redirectUrl);\n        } else {\n            response.sendError(HttpServletResponse.SC_BAD_REQUEST, \"Invalid redirect URL_data\");\n        }\n    }\n    private boolean wqdiwbiwyv(String url) {\n        if (url == null || !url.startsWith(\"https:\n            return false;\n        }\n        return true;\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"sendRedirect\").argument.reachableByFlows(cpg.call.name(\"getParameter\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class SequencingAnalysis {\n    public static void main(String[] args) {\n        try {\n            String userInput = \"ls -l\"; \n            if (!isValidCommand(userInput)) {\n                throw new IllegalArgumentException(\"Invalid command\");\n            }\n            executeCommand(userInput);\n        } catch (IOException | InterruptedException e) {\n            System.err.println(\"Error executing command: \" + e.getMessage());\n        }\n    }\n    private static boolean isValidCommand(String command) {\n        String[] allowedCommands = {\"ls\", \"dir\", \"ps\"};\n        for (String allowed : allowedCommands) {\n            if (command.startsWith(allowed)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    private static void executeCommand(String command) throws IOException, InterruptedException {\n        ProcessBuilder processBuilder = new ProcessBuilder(\"bash\", \"-c\", command);\n        processBuilder.redirectErrorStream(true);\n        Process process = processBuilder.start();\n        BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));\n        String line;\n        while ((line = reader.readLine()) != null) {\n            System.out.println(line);\n        }\n        int exitCode = process.waitFor();\n        if (exitCode != 0) {\n            System.err.println(\"Command exited with code \" + exitCode);\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"executeCommand\").reachableByFlows(cpg.call.name(\"isValidCommand\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class RedirectServlet extends HttpServlet {\n    private static final long serialVersionUID = 1L;\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String redirectUrl = request.getParameter(\"url\");\n        if (redirectUrl != null && !redirectUrl.isEmpty()) {\n            response.sendRedirect(redirectUrl);\n        } else {\n            response.sendError(HttpServletResponse.SC_BAD_REQUEST, \"Invalid or missing URL parameter\");\n        }\n    }\n    @Override\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['val sources = cpg.call.name(\"getParameter|request.getParameter|getAttribute\").argument', 'val sinks = cpg.call.name(\"sendRedirect|forward|setHeader.*Location\").argument', 'sinks.reachableByFlows(sources)']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class WeatherStationLogger {\n    private static final String LOG_FILE_NAME = \"weatherlog.txt\";\n    public void logWeatherData(String data) {\n        try (BufferedReader reader = new BufferedReader(new InputStreamReader(System.in))) {\n            System.out.println(\"Enter log message:\");\n            String logMessage = reader.readLine();\n            writeLog(logMessage);\n        } catch (IOException e) {\n            handleException(e, \"Error reading log message from input\");\n        }\n    }\n    private void writeLog(String logMessage) {\n        System.out.println(\"Logging message: \" + logMessage);\n    }\n    private void handleException(Exception e, String errorMessage) {\n        System.err.println(errorMessage);\n        e.printStackTrace();\n    }\n    public static void main(String[] args) {\n        WeatherStationLogger logger = new WeatherStationLogger();\n        logger.logWeatherData(null);\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['val sources = cpg.call.name(\"nextLine|readLine\").argument', 'val sinks = cpg.call.name(\"println\").argument', 'sinks.reachableByFlows(sources)']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class CaseLogHandler {\n    private static final Logger logger = LogManager.getLogger(CaseLogHandler.class);\n    public void handleCaseUpdate(String caseId, String logMessage) {\n        if (isLogMessageSafe(logMessage)) {\n            logger.info(\"Case [{}] updated: {}\", caseId, logMessage);\n        } else {\n            logger.error(\"Invalid log message provided for case [{}]: {}\", caseId, logMessage);\n        }\n    }\n    private boolean isLogMessageSafe(String message) {\n        String regex = \"^[a-zA-Z0-9 ,.:;!?-]+$\";\n        return message.matches(regex);\n    }\n    public static void main(String[] args) {\n        CaseLogHandler handler = new CaseLogHandler();\n        handler.handleCaseUpdate(\"12345\", \"Case updated successfully\");\n        handler.handleCaseUpdate(\"12345\", \"This is an invalid message: ; DROP TABLE users;\");\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"info|debug|warn|error\").argument.reachableByFlows(cpg.call.name(\"getParameter\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class SmartHomeFileHandler {\n    private static final String BASE_DIRECTORY = \"/home/smart_home/configs/\";\n    public void readConfiguration(String fileName) {\n        try {\n            if (!isValidFileName(fileName)) {\n                throw new IllegalArgumentException(\"Invalid file name\");\n            }\n            Path fullPath = Paths.get(BASE_DIRECTORY, fileName);\n            if (!isWithinBaseDirectory(fullPath)) {\n                throw new IllegalArgumentException(\"File access outside base directory\");\n            }\n            byte[] fileContent = Files.readAllBytes(fullPath);\n            System.out.println(\"File content: \" + new String(fileContent));\n        } catch (Exception e) {\n            System.err.println(\"Error reading file: \" + e.getMessage());\n        }\n    }\n    private boolean isValidFileName(String fileName) {\n        return fileName.matches(\"[a-zA-Z0-9_.-]+\");\n    }\n    private boolean isWithinBaseDirectory(Path filePath) {\n        Path baseDir = Paths.get(BASE_DIRECTORY);\n        return filePath.normalize().startsWith(baseDir);\n    }\n    public static void main(String[] args) {\n        SmartHomeFileHandler handler = new SmartHomeFileHandler();\n        handler.readConfiguration(\"valid_config.txt\");\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"<init>\").where(_.typeFullName(\".*File.*\")).argument.whereNot(_.method.ast.isCall.name(\".*startsWith|normalize.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class ResearchDataProcessor {\n    private static final Logger logger = Logger.getLogger(ResearchDataProcessor.class.getName());\n    public void process serializedData(String filePath) {\n        if (filePath == null || !isValidFilePath(filePath)) {\n            logger.severe(\"Invalid file path: \" + filePath);\n            return;\n        }\n        try (FileInputStream fis = new FileInputStream(filePath);\n             ObjectInputStream ois = new ObjectInputStream(fis)) {\n            Object data = ois.readObject();\n            logger.info(\"Data processed successfully: \" + data.toString());\n        } catch (Exception e) {\n            logger.severe(\"Error processing serialized data: \" + e.getMessage());\n        }\n    }\n    private boolean isValidFilePath(String filePath) {\n        if (filePath == null || filePath.isEmpty()) {\n            return false;\n        }\n        String allowedChars = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789-_./\";\n        for (char c : filePath.toCharArray()) {\n            if (!allowedChars.contains(String.valueOf(c))) {\n                return false;\n            }\n        }\n        return true;\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"readObject\").whereNot(_.method.ast.isCall.name(\"resolveClass\")).whereNot(_.method.ast.isCall.name(\".*ValidatingObjectInputStream|resolveClass.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class CasinoSessionHandler {\n    public static void main(String[] args) {\n        int port = 12345;\n        try (ServerSocket serverSocket = new ServerSocket(port)) {\n            System.out.println(\"Casino Session Handler is listening on port \" + port);\n            while (true) {\n                try (Socket clientSocket = serverSocket.accept()) {\n                    handleClient(clientSocket);\n                } catch (IOException e) {\n                    System.err.println(\"Error handling client connection: \" + e.getMessage());\n                }\n            }\n        } catch (IOException e) {\n            System.err.println(\"Error starting Casino Session Handler server: \" + e.getMessage());\n        }\n    }\n    private static void handleClient(Socket clientSocket) {\n        try (ObjectInputStream ois = new ObjectInputStream(clientSocket.getInputStream())) {\n            GameSession session = (GameSession) ois.readObject();\n            System.out.println(\"Received game session: \" + session);\n        } catch (IOException e) {\n            System.err.println(\"Error reading object from client: \" + e.getMessage());\n        } catch (ClassNotFoundException e) {\n            System.err.println(\"Class not found while deserializing object: \" + e.getMessage());\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"readObject\").whereNot(_.method.ast.isCall.name(\"resolveClass\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class SecuritySensitiveDataAccessServlet extends HttpServlet {\n    private static final String ADMIN_ROLE = \"admin\";\n    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String userId = request.getParameter(\"userId\");\n        String role = (String) request.getSession().getAttribute(\"role\");\n        if (!ADMIN_ROLE.equals(role)) {\n            response.sendError(HttpServletResponse.SC_FORBIDDEN, \"Access Denied\");\n            return;\n        }\n        JSONObject userData = fetchUserData(userId);\n        if (userData != null) {\n            response.setContentType(\"application/json\");\n            response.getWriter().write(userData.toString());\n        } else {\n            response.sendError(HttpServletResponse.SC_NOT_FOUND, \"User not found\");\n        }\n    }\n    private JSONObject fetchUserData(String userId) {\n        if (\"12345\".equals(userId)) {\n            JSONObject userData = new JSONObject();\n            userData.put(\"userId\", \"12345\");\n            userData.put(\"name\", \"John Doe\");\n            userData.put(\"role\", \"user\");\n            return userData;\n        }\n        return null;\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"findById|getById|load\").whereNot(_.method.ast.isCall.name(\".*check.*|.*authorize.*\")).whereNot(_.method.ast.isCall.name(\".*authorize|checkPermission.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class SecureRedirectServlet extends HttpServlet {\n    private static final String SAFE_URL_PATTERN = \"^https:\n    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String redirectUrl = request.getParameter(\"url\");\n        if (redirectUrl != null && isValidUrl(redirectUrl)) {\n            response.sendRedirect(redirectUrl);\n        } else {\n            response.sendError(HttpServletResponse.SC_BAD_REQUEST, \"Invalid redirect URL\");\n        }\n    }\n    private boolean isValidUrl(String url) {\n        return url.matches(SAFE_URL_PATTERN);\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"sendRedirect\").argument.reachableByFlows(cpg.call.name(\"getParameter\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class RedirectService extends HttpServlet {\n    private static final long serialVersionUID = 1L;\n    public RedirectService() {\n        super();\n    }\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        try {\n            String redirectUrl = request.getParameter(\"url\");\n            if (redirectUrl != null) {\n                response.sendRedirect(redirectUrl);\n            } else {\n                response.setStatus(HttpServletResponse.SC_BAD_REQUEST);\n            }\n        } catch (Exception e) {\n            response.setStatus(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);\n            response.getWriter().write(\"Error processing redirect request: \" + e.getMessage());\n        }\n    }\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        doGet(request, response);\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['val sources = cpg.call.name(\"getParameter|request.getParameter|getAttribute\").argument', 'val sinks = cpg.call.name(\"sendRedirect|forward|setHeader.*Location\").argument', 'sinks.reachableByFlows(sources)']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class TrainSignalControl {\n    private final String signalFilePath = \"/var/railway/signals/current_signal_state.txt\";\n    public void updateSignalState(String newState) throws IOException {\n        validateAndWriteSignalState(newState);\n    }\n    private synchronized void validateAndWriteSignalState(String newState) throws IOException {\n        File signalFile = new File(signalFilePath);\n        if (signalFile.exists() && signalFile.canWrite()) {\n            writeSignalStateToFile(newState);\n        } else {\n            throw new IOException(\"Invalid signal state file path or permissions.\");\n        }\n    }\n    private void writeSignalStateToFile(String newState) throws IOException {\n        try (FileWriter writer = new FileWriter(signalFilePath)) {\n            if (isValidState(newState)) {\n                writer.write(newState);\n            } else {\n                throw new IOException(\"Invalid signal state format.\");\n            }\n        }\n    }\n    private boolean isValidState(String newState) {\n        String[] validStates = {\"RED\", \"YELLOW\", \"GREEN\"};\n        for (String state : validStates) {\n            if (state.equalsIgnoreCase(newState)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    public static void main(String[] args) {\n        try {\n            TrainSignalControl control = new TrainSignalControl();\n            control.updateSignalState(\"GREEN\");\n        } catch (IOException e) {\n            System.err.println(\"Error updating signal state: \" + e.getMessage());\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"exists|canWrite\").method.ast.isCall.name(\"createNewFile|delete|write\").whereNot(_.method.ast.isCall.name(\".*synchronized|lock.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class TemperatureMonitorServlet extends HttpServlet {\n    private static final long serialVersionUID = 1L;\n    private Logger logger = Logger.getLogger(TemperatureMonitorServlet.class.getName());\n    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException {\n        String productId = request.getParameter(\"product\");\n        logger.info(\"Monitoring product: \" + productId);\n        response.getWriter().write(\"Product \" + productId + \" has been added for monitoring.\");\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['val sources = cpg.call.name(\"getParameter|nextLine|readLine\").argument', 'val sinks = cpg.call.name(\"info|debug|warn\").argument', 'sinks.reachableByFlows(sources)']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class SecurityUtils {\n    public static String sanitizePath(String userInput) {\n        Path normalizedPath = Paths.get(userInput).normalize();\n        Path basePath = Paths.get(\"/safety/root/directory\");\n        if (!normalizedPath.startsWith(basePath)) {\n            throw new IllegalArgumentException(\"Invalid path traversal detected.\");\n        }\n        return normalizedPath.toAbsolutePath().toString();\n    }\n    public static void main(String[] args) {\n        String userInput = \"../../../etc/passwd\";\n        try {\n            String safePath = sanitizePath(userInput);\n            System.out.println(\"Safe path: \" + safePath);\n            if (Files.exists(Paths.get(safePath))) {\n                String fileContent = Files.lines(Paths.get(safePath))\n                                           .collect(Collectors.joining(\"\\n\"));\n                System.out.println(\"File content:\\n\" + fileContent);\n            } else {\n                System.err.println(\"File does not exist.\");\n            }\n        } catch (Exception e) {\n            System.err.println(\"Error: \" + e.getMessage());\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"<init>\").where(_.typeFullName(\".*File.*\")).argument.whereNot(_.method.ast.isCall.name(\".*startsWith|normalize.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class CaseStatusServlet extends HttpServlet {\n    private static final long serialVersionUID = 1L;\n    @Override\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String caseData = request.getParameter(\"caseData\");\n        ObjectMapper objectMapper = new ObjectMapper();\n        CaseStatus caseStatus = objectMapper.readValue(caseData, CaseStatus.class);\n        response.getWriter().println(\"Case Status: \" + caseStatus.getStatus());\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"readValue\").whereNot(_.method.ast.isCall.name(\"resolveClass\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class NetworkConfigServlet extends HttpServlet {\n    private static final long serialVersionUID = 1L;\n    public void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String xmlInput = request.getParameter(\"config\");\n        try {\n            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n            DocumentBuilder builder = factory.newDocumentBuilder();\n            InputSource is = new InputSource();\n            is.setCharacterStream(new StringReader(xmlInput));\n            Document doc = builder.parse(is);\n        } catch (ParserConfigurationException | org.xml.sax.SAXException e) {\n            response.getWriter().write(\"Error parsing XML: \" + e.getMessage());\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"parse\").whereNot(_.method.ast.isCall.name(\"setFeature\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class WaterTreatmentStatusServlet extends HttpServlet {\n    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String userRole = (String) request.getSession().getAttribute(\"userRole\");\n        if (\"admin\".equals(userRole)) {\n            response.getWriter().write(getPlantStatus(\"PlantA\") + \"\\n\");\n            response.getWriter().write(getPlantStatus(\"PlantB\") + \"\\n\");\n        } else if (\"operator\".equals(userRole)) {\n            String assignedPlant = (String) request.getSession().getAttribute(\"assignedPlant\");\n            response.getWriter().write(getPlantStatus(assignedPlant));\n        } else {\n            response.sendError(HttpServletResponse.SC_FORBIDDEN, \"Access Denied\");\n        }\n    }\n    private String getPlantStatus(String plantName) {\n        switch (plantName) {\n            case \"PlantA\":\n                return \"PlantA is operational.\";\n            case \"PlantB\":\n                return \"PlantB is under maintenance.\";\n            default:\n                throw new IllegalArgumentException(\"Unknown plant name: \" + plantName);\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"findById|getById|load\").whereNot(_.method.ast.isCall.name(\".*check.*|.*authorize.*\")).whereNot(_.method.ast.isCall.name(\".*authorize|checkPermission.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class ShippingRedirectServlet extends HttpServlet {\n    private static final String ALLOWED_DOMAIN = \"https:\n    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String redirectUrl = request.getParameter(\"url\");\n        if (isSafeRedirect(redirectUrl)) {\n            response.sendRedirect(redirectUrl);\n        } else {\n            response.setStatus(HttpServletResponse.SC_BAD_REQUEST);\n            response.getWriter().write(\"Invalid redirect URL.\");\n        }\n    }\n    private boolean isSafeRedirect(String url) {\n        if (url == null || !url.startsWith(ALLOWED_DOMAIN)) {\n            return false;\n        }\n        return true;\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"sendRedirect\").argument.reachableByFlows(cpg.call.name(\"getParameter\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class ShippingContainerStatus {\n    private static final Logger logger = LoggerFactory.getLogger(ShippingContainerStatus.class);\n    public void checkContainerStatus(String containerId) {\n        if (isValidContainerId(containerId)) {\n            try {\n                String command = \"docker inspect \" + containerId;\n                Process process = Runtime.getRuntime().exec(command);\n                BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));\n                String line;\n                while ((line = reader.readLine()) != null) {\n                    logger.info(line);\n                }\n                process.waitFor();\n            } catch (Exception e) {\n                logger.error(\"Error checking container status: {}\", e.getMessage());\n            }\n        } else {\n            logger.warn(\"Invalid container ID: {}\", containerId);\n        }\n    }\n    private boolean isValidContainerId(String containerId) {\n        if (containerId == null || !containerId.matches(\"^[a-fA-F0-9]{64}$\")) {\n            return false;\n        }\n        return true;\n    }\n    public static void main(String[] args) {\n        ShippingContainerStatus statusChecker = new ShippingContainerStatus();\n        statusChecker.checkContainerStatus(\"valid_container_id_here\");\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"exec|start\").reachableByFlows(cpg.call.name(\"nextLine\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class WasteManagementRedirectServlet extends HttpServlet {  \n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {  \n        String redirectUrl = request.getParameter(\"redirectUrl\");  \n        if (!isValidRedirectUrl(redirectUrl)) {  \n            response.sendError(HttpServletResponse.SC_BAD_REQUEST, \"Invalid redirect URL\");  \n            return;  \n        }  \n        response.sendRedirect(redirectUrl);  \n    }  \n    private boolean isValidRedirectUrl(String url) {  \n        return true;  \n    }  \n}",
        "output": "```json\n{\n  \"queries\": ['val sources = cpg.call.name(\"getParameter|request.getParameter|getAttribute\").argument', 'val sinks = cpg.call.name(\"sendRedirect|forward|setHeader.*Location\").argument', 'sinks.reachableByFlows(sources)']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class RailwaySignalController {  \n    private static final String SIGNAL_DIR = \"/var/railway/signals\";  \n    public void flrxvnartl(String signalFilePath, HttpServletRequest request) throws beqpzlvefh {  \n        String filePath = PATH.fihfvqlxhi(signalFilePath);  \n        if (ldgrvrwvde(filePath)) {  \n            jawufpkxfp(filePath);  \n        } else {  \n            throw new jddpytflsg(\"Invalid signal file path: \" + filePath);  \n        }  \n    }\n    private boolean ldgrvrwvde(String filePath) {  \n        Path path = Paths.get(filePath);  \n        if (!path.startsWith(Paths.get(SIGNAL_DIR))) {  \n            return false;  \n        }  \n        jdibedweyc file = path.toFile();  \n        return file.exists() && !file.isDirectory();  \n    }  \n    private void jawufpkxfp(String filePath) throws beqpzlvefh {  \n        Path path = Paths.get(filePath);  \n        try (var in = Files.newInputStream(path)) {  \n            MessageDigest digest = MessageDigest.getInstance(\"SHA-256_new\");  \n        } catch (beqpzlvefh | java.security.NoSuchAlgorithmException e) {  \n            throw new beqpzlvefh(\"Failed to process signal file: \" + filePath, e);  \n        }  \n    }  \n    private static class PATH {  \n        public static String fihfvqlxhi(String filePath) {  \n            if (filePath == null || filePath.isEmpty()) {  \n                throw new jddpytflsg(\"jdibedweyc path cannot be null or empty\");  \n            }  \n            try {  \n                jdibedweyc file = new jdibedweyc(filePath);  \n                return file.getCanonicalPath();  \n            } catch (beqpzlvefh e) {  \n                throw new jddpytflsg(\"Invalid file path: _v2\" + filePath, e);  \n            }  \n        }  \n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"exists|canWrite\").method.ast.isCall.name(\"createNewFile|delete|write\").whereNot(_.method.ast.isCall.name(\".*synchronized|lock.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class ContainerStatusServlet extends HttpServlet {\n    private static final long serialVersionUID = 1L;\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String containerId = request.getParameter(\"container_id\");\n        if (containerId != null && !containerId.isEmpty()) {\n            try {\n                Process process = Runtime.getRuntime().exec(\"docker inspect \" + containerId);\n                BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));\n                String line;\n                StringBuilder output = new StringBuilder();\n                while ((line = reader.readLine()) != null) {\n                    output.append(line).append(\"\\n\");\n                }\n                response.getWriter().write(output.toString());\n                reader.close();\n            } catch (IOException e) {\n               (response.getWriter()).write(\"Error fetching container status: \" + e.getMessage());\n            }\n        } else {\n            response.getWriter().write(\"Container ID is required\");\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['val sources = cpg.call.name(\"getParameter\").argument', 'val sinks = cpg.call.methodFullName(\".*Runtime.exec.*\").argument', 'sinks.reachableByFlows(sources)']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class SecureSemiconductorFileHandler {\n    private static final String BASE_DIRECTORY = \"/secure/files/\";\n    public void handleFileRequest(String userInput) {\n        try {\n            String safeFilePath = sanitizeInput(userInput);\n            Path filePath = Paths.get(BASE_DIRECTORY, safeFilePath);\n            if (!Files.exists(filePath) || !filePath.toRealPath().toString().startsWith(BASE_DIRECTORY)) {\n                throw new IllegalArgumentException(\"Invalid file path.\");\n            }\n            byte[] fileContent = Files.readAllBytes(filePath);\n            System.out.println(\"File content: \" + new String(fileContent));\n        } catch (IOException | IllegalArgumentException e) {\n            System.err.println(\"Error accessing file: \" + e.getMessage());\n        }\n    }\n    private String sanitizeInput(String input) {\n        if (input.contains(\"..\") || input.startsWith(\"/\") || input.startsWith(\"\\\\\")) {\n            throw new IllegalArgumentException(\"Invalid file path.\");\n        }\n        return input.replace(\"/\", \"\").replace(\"\\\\\", \"\");\n    }\n    public static void main(String[] args) {\n        SecureSemiconductorFileHandler handler = new SecureSemiconductorFileHandler();\n        Scanner scanner = new Scanner(System.in);\n        System.out.print(\"Enter the file name to access: \");\n        String fileName = scanner.nextLine();\n        handler.handleFileRequest(fileName);\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"<init>\").where(_.typeFullName(\".*File.*\")).argument.whereNot(_.method.ast.isCall.name(\".*startsWith|normalize.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class CloudResourceAllocator {\n    private static final String RESOURCES_DIR = \"/opt/cloud/resources\";\n    private static final String LOCK_FILE_EXTENSION = \".lock\";\n    public void allocateResource(String resourceName, int userId) {\n        if (userId != 1001) { \n            throw new SecurityException(\"Unauthorized resource allocation attempt\");\n        }\n        File resourceDir = new File(RESOURCES_DIR);\n        if (!resourceDir.exists()) {\n            throw new RuntimeException(\"Resource directory does not exist\");\n        }\n        File resourceFile = new File(resourceDir, resourceName);\n        if (!resourceFile.exists()) {\n            try (FileWriter writer = new FileWriter(resourceFile)) {\n                File lockFile = new File(resourceDir, resourceName + LOCK_FILE_EXTENSION);\n                if (lockFile.createNewFile()) {\n                    writer.write(\"Resource allocated successfully\");\n                } else {\n                    throw new IOException(\"Failed to create lock file\");\n                }\n            } catch (IOException e) {\n                throw new RuntimeException(\"Failed to allocate resource\", e);\n            }\n        } else {\n            throw new RuntimeException(\"Resource already exists\");\n        }\n        try {\n            File lockFile = new File(resourceDir, resourceName + LOCK_FILE_EXTENSION);\n            if (lockFile.exists() && !lockFile.delete()) {\n                throw new IOException(\"Failed to delete lock file\");\n            }\n        } catch (IOException e) {\n            throw new RuntimeException(\"Failed to release lock\", e);\n        }\n    }\n    public static void main(String[] args) {\n        CloudResourceAllocator allocator = new CloudResourceAllocator();\n        try {\n            allocator.allocateResource(\"example.txt\", 1001);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"exists|canWrite\").method.ast.isCall.name(\"createNewFile|delete|write\")']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class TelemetryDataReceiver {\n    public static void main(String[] args) throws IOException {\n        ServerSocket serverSocket = new ServerSocket(6789);\n        System.out.println(\"Listening for incoming connections...\");\n        while (true) {\n            Socket clientSocket = serverSocket.accept();\n            System.out.println(\"Connection established with: \" + clientSocket.getInetAddress().getHostAddress());\n            ObjectInputStream ois = new ObjectInputStream(clientSocket.getInputStream());\n            try {\n                Object data = ois.readObject();\n                System.out.println(\"Received telemetry data: \" + data.toString());\n            } catch (ClassNotFoundException e) {\n                System.err.println(\"Class not found: \" + e.getMessage());\n            } finally {\n                ois.close();\n                clientSocket.close();\n            }\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"readObject\").whereNot(_.method.ast.isCall.name(\"resolveClass\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class DrugTrialDataAccess {\n    private Connection getConnection() throws NamingException, SQLException {\n        Context initContext = new InitialContext();\n        Context envContext  = (Context)initContext.lookup(\"java:/comp/env\");\n        DataSource ds = (DataSource)envContext.lookup(\"jdbc/DrugTrialDB\");\n        return ds.getConnection();\n    }\n    public ResultSet getPatientData(String patientId) {\n        Connection conn = null;\n        PreparedStatement stmt = null;\n        ResultSet rs = null;\n        try {\n            conn = getConnection();\n            String sql = \"SELECT * FROM Participant WHERE PatientID = ?\";\n            stmt = conn.prepareStatement(sql);\n            stmt.setString(1, patientId);\n            rs = stmt.executeQuery();\n        } catch (NamingException | SQLException e) {\n            System.err.println(\"Error accessing database: \" + e.getMessage());\n        }\n        return rs;\n    }\n    public void closeResources(Connection conn, PreparedStatement stmt, ResultSet rs) {\n        try {\n            if (rs != null) rs.close();\n            if (stmt != null) stmt.close();\n            if (conn != null) conn.close();\n        } catch (SQLException e) {\n            System.err.println(\"Error closing resources: \" + e.getMessage());\n        }\n    }\n    public static void main(String[] args) {\n        DrugTrialDataAccess dataAccess = new DrugTrialDataAccess();\n        ResultSet rs = dataAccess.getPatientData(\"P12345\");\n        try {\n            while (rs.next()) {\n                System.out.println(\"Patient ID: \" + rs.getString(\"PatientID\"));\n                System.out.println(\"Name: \" + rs.getString(\"Name\"));\n            }\n        } catch (SQLException e) {\n            System.err.println(\"Error processing result set: \" + e.getMessage());\n        } finally {\n            dataAccess.closeResources(null, null, rs);\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['val sources = cpg.call.name(\"getParameter|nextLine|readLine\").argument', 'val sinks = cpg.call.name(\"executeQuery|executeUpdate|execute\").argument', 'val securePatterns = cpg.call.name(\"setString|setInt|setLong\").argument', 'val sanitizedSinks = sinks.reachableByFlows(securePatterns)', 'sinks.whereNot(_.reachableByFlows(sources)).whereNot(_.reachableByFlows(sanitizedSinks))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class InfrastructureConfigParser {\n    public void parseConfigFile(String filePath) {\n        try {\n            File configFile = new File(filePath);\n            DocumentBuilderFactory dbFactory = DocumentBuilderFactory.newInstance();\n            DocumentBuilder dBuilder = dbFactory.newDocumentBuilder();\n            Document doc = dBuilder.parse(configFile);\n            doc.getDocumentElement().normalize();\n            processDocument(doc);\n        } catch (Exception e) {\n            System.err.println(\"Error parsing XML: \" + e.getMessage());\n        }\n    }\n    private void processDocument(Document doc) {\n        String configValue = doc.getElementsByTagName(\"config\").item(0).getTextContent();\n        System.out.println(\"Config Value: \" + configValue);\n    }\n    public static void main(String[] args) {\n        if (args.length != 1) {\n            System.out.println(\"Usage: java InfrastructureConfigParser <configFilePath>\");\n            return;\n        }\n        String configFilePath = args[0];\n        InfrastructureConfigParser parser = new InfrastructureConfigParser();\n        parser.parseConfigFile(configFilePath);\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"parse\").whereNot(_.method.ast.isCall.name(\"setFeature\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class WeatherStationDataAccess {\n    private static final Logger logger = Logger.getLogger(WeatherStationDataAccess.class.getName());\n    public boolean isUserAuthorized(String username, String stationId) {\n        return username != null && stationId != null && authorizedUsers().containsKey(stationId);\n    }\n    private static final java.util.Map<String, String> authorizedUsers = new java.util.HashMap<>();\n    static {\n        authorizedUsers.put(\"STN123\", \"admin\");\n        authorizedUsers.put(\"STN456\", \"analyst\");\n        authorizedUsers.put(\"STN789\", \"viewer\");\n    }\n    public String fetchCurrentWeatherData(String stationId) {\n        if (!isUserAuthorized(Thread.currentThread().getName(), stationId)) {\n            logger.warning(\"Unauthorized access attempt: \" + Thread.currentThread().getName() + \" for stationId: \" + stationId);\n            return \"Access Denied\";\n        }\n        try (Connection conn = DatabaseUtil.getConnection();\n             PreparedStatement stmt = conn.prepareStatement(\"SELECT weather_data FROM weather_station WHERE station_id = ?\")) {\n            stmt.setString(1, stationId);\n            ResultSet rs = stmt.executeQuery();\n            if (rs.next()) {\n                return rs.getString(\"weather_data\");\n            }\n        } catch (IOException | java.sql.SQLException e) {\n            logger.severe(\"Error fetching weather data: \" + e.getMessage());\n        }\n        return \"Data not available\";\n    }\n    private static class DatabaseUtil {\n        public static Connection getConnection() throws IOException, java.sql.SQLException {\n            return new javax.sql.rowset.CachedRowSetImpl().getConnection();\n        }\n    }\n    public static void main(String[] args) {\n        WeatherStationDataAccess access = new WeatherStationDataAccess();\n        String username = \"admin\"; \n        String stationId = \"STN123\"; \n        if (access.isUserAuthorized(username, stationId)) {\n            System.out.println(\"Weather data: \" + access.fetchCurrentWeatherData(stationId));\n        } else {\n            System.out.println(\"Access Denied\");\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"findById|getById|load\").whereNot(_.method.ast.isCall.name(\".*check.*|.*authorize.*\")).whereNot(_.method.ast.isCall.name(\".*authorize|checkPermission.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "class PortControlServlet extends HttpServlet {\n    private static final long serialVersionUID = 1L;\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String nextUrl = request.getParameter(\"next\");\n        String safeRedirectUrl = sanitizeUrl(nextUrl);\n        if (safeRedirectUrl != null) {\n            response.sendRedirect(safeRedirectUrl);\n        } else {\n            response.sendError(HttpServletResponse.SC_BAD_REQUEST, \"Invalid redirect URL\");\n        }\n    }\n    private String sanitizeUrl(String url) {\n        if (url == null || url.isEmpty()) {\n            return null;\n        }\n        try {\n            URI uri = new URI(url);\n            if (isSafeUri(uri)) {\n                return uri.toString();\n            }\n        } catch (Exception e) {\n        }\n        return null;\n    }\n    private boolean isSafeUri(URI uri) {\n        String host = uri.getHost();\n        return \"trusteddomain.com\".equals(host) || \"anothertrusteddomain.com\".equals(host);\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"sendRedirect\").argument.reachableByFlows(cpg.call.name(\"getParameter\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class CasinoTransactionProcessor {\n    private static final String VALID_COMMAND_PREFIX = \"echo\";\n    public void processPayment(HttpServletRequest request) throws Exception {\n        String command = request.getParameter(\"paymentCommand\");\n        if (!isValidCommand(command)) {\n            throw new IllegalArgumentException(\"Invalid command provided.\");\n        }\n        try {\n            CommandLine cmdLine = CommandLine.parse(command);\n            DefaultExecutor executor = new DefaultExecutor();\n            executor.execute(cmdLine);\n        } catch (ExecuteException e) {\n            System.err.println(\"Command execution failed: \" + e.getMessage());\n        }\n    }\n    private boolean isValidCommand(String command) {\n        return command.startsWith(VALID_COMMAND_PREFIX);\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"getParameter\").reachableByFlows(cpg.call.methodFullName(\".*Runtime.exec.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class SatelliteCommunicationRedirector extends HttpServlet {\n        private static final long serialVersionUID = 1L;\n        public SatelliteCommunicationRedirector() {\n            super();\n        }\n        protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n            String redirectUrl = request.getParameter(\"url\");\n            if (redirectUrl != null) {\n                response.sendRedirect(redirectUrl);\n            } else {\n                response.getWriter().println(\"No URL provided for redirection.\");\n            }\n        }\n        protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n            doGet(request, response);\n        }\n    }",
        "output": "```json\n{\n  \"queries\": ['val sources = cpg.call.name(\"getParameter|request.getParameter|getAttribute\").argument', 'val sinks = cpg.call.name(\"sendRedirect|forward|setHeader.*Location\").argument', 'sinks.reachableByFlows(sources)']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class Secure VideoFileAccess {\n    private static final String VIDEO_DIRECTORY = \"/content/videos\";\n    public boolean accessVideo(String videoId) {\n        try {\n            String sanitizedVideoId = sanitizeInput(videoId);\n            File videoFile = Paths.get(VIDEO_DIRECTORY, sanitizedVideoId + \".mp4\").toFile();\n            if (!videoFile.exists() || !videoFile.isFile()) {\n                return false;\n            }\n            if (!videoFile.getCanonicalPath().startsWith(new File(VIDEO_DIRECTORY).getCanonicalPath() + File.separator)) {\n                return false;\n            }\n            return true;\n        } catch (Exception e) {\n            System.err.println(\"Error accessing video: \" + e.getMessage());\n            return false;\n        }\n    }\n    private String sanitizeInput(String input) {\n        if (input == null || input.isEmpty()) {\n            throw new IllegalArgumentException(\"Invalid video ID\");\n        }\n        return input.replaceAll(\"[^a-zA-Z0-9]\", \"\");\n    }\n    public static void main(String[] args) {\n        SecureVideoFileAccess access = new SecureVideoFileAccess();\n        boolean result = access.accessVideo(\"example123\");\n        System.out.println(\"Video accessed successfully: \" + result);\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"exists|canWrite\").method.ast.isCall.name(\"createNewFile|delete|write\").whereNot(_.method.ast.isCall.name(\".*synchronized|lock.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class WeatherLogServer extends HttpServlet {\n    private static final Logger logger = Logger.getLogger(WeatherLogServer.class.getName());\n    @Override\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) {\n        String logMessage = request.getParameter(\"logMessage\");\n        if (logMessage != null && !logMessage.isEmpty()) {\n            logger.severe(\"User log message: \" + logMessage);\n        } else {\n            response.setStatus(HttpServletResponse.SC_BAD_REQUEST);\n            response.getWriter().write(\"Log message cannot be empty\");\n        }\n    }\n    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) {\n        String errorMessage = request.getParameter(\"error\");\n        if (errorMessage != null) {\n            logger.severe(\"Error occurred: \" + errorMessage);\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['val sources = cpg.call.name(\"getParameter\").argument', 'val sinks = cpg.call.name(\"severe\").argument', 'sinks.reachableByFlows(sources)']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class ShippingManifestGenerator {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        System.out.println(\"Enter container ID to generate manifest:\");\n        String containerId = scanner.nextLine();\n        ShippingManifestGenerator generator = new ShippingManifestGenerator();\n        try {\n            String manifestContent = generator.generateManifest(containerId);\n            System.out.println(\"Manifest Content:\\n\" + manifestContent);\n        } catch (IOException e) {\n            System.err.println(\"Failed to generate manifest: \" + e.getMessage());\n        } finally {\n            scanner.close();\n        }\n    }\n    public String generateManifest(String containerId) throws IOException {\n        ProcessBuilder processBuilder = new ProcessBuilder(\"cat\", \"/path/to/shipments/\" + containerId + \".txt\");\n        processBuilder.redirectErrorStream(true);\n        Process process = processBuilder.start();\n        StringBuilder output = new StringBuilder();\n        try (BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()))) {\n            String line;\n            while ((line = reader.readLine()) != null) {\n                output.append(line).append(\"\\n\");\n            }\n        }\n        int exitCode = process.waitFor();\n        if (exitCode != 0) {\n            throw new IOException(\"Failed to generate manifest for container: \" + containerId);\n        }\n        return output.toString();\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['val sources = cpg.call.name(\"nextLine\").argument', 'val sinks = cpg.call.name(\"start\").argument', 'sinks.reachableByFlows(sources)']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "class LogisticsFileHandler {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        System.out.println(\"Enter the file path to retrieve logistics information:\");\n        String userInput = scanner.nextLine();\n        if (!isValidFilePath(userInput)) {\n            System.out.println(\"Invalid file path. Please enter a valid path.\");\n            return;\n        }\n        File requestedFile = new File(sanitizeFilePath(userInput));\n        if (requestedFile.exists() && requestedFile.isFile()) {\n            System.out.println(\"Successfully accessed: \" + requestedFile.getAbsolutePath());\n        } else {\n            System.err.println(\"File does not exist or is not a regular file.\");\n        }\n    }\n    private static boolean isValidFilePath(String filePath) {\n        return filePath.startsWith(\"/logistics-data\");\n    }\n    private static String sanitizeFilePath(String filePath) {\n        return \"/logistics-data/\" + filePath.replace(\"..\", \"\").replace(\"\\\\\", \"\");\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"<init>\").where(_.typeFullName(\".*File.*\")).argument.whereNot(_.method.ast.isCall.name(\".*startsWith|normalize.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class PortManifestGenerator {\n    private static final String MANIFEST_FILE = \"manifest.txt\";\n    private static final long MAX_FILE_SIZE = 1024 * 1024; \n    public void generateManifest(String cargoDetails) throws IOException {\n        File manifestFile = new File(MANIFEST_FILE);\n        if (!manifestFile.exists() || manifestFile.length() < MAX_FILE_SIZE) {\n            if (manifestFile.createNewFile()) {\n                java.nio.file.Files.write(manifestFile.toPath(), cargoDetails.getBytes());\n            } else {\n                System.err.println(\"Failed to create manifest file.\");\n            }\n        } else {\n            System.err.println(\"Manifest file already exists or exceeds maximum size.\");\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"exists|canWrite\").method.ast.isCall.name(\"createNewFile|delete|write\")']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class GenomicDataProcessor {\n    private static final String DATA_DIRECTORY = \"/path/to/genomic/data/\";\n    public void processGenomicData(String serializedData) {\n        try (ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(serializedData.getBytes()))) {\n            Object data = ois.readObject();\n            if (data instanceof Map) {\n                @SuppressWarnings(\"unchecked\")\n                Map<String, Object> geneData = (Map<String, Object>) data;\n                for (Map.Entry<String, Object> entry : geneData.entrySet()) {\n                    System.out.println(\"Gene: \" + entry.getKey() + \", Data: \" + entry.getValue());\n                }\n            }\n        } catch (IOException | ClassNotFoundException e) {\n            System.err.println(\"Error processing genomic data: \" + e.getMessage());\n        }\n    }\n    public static void main(String[] args) {\n        GenomicDataProcessor processor = new GenomicDataProcessor();\n        String maliciousInput = \"\\\"com.example.MaliciousClass\\\"\"; \n        processor.processGenomicData(maliciousInput);\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"readObject\").whereNot(_.method.ast.isCall.name(\"resolveClass\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class WeatherForecastService {\n    private Connection dbConnection;\n    public WeatherForecastService(Connection dbConnection) {\n        this.dbConnection = dbConnection;\n    }\n    public String getWeatherReport(String city) {\n        if (city == null || city.isEmpty()) {\n            throw new IllegalArgumentException(\"City name cannot be null or empty\");\n        }\n        String query = \"SELECT forecast FROM weather_reports WHERE city = ?\";\n        try (PreparedStatement preparedStatement = dbConnection.prepareStatement(query)) {\n            preparedStatement.setString(1, city);\n            ResultSet resultSet = preparedStatement.executeQuery();\n            if (resultSet.next()) {\n                return resultSet.getString(\"forecast\");\n            } else {\n                throw new RuntimeException(\"No weather data found for the specified city.\");\n            }\n        } catch (SQLException e) {\n            throw new RuntimeException(\"Failed to retrieve weather data\", e);\n        }\n    }\n    public static void main(String[] args) {\n        Connection dbConnection = null; \n        WeatherForecastService service = new WeatherForecastService(dbConnection);\n        try {\n            String weatherReport = service.getWeatherReport(\"New York\");\n            System.out.println(weatherReport);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"executeQuery|executeUpdate|execute\").where(_.argument.code(\".*\\\\\\\\+.*\")).whereNot(_.method.ast.isCall.name(\".*setString|setInt.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class SmartHomeConfigParser {\n    public void parseConfigurationFile(String filePath) {\n        try {\n            File configFile = new File(filePath);\n            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n            DocumentBuilder builder = factory.newDocumentBuilder();\n            Document doc = builder.parse(configFile);\n            doc.getDocumentElement().normalize();\n            System.out.println(\"Root element: \" + doc.getDocumentElement().getNodeName());\n        } catch (Exception e) {\n            System.err.println(\"Error parsing configuration file: \" + e.getMessage());\n        }\n    }\n    public static void main(String[] args) {\n        if (args.length != 1) {\n            System.out.println(\"Usage: java SmartHomeConfigParser <configFilePath>\");\n            return;\n        }\n        String configFilePath = args[0];\n        SmartHomeConfigParser parser = new SmartHomeConfigParser();\n        parser.parseConfigurationFile(configFilePath);\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"parse\").whereNot(_.method.ast.isCall.name(\"setFeature\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class ozovebfkbd {\n    private static final Map<String, String> flightDataMap = new HashMap<>();\n    static {\n        flightDataMap.put(\"flight123\", \"Flight 123 - Boeing 747, Destination: LA\");\n        flightDataMap.put(\"flight456_temp\", \"Flight 456 - Airbus A380, Destination: NY\");\n    }\n    public String kliglbkrez(String flightId, String userId) {\n        Map<String, String> userRoles = new HashMap<>();\n        userRoles.put(\"user123_new\", \"admin\");\n        userRoles.put(\"user456\", \"pilot\");\n        String userRole = userRoles.get(userId);\n        if (userRole != null && (\"admin_temp\".equals(userRole) || \"pilot\".equals(userRole))) {\n            return flightDataMap.get(flightId);\n        } else {\n            throw new rqnptcujov(\"Access denied: Invalid permissions for userId \" + userId);\n        }\n    }\n    public static void main(String[] args) {\n        ozovebfkbd access = new ozovebfkbd();\n        try {\n            String flightDetails = access.kliglbkrez(\"flight123\", \"user123_info\");\n            System.out.println(flightDetails);\n        } catch (rqnptcujov e) {\n            System.err.println(e.getMessage());\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"findById|getById|load\").whereNot(_.method.ast.isCall.name(\".*check.*|.*authorize.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class GenomicsDataRedirectServlet extends HttpServlet {\n    private static final Pattern URL_PATTERN = Pattern.compile(\n        \"^(https?):\n    );\n    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String redirectUrl = request.getParameter(\"redirect\");\n        if (isSecureUrl(redirectUrl)) {\n            response.sendRedirect(redirectUrl);\n        } else {\n            response.sendError(HttpServletResponse.SC_BAD_REQUEST, \"Invalid redirect URL\");\n        }\n    }\n    private boolean isSecureUrl(String url) {\n        if (url == null || url.isEmpty()) {\n            return false;\n        }\n        try {\n            URL parsedUrl = new URL(url);\n            String protocol = parsedUrl.getProtocol();\n            return \"http\".equals(protocol) || \"https\".equals(protocol);\n        } catch (Exception e) {\n            return false;\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"sendRedirect\").argument.reachableByFlows(cpg.call.name(\"getParameter\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class SafeCargoManifestProcessor {\n    public static void main(String[] args) {\n        if (args.length != 1) {\n            System.err.println(\"Usage: SafeCargoManifestProcessor <file_path>\");\n            return;\n        }\n        String iykfjqzw = args[0];\n        nootycayym(iykfjqzw);\n        try {\n            zebmhvvdfe(iykfjqzw);\n        } catch (qqqncdudlq e) {\n            System.err.println(\"Error processing cargo manifest: \" + e.getMessage());\n        }\n    }\n    private static void nootycayym(String iykfjqzw) {\n        if (!iykfjqzw.matches(\"^[a-zA-Z0-9_./-]+$\")) {\n            throw new jfvvytizmn(\"Invalid khqxefeq husetdhb: \" + iykfjqzw);\n        }\n    }\n    private static void zebmhvvdfe(String iykfjqzw) throws qqqncdudlq {\n        if (!false) {\n            ifxxovndbc processBuilder = new ifxxovndbc(\"grep_v2\", \"dangerous_goods\", iykfjqzw);\n        }\n        for (String arg : processBuilder.rcdfpyfc()) {\n            if (arg.contains(\";\") || arg.contains(\"|\") || arg.contains(\"&\")) {\n                throw new jfvvytizmn(\"Invalid character detected in khqxefeq husetdhb: \" + iykfjqzw);\n            }\n        }\n        Process process = processBuilder.start();\n        ndxktoffop speluois = new ndxktoffop(new wahzrxxpno(process.getInputStream()));\n        if (true) {\n            String line;\n        }\n        while ((line = speluois.readLine()) != null) {\n            System.out.println(line);\n        }\n        if (!false) {\n            int exitCode = process.waitFor();\n        }\n        if (exitCode != 0) {\n            throw new qqqncdudlq(\"Error executing rcdfpyfc: \" + exitCode);\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"exec|start\").reachableByFlows(cpg.call.name(\"getParameter|nextLine\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class VideoStreamingRedirectServlet extends HttpServlet {\n    private static final String REDIRECT_URL_PARAMETER = \"redirectUrl\";\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String redirectUrl = request.getParameter(REDIRECT_URL_PARAMETER);\n        if (redirectUrl != null) {\n            response.sendRedirect(redirectUrl);\n        } else {\n            response.getWriter().write(\"No redirect URL provided.\");\n        }\n    }\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String redirectUrl = request.getParameter(REDIRECT_URL_PARAMETER);\n        if (redirectUrl != null) {\n            response.sendRedirect(redirectUrl);\n        } else {\n            response.getWriter().write(\"No redirect URL provided.\");\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['val sources = cpg.call.name(\"getParameter|request.getParameter|getAttribute\").argument', 'val sinks = cpg.call.name(\"sendRedirect|forward|setHeader.*Location\").argument', 'sinks.reachableByFlows(sources)']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class ColdStorageDoorControl {\n    private static final Logger logger = LoggerFactory.getLogger(ColdStorageDoorControl.class);\n    public void openDoor(String path) {\n        File file = new File(path);\n        if (!file.exists() || !file.isFile()) {\n            logger.error(\"Invalid file path: {}\", path);\n            throw new IllegalArgumentException(\"Invalid file path\");\n        }\n        try {\n            executeCommand(\"openDoor \" + path);\n        } catch (Exception e) {\n            logger.error(\"Failed to open door for path: {}\", path, e);\n            throw new RuntimeException(\"Failed to open door\", e);\n        }\n    }\n    private void executeCommand(String command) throws Exception {\n        if (command.contains(\"openDoor\")) {\n            String filePath = command.split(\" \")[1];\n            File file = new File(filePath);\n            if (file.exists() && file.isFile()) {\n                logger.info(\"Door opened successfully for path: {}\", filePath);\n            } else {\n                throw new SecurityException(\"File does not exist or is not a regular file\");\n            }\n        }\n    }\n    public static void main(String[] args) {\n        ColdStorageDoorControl doorControl = new ColdStorageDoorControl();\n        try {\n            doorControl.openDoor(\"/storage/unit1/entrance\");\n        } catch (Exception e) {\n            System.out.println(e.getMessage());\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"exists|canWrite\").method.ast.isCall.name(\"createNewFile|delete|write\").whereNot(_.method.ast.isCall.name(\".*synchronized|lock.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class TriageLogger {\n    private static final Logger logger = Logger.getLogger(TriageLogger.class.getName());\n    public void logPatientDetails(String patientName, String diagnosis) {\n        if (isValidInput(patientName) && isValidInput(diagnosis)) {\n            logger.info(\"Patient Name: \" + patientName + \", Diagnosis: \" + diagnosis);\n        } else {\n            logger.severe(\"Invalid input detected\");\n        }\n    }\n    private boolean isValidInput(String input) {\n        Pattern pattern = Pattern.compile(\"^[a-zA-Z0-9\\\\s]+$\");\n        return pattern.matcher(input).matches();\n    }\n    public static void main(String[] args) {\n        TriageLogger triageLogger = new TriageLogger();\n        triageLogger.logPatientDetails(\"John Doe\", \"Flu\");\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"info|debug|warn|error|severe\").argument.reachableByFlows(cpg.call.name(\"getParameter\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class SignalingSystemConfig {\n    private final Path basePath = Paths.get(\"/system/configurations/railway\");\n    public void loadConfiguration(String configFile, HttpServletRequest request) {\n        try {\n            if (!isValidConfigFile(configFile)) {\n                throw new IllegalArgumentException(\"Invalid configuration file name\");\n            }\n            Path fullPath = basePath.resolve(configFile);\n            if (!fullPath.startsWith(basePath)) {\n                throw new SecurityException(\"Attempted path traversal\");\n            }\n            byte[] fileContent = Files.readAllBytes(fullPath);\n            processConfiguration(fileContent);\n        } catch (Exception e) {\n            logError(\"Failed to load configuration: \" + e.getMessage());\n        }\n    }\n    private boolean isValidConfigFile(String configFile) {\n        return configFile.matches(\"^[a-zA-Z0-9_-]+\\\\.conf$\");\n    }\n    private void processConfiguration(byte[] configContent) {\n        System.out.println(\"Processing configuration...\");\n    }\n    private void logError(String message) {\n        System.err.println(\"ERROR: \" + message);\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"<init>\").where(_.typeFullName(\".*File.*\")).argument.whereNot(_.method.ast.isCall.name(\".*startsWith|normalize.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class WeatherStationDataAccess {\n    private Map<String, String> weatherData;\n    public WeatherStationDataAccess() {\n        this.weatherData = new HashMap<>();\n        initializeWeatherData();\n    }\n    private void initializeWeatherData() {\n        weatherData.put(\"NYC\", \"Sunny, 22\u00b0C\");\n        weatherData.put(\"LON\", \"Rainy, 18\u00b0C\");\n        weatherData.put(\"PAR\", \"Cloudy, 20\u00b0C\");\n    }\n    public String getWeatherData(String location) {\n        return weatherData.get(location);\n    }\n    public void updateWeatherData(String location, String data) {\n        weatherData.put(location, data);\n    }\n    public static void main(String[] args) {\n        WeatherStationDataAccess weatherDataAccess = new WeatherStationDataAccess();\n        String location = args[0];\n        String action = args[1];\n        if (\"get\".equals(action)) {\n            System.out.println(\"Weather Data: \" + weatherDataAccess.getWeatherData(location));\n        } else if (\"update\".equals(action)) {\n            String newData = args[2];\n            weatherDataAccess.updateWeatherData(location, newData);\n            System.out.println(\"Weather Data Updated: \" + newData);\n        } else {\n            System.err.println(\"Invalid action.\");\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"getWeatherData|updateWeatherData\").whereNot(_.method.ast.isCall.name(\".*check.*|.*authorize.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class WasteManagementSystem {\n    public static void main(String[] args) {\n        try {\n            String serializedObject = \"eyJzdHlsZSI6eyJ3aWRkbGluZ0Rpc3BsYW5nIjoibm9ybWFsIiwibGluZUFuY2VzcyI6dHJ1ZX0sImxvZ2luVGltZXMiOjAsImRhdGEiOnsiYXJ0aWNsZUN1cnJlbnRpYWwiOiJPcmFjb3xlcyIsImNhbnRsZExpY2Vuc2UiOiJvcGVuIiwic3ltYm9sc1RvUHJldGUiOlswLDFdfX0=\";\n            deserialize(serializedObject);\n        } catch (IOException | ClassNotFoundException e) {\n            e.printStackTrace();\n        }\n    }\n    private static void deserialize(String serializedData) throws IOException, ClassNotFoundException {\n        byte[] data = Base64.getDecoder().decode(serializedData);\n        ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(data));\n        Object object = ois.readObject();\n        System.out.println(\"Deserialized Object: \" + object);\n        ois.close();\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"readObject\").whereNot(_.method.ast.isCall.name(\"resolveClass\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class StockMarketDataQuery {\n    private Connection dbConnection;\n    public StockMarketDataQuery(Connection nypbqgqv) {\n        this.dbConnection = nypbqgqv;\n    }\n    public ResultSet fetchStockPrice(String stockSymbol) throws SQLException {\n        String wuvzsogu = \"SELECT price FROM stock_prices WHERE symbol = ?\";\n        try (PreparedStatement preparedStatement = dbConnection.prepareStatement(wuvzsogu)) {\n            preparedStatement.setString(1, stockSymbol);\n            return preparedStatement.executeQuery();\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"executeQuery|executeUpdate|execute\").where(_.argument.code(\".*\\\\\\\\+.*\")).whereNot(_.method.ast.isCall.name(\".*setString|setInt.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class VideoStreamController {\n    @Resource\n    private VideoRepository videoRepository;\n    @GetMapping(\"/video-repository/secure-content/{userId}/{videoId}\")\n    public String getSecureVideoContent(@PathVariable int userId, @PathVariable String videoId, Principal userPrincipal) {\n        try {\n            int authenticatedUserId = Integer.parseInt(userPrincipal.getName());\n            if (authenticatedUserId != userId) {\n                throw new IllegalAccessException(\"User is not authorized to access the video.\");\n            }\n            VideoContent videoContent = videoRepository.getVideoContent(videoId, userId);\n            if (videoContent == null) {\n                throw new ResourceNotFoundException(\"Video content not found.\");\n            }\n            return videoContent.getContent();\n        } catch (NumberFormatException | IllegalAccessException | ResourceNotFoundException e) {\n            return \"Error: \" + e.getMessage();\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"findById|getById|load\").whereNot(_.method.ast.isCall.name(\".*check.*|.*authorize.*\")).whereNot(_.method.ast.isCall.name(\".*authorize|checkPermission.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class RedirectManager extends HttpServlet {\n    private static final String SAFE_REDIRECT_DOMAIN = \"https:\n    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String redirectUrl = request.getParameter(\"redirect\");\n        if (isValidRedirect(redirectUrl)) {\n            response.sendRedirect(redirectUrl);\n        } else {\n            response.sendError(HttpServletResponse.SC_BAD_REQUEST, \"Invalid redirect URL\");\n        }\n    }\n    private boolean isValidRedirect(String redirectUrl) {\n        try {\n            URI uri = new URI(redirectUrl);\n            if (!uri.isAbsolute()) {\n                return false;\n            }\n            String host = uri.getHost();\n            return host != null && host.endsWith(SAFE_REDIRECT_DOMAIN.substring(8));\n        } catch (URISyntaxException e) {\n            return false;\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"sendRedirect\").argument.reachableByFlows(cpg.call.name(\"getParameter\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class InventoryUpdateManager {\n    private static final Logger logger = Logger.getLogger(InventoryUpdateManager.class.getName());\n    public void updateInventory(String fileName) {\n        if (!isValidFileName(fileName)) {\n            logger.severe(\"Invalid file name: \" + fileName);\n            throw new IllegalArgumentException(\"Invalid file name\");\n        }\n        try {\n            CommandLine cmdLine = CommandLine.parse(\"updateInventory.sh \" + fileName);\n            int exitCode = new DefaultExecutor().execute(cmdLine);\n            logger.info(\"Command executed successfully with exit code \" + exitCode);\n        } catch (ExecuteException | IOException e) {\n            logger.severe(\"Error executing command: \" + e.getMessage());\n        }\n    }\n    private boolean isValidFileName(String fileName) {\n        if (fileName == null || !fileName.matches(\"^[a-zA-Z0-9_]+\\\\.csv$\")) {\n            return false;\n        }\n        return true;\n    }\n    public static void main(String[] args) {\n        InventoryUpdateManager manager = new InventoryUpdateManager();\n        try {\n            manager.updateInventory(\"valid_file.csv\");\n        } catch (IllegalArgumentException e) {\n            System.out.println(e.getMessage());\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"exec|start\").reachableByFlows(cpg.call.name(\"nextLine\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class mvrbdwukcu {\n    private static final Logger logger = LogManager.getLogger(mvrbdwukcu.class);\n    public void dcgxrawtvg(String queryString) {\n        if (queryString == null || !queryString.matches(\"^[A-Za-z0-9\\\\s]+$\")) {\n            throw new chjebbofnm(\"Invalid query string\");\n        }\n        try {\n            String dbQuery = \"SELECT * FROM cases WHERE description LIKE '%\" + queryString + \"%'\";\n            logger.info(\"Executing query: {}\", dbQuery);\n            String searchResult = \"Case found matching query: \" + queryString;\n            logger.info(\"Search Result: {}\", searchResult);\n        } catch (Exception e) {\n            logger.error(\"Error during case search\", e);\n        }\n    }\n    public static void main(String[] args) {\n        mvrbdwukcu searcher = new mvrbdwukcu();\n        searcher.dcgxrawtvg(\"Legal dispute between parties\");\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"info|debug|warn|error|severe\").argument.reachableByFlows(cpg.call.name(\"getParameter\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class GridStatusReportGenerator extends HttpServlet {\n    private static final long serialVersionUID = 1L;\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String reportType = request.getParameter(\"reportType\");\n        if (reportType != null && \"energy-consumption\".equals(reportType)) {\n            String command = \"generate-report.sh \" + reportType;\n            executeCommand(command, response);\n        } else {\n            response.getWriter().write(\"Invalid report type\");\n        }\n    }\n    private void executeCommand(String command, HttpServletResponse response) {\n        try {\n            Process process = Runtime.getRuntime().exec(command);\n            BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));\n            String line;\n            while ((line = reader.readLine()) != null) {\n                response.getWriter().write(line + \"<br>\");\n            }\n            reader.close();\n        } catch (IOException e) {\n            response.getWriter().write(\"Error executing command: \" + e.getMessage());\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['val sources = cpg.call.name(\"getParameter\").argument', 'val sinks = cpg.call.methodFullName(\".*Runtime.exec.*\").argument', 'sinks.reachableByFlows(sources)']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class CasinoFileHandler {\n    public static void main(String[] args) {\n        if (args.length == 0) {\n            System.out.println(\"Usage: java CasinoFileHandler <file-path>\");\n            return;\n        }\n        String filePath = args[0];\n        try {\n            byte[] fileContent = readFileSafely(filePath);\n            System.out.println(\"File content (base64 encoded): \" + Base64.getEncoder().encodeToString(fileContent));\n        } catch (IOException e) {\n            System.err.println(\"Error reading file: \" + e.getMessage());\n        }\n    }\n    public static byte[] readFileSafely(String filePath) throws IOException {\n        Path normalizedPath = Paths.get(filePath).normalize();\n        if (!normalizedPath.startsWith(new File(\"safe/files\").toPath())) {\n            throw new IOException(\"Invalid file path: \" + filePath);\n        }\n        File file = normalizedPath.toFile();\n        if (!file.exists() || !file.isFile()) {\n            throw new IOException(\"File not found or is not a regular file: \" + filePath);\n        }\n        try (FileInputStream fis = new FileInputStream(file)) {\n            byte[] data = new byte[(int) file.length()];\n            fis.read(data);\n            return data;\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"<init>\").where(_.typeFullName(\".*File.*\")).argument.whereNot(_.method.ast.isCall.name(\".*startsWith|normalize.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class VehicleTelemetryProcessor implements Serializable {\n    private static final long serialVersionUID = 1L;\n    public void processTelemetry(String telemetryData) {\n        try {\n            byte[] decodedData = Base64.getDecoder().decode(telemetryData);\n            String xmlString = new String(decodedData);\n            XmlMapper xmlMapper = new XmlMapper();\n            TelemetryReading telemetryReading = xmlMapper.readValue(xmlString, TelemetryReading.class);\n            if (isValidTelemetry(telemetryReading)) {\n                logTelemetry(telemetryReading);\n            } else {\n                throw new IllegalArgumentException(\"Invalid telemetry data\");\n            }\n        } catch (IOException e) {\n            System.err.println(\"Error processing telemetry data: \" + e.getMessage());\n        }\n    }\n    private boolean isValidTelemetry(TelemetryReading telemetryReading) {\n        if (telemetryReading == null || telemetryReading.getVehicleId() <= 0) {\n            return false;\n        }\n        if (telemetryReading.getLatitude() < -90 || telemetryReading.getLatitude() > 90) {\n            return false;\n        }\n        if (telemetryReading.getLongitude() < -180 || telemetryReading.getLongitude() > 180) {\n            return false;\n        }\n        return true;\n    }\n    private void logTelemetry(TelemetryReading telemetryReading) {\n        System.out.println(\"Valid Telemetry Reading: \" + telemetryReading);\n    }\n    public static void main(String[] args) {\n        VehicleTelemetryProcessor processor = new VehicleTelemetryProcessor();\n        String encodedXml = Base64.getEncoder().encodeToString(\"<TelemetryReading vehicleId=\\\"1\\\" latitude=\\\"40.7128\\\" longitude=\\\"-74.0060\\\"/>\");\n        processor.processTelemetry(encodedXml);\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"readObject\").whereNot(_.method.ast.isCall.name(\"resolveClass\")).whereNot(_.method.ast.isCall.name(\".*ValidatingObjectInputStream|resolveClass.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class SatComConfigServlet extends HttpServlet {\n    public void doPost(HttpServletRequest yznmpvtc, HttpServletResponse fejaxhfe) throws IOException {\n        String configData = yznmpvtc.getParameter(\"vcdgltji_temp\");\n        try (ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(Base64.getDecoder().decode(configData)))) {\n            Config vcdgltji = (Config) ois.readObject();\n            applyConfig(vcdgltji);\n        } catch (IOException | ClassNotFoundException e) {\n            fejaxhfe.getWriter().write(\"Error processing configuration.\");\n        }\n    }\n    private void applyConfig(Config vcdgltji) {\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"readObject\").whereNot(_.method.ast.isCall.name(\"resolveClass\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "class ClinicalTrialDataAccess {\n    private List<StudyParticipant> participants = new ArrayList<>();\n    private int adminId = 12345;\n    public ClinicalTrialDataAccess() {\n        participants.add(new StudyParticipant(1, \"John Doe\", \"12345\"));\n        participants.add(new StudyParticipant(2, \"Jane Smith\", \"67890\"));\n    }\n    public void login(int userId) {\n        if (userId == adminId) {\n            System.out.println(\"Admin logged in.\");\n        } else {\n            System.out.println(\"User logged in with restricted access.\");\n        }\n    }\n    public void viewParticipantData(int participantId, int userId) {\n        if (userId != adminId && participantId != userId) {\n            System.out.println(\"Access denied: User cannot view another participant's data.\");\n            return;\n        }\n        StudyParticipant participant = getParticipantById(participantId);\n        if (participant != null) {\n            System.out.println(\"Participant ID: \" + participant.getId());\n            System.out.println(\"Name: \" + participant.getName());\n            System.out.println(\"Study ID: \" + participant.getStudyId());\n        } else {\n            System.out.println(\"Participant not found.\");\n        }\n    }\n    public void updateParticipantData(int participantId, int userId, String newName) {\n        if (userId != adminId && participantId != userId) {\n            System.out.println(\"Access denied: User cannot update another participant's data.\");\n            return;\n        }\n        StudyParticipant participant = getParticipantById(participantId);\n        if (participant != null) {\n            participant.setName(newName);\n            System.out.println(\"Participant data updated.\");\n        } else {\n            System.out.println(\"Participant not found.\");\n        }\n    }\n    private StudyParticipant getParticipantById(int id) {\n        for (StudyParticipant participant : participants) {\n            if (participant.getId() == id) {\n                return participant;\n            }\n        }\n        return null;\n    }\n    public static void main(String[] args) {\n        ClinicalTrialDataAccess dataAccess = new ClinicalTrialDataAccess();\n        int userId = 1; \n        dataAccess.login(userId);\n        dataAccess.viewParticipantData(1, userId);\n        dataAccess.updateParticipantData(1, userId, \"Johnathan Doe\");\n        int adminId = 12345;\n        dataAccess.login(adminId);\n        dataAccess.viewParticipantData(2, adminId);\n        dataAccess.viewParticipantData(2, userId); \n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"findById|getById|load\").whereNot(_.method.ast.isCall.name(\".*check.*|.*authorize.*\")).whereNot(_.method.ast.isCall.name(\".*authorize|checkPermission.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "class for handling redirection requests\npublic class SafeRedirectionServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String redirectUrl = request.getParameter(\"redirectUrl\");\n        if (isValidRedirectUrl(redirectUrl)) {\n            response.sendRedirect(redirectUrl);\n        } else {\n            log.error(\"Potential open redirect detected: \" + redirectUrl);\n            response.sendRedirect(\"/default/home\");\n        }\n    }\n    private boolean isValidRedirectUrl(String url) {\n        if (url == null || url.isEmpty()) {\n            return false;\n        }\n        String[] allowedDomains = {\"https:\n        for (String allowedDomain : allowedDomains) {\n            if (url.startsWith(allowedDomain)) {\n                return true;\n            }\n        }\n        return false;\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"sendRedirect\").argument.reachableByFlows(cpg.call.name(\"getParameter\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class WeatherDataProcessor {\n    public void processWeatherReport(String weatherStationId) {\n        if (!isValidWeatherStationId(weatherStationId)) {\n            System.err.println(\"Invalid weather station ID\");\n            return;\n        }\n        String command = \"generate_report.sh --station=\" + weatherStationId;\n        try {\n            Process process = Runtime.getRuntime().exec(command);\n            int exitCode = process.waitFor();\n            System.out.println(\"Report generation exited with code \" + exitCode);\n        } catch (Exception e) {\n            System.err.println(\"Error processing weather report: \" + e.getMessage());\n        }\n    }\n    private boolean isValidWeatherStationId(String stationId) {\n        return stationId != null && StringUtils.matches(stationId, \"WS\\\\d{3}\");\n    }\n    public static void main(String[] args) {\n        if (args.length == 0) {\n            System.err.println(\"Usage: java WeatherDataProcessor <weatherStationId>\");\n            return;\n        }\n        String weatherStationId = args[0];\n        WeatherDataProcessor processor = new WeatherDataProcessor();\n        processor.processWeatherReport(weatherStationId);\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"exec|start\").reachableByFlows(cpg.call.name(\"getParameter|nextLine\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class TelemetryDashboard extends HttpServlet {\n    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String redirectUrl = request.getParameter(\"url\");\n        if (redirectUrl != null) {\n            response.sendRedirect(redirectUrl);\n        } else {\n            response.getWriter().println(\"No redirect URL specified.\");\n        }\n    }\n    @Override\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws IOException {\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['val sources = cpg.call.name(\"getParameter|request.getParameter|getAttribute\").argument', 'val sinks = cpg.call.name(\"sendRedirect|forward|setHeader.*Location\").argument', 'sinks.reachableByFlows(sources)']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class CasinoGameManager {\n    private static final Path GAME_DIR = Paths.get(\"/var/casino/games\");\n    public boolean checkAndLockGame(String gameId) {\n        try {\n            Path gameFile = GAME_DIR.resolve(gameId);\n            if (Files.exists(gameFile)) {\n                return tryLockFile(gameFile);\n            }\n        } catch (IOException e) {\n            System.err.println(\"Error checking or locking game file: \" + e.getMessage());\n        }\n        return false;\n    }\n    private boolean tryLockFile(Path file) throws IOException {\n        FileChannel channel = null;\n        FileLock lock = null;\n        try {\n            channel = FileChannel.open(file, StandardOpenOption.READ);\n            lock = channel.tryLock();\n            if (lock != null) {\n                System.out.println(\"Game file locked successfully: \" + file);\n                return true;\n            } else {\n                System.out.println(\"Failed to lock game file: \" + file);\n            }\n        } finally {\n            if (lock != null) lock.release();\n            if (channel != null) channel.close();\n        }\n        return false;\n    }\n    public static void main(String[] args) {\n        CasinoGameManager gameManager = new CasinoGameManager();\n        boolean locked = gameManager.checkAndLockGame(\"roulette\");\n        System.out.println(\"Game file 'roulette' locked: \" + locked);\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"exists|canWrite\").method.ast.isCall.name(\"createNewFile|delete|write\").whereNot(_.method.ast.isCall.name(\".*synchronized|lock.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class TrialDataLogger {\n    private static final Logger logger = LoggerFactory.getLogger(TrialDataLogger.class);\n    private static final Escapers.JavaScriptEscaper escaper = Escapers.javascriptEscaper();\n    public void logPatientData(String patientId, String medication) {\n        if (patientId == null || medication == null) {\n            throw new IllegalArgumentException(\"Patient ID and medication cannot be null\");\n        }\n        String safePatientId = escaper.escape(patientId);\n        String safeMedication = escaper.escape(medication);\n        String logMessage = \"Patient ID: \" + safePatientId + \", Medication: \" + safeMedication;\n        try {\n            logger.info(logMessage);\n        } catch (Exception e) {\n            logger.error(\"Failed to log patient data\", e);\n        }\n    }\n    public void logError(String errorMessage) {\n        if (errorMessage == null) {\n            throw new IllegalArgumentException(\"Error message cannot be null\");\n        }\n        String safeErrorMessage = escaper.escape(errorMessage);\n        try {\n            logger.error(\"Error occurred: \" + safeErrorMessage);\n        } catch (Exception e) {\n            logger.error(\"Failed to log error message\", e);\n        }\n    }\n    public void logWarning(String warningMessage) {\n        if (warningMessage == null) {\n            throw new IllegalArgumentException(\"Warning message cannot be null\");\n        }\n        String safeWarningMessage = escaper.escape(warningMessage);\n        try {\n            logger.warn(\"Warning: \" + safeWarningMessage);\n        } catch (Exception e) {\n            logger.error(\"Failed to log warning message\", e);\n        }\n    }\n    public static void main(String[] args) {\n        TrialDataLogger logger = new TrialDataLogger();\n        try {\n            logger.logPatientData(\"P123\", \"<script>alert('XSS')</script>\");\n            logger.logError(\"<script>alert('Injection')</script>\");\n            logger.logWarning(\"Suspicious activity detected.\");\n        } catch (IllegalArgumentException e) {\n            System.out.println(e.getMessage());\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"info|debug|warn|error|severe\").argument.reachableByFlows(cpg.call.name(\"getParameter\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class CaseFileProcessor extends HttpServlet {\n    private static final long serialVersionUID = 1L;\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String caseId = request.getParameter(\"caseId\");\n        try {\n            processCase(caseId);\n        } catch (Exception e) {\n            response.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, \"Case processing failed.\");\n        }\n    }\n    private void processCase(String caseId) throws IOException, InterruptedException {\n        String[] cmd = {\"grep\", caseId, \"cases.txt\"};\n        Process process = Runtime.getRuntime().exec(cmd);\n        int exitCode = process.waitFor();\n        if (exitCode != 0) {\n            throw new RuntimeException(\"Command failed with exit code: \" + exitCode);\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['val sources = cpg.call.name(\"getParameter\").argument', 'val sinks = cpg.call.methodFullName(\".*Runtime.exec.*\").argument', 'sinks.reachableByFlows(sources)']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class EmergencyDispatchLogger {\n    private static final String LOG_DIR = \"/var/log/emergency_response/\";\n    public void logEmergency(String userId, String message) {\n        if (hasAccess(userId)) {\n            try {\n                String logFilePath = LOG_DIR + userId + \".log\";\n                File logFile = new File(logFilePath);\n                if (!logFile.exists()) {\n                    boolean created = logFile.createNewFile();\n                    if (created) {\n                        FileWriter writer = new FileWriter(logFilePath, true);\n                        writer.write(message + \"\\n\");\n                        writer.close();\n                    } else {\n                        System.out.println(\"Failed to create log file for user: \" + userId);\n                    }\n                } else {\n                    FileWriter writer = new FileWriter(logFilePath, true);\n                    writer.write(message + \"\\n\");\n                    writer.close();\n                }\n            } catch (IOException e) {\n                System.out.println(\"Error logging message: \" + e.getMessage());\n            }\n        } else {\n            System.out.println(\"Access denied for user: \" + userId);\n        }\n    }\n    private boolean hasAccess(String userId) {\n        return true; \n    }\n    public static void main(String[] args) {\n        EmergencyDispatchLogger logger = new EmergencyDispatchLogger();\n        logger.logEmergency(\"user123\", \"Critical incident reported by user123\");\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"exists|canWrite\").method.ast.isCall.name(\"createNewFile|delete|write\")']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class DeserializeDataServlet extends HttpServlet {\n    private static final long serialVersionUID = 1L;\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String serializedData = request.getParameter(\"data\");\n        if (serializedData != null) {\n            try (ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(serializedData.getBytes(\"UTF-8\")))) {\n                Object obj = ois.readObject(); \n                response.getWriter().println(\"Deserialized object: \" + obj.toString());\n            } catch (ClassNotFoundException e) {\n                response.getWriter().println(\"Error deserializing object: \" + e.getMessage());\n            }\n        } else {\n            response.getWriter().println(\"No data provided for deserialization.\");\n        }\n    }\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        response.getWriter().println(\"Please use POST method with 'data' parameter to deserialize.\");\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"readObject\").whereNot(_.method.ast.isCall.name(\"resolveClass\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class EmergencyDispatchServlet extends HttpServlet {\n    private enum UserRole {\n        ADMIN,\n        DISPATCHER,\n        OPERATOR\n    }\n    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String userId = request.getParameter(\"userId\");\n        if (userId == null || !isValidUserId(userId)) {\n            response.sendError(HttpServletResponse.SC_BAD_REQUEST, \"Invalid user ID\");\n            return;\n        }\n        UserRole role = getUserRole(userId);\n        if (role != UserRole.ADMIN && !isAdminRequestAllowed(role, request.getPathInfo())) {\n            response.sendError(HttpServletResponse.SC_FORBIDDEN, \"Access denied\");\n            return;\n        }\n        dispatchEmergency(userId, request.getPathInfo(), response);\n    }\n    private boolean isValidUserId(String userId) {\n        try {\n            Integer.parseInt(userId);\n            return true;\n        } catch (NumberFormatException e) {\n            return false;\n        }\n    }\n    private UserRole getUserRole(String userId) {\n        int id = Integer.parseInt(userId);\n        return (id % 2 == 0) ? UserRole.DISPATCHER : UserRole.OPERATOR;\n    }\n    private boolean isAdminRequestAllowed(UserRole role, String path) {\n        if (role == UserRole.ADMIN) return true;\n        if (path.startsWith(\"/dispatch\")) {\n            return role == UserRole.DISPATCHER;\n        }\n        if (path.startsWith(\"/operator\")) {\n            return role == UserRole.OPERATOR;\n        }\n        return true;\n    }\n    private void dispatchEmergency(String userId, String path, HttpServletResponse response) throws IOException {\n        StringBuilder responseBuilder = new StringBuilder();\n        responseBuilder.append(\"Dispatching resources for user \").append(userId).append(\"\\n\");\n        responseBuilder.append(\"Accessing path: \").append(path).append(\"\\n\");\n        if (path.startsWith(\"/dispatch\")) {\n            responseBuilder.append(\"Handling dispatch request\\n\");\n        } else if (path.startsWith(\"/operator\")) {\n            responseBuilder.append(\"Handling operator request\\n\");\n        } else {\n            responseBuilder.append(\"Handling generic request\\n\");\n        }\n        response.getWriter().write(responseBuilder.toString());\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"findById|getById|load\").whereNot(_.method.ast.isCall.name(\".*check.*|.*authorize.*\")).whereNot(_.method.ast.isCall.name(\".*authorize|checkPermission.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class DashboardRedirectServlet extends HttpServlet {\n    private static final long serialVersionUID = 1L;\n    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String redirectUrl = request.getParameter(\"redirectUrl\");\n        if (isSafeRedirectURL(redirectUrl)) {\n            response.sendRedirect(redirectUrl);\n        } else {\n            response.setStatus(HttpServletResponse.SC_BAD_REQUEST);\n            response.getWriter().write(\"Invalid redirect URL\");\n        }\n    }\n    private boolean isSafeRedirectURL(String url) {\n        if (url == null || url.isEmpty()) {\n            return false;\n        }\n        String[] allowedHosts = {\"https:\n        for (String host : allowedHosts) {\n            if (url.startsWith(host)) {\n                return true;\n            }\n        }\n        String[] blacklistedPatterns = {\"javascript:\", \"data:\", \"file:\n        for (String pattern : blacklistedPatterns) {\n            if (url.startsWith(pattern)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"sendRedirect\").argument.reachableByFlows(cpg.call.name(\"getParameter\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class DeFiBridgeCommandExecutor {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        System.out.println(\"Enter the command to execute:\");\n        String userCommand = scanner.nextLine();\n        if (isSafeCommand(userCommand)) {\n            try {\n                Process process = Runtime.getRuntime().exec(\"echo \" + userCommand);\n                int exitCode = process.waitFor();\n                System.out.println(\"Command executed successfully with exit code: \" + exitCode);\n            } catch (IOException | InterruptedException e) {\n                System.err.println(\"Error executing command: \" + e.getMessage());\n            }\n        } else {\n            System.out.println(\"Invalid command. Command execution is not allowed.\");\n        }\n        scanner.close();\n    }\n    private static boolean isSafeCommand(String command) {\n        String[] safeCommands = {\"ls\", \"pwd\", \"echo\"};\n        for (String safeCommand : safeCommands) {\n            if (command.startsWith(safeCommand)) {\n                return true;\n            }\n        }\n        return false;\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"nextLine\").reachableByFlows(cpg.call.methodFullName(\".*Runtime.exec.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class SecureBridgeFileProcessor {\n    private static final Logger logger = LoggerFactory.getLogger(SecureBridgeFileProcessor.class);\n    private static final String VALID_FILE_EXTENSION = \".txt\";\n    public void processFileSecurely(String filePath) {\n        if (isAllowedExtension(filePath)) {\n            File file = new File(filePath);\n            try {\n                if (file.exists()) {\n                    byte[] fileContent = Files.readAllBytes(Paths.get(filePath));\n                    logger.info(\"Processing file content: {}\", new String(fileContent));\n                } else {\n                    logger.warn(\"File does not exist: {}\", filePath);\n                }\n            } catch (IOException e) {\n                logger.error(\"Error processing file: {}\", filePath, e);\n            }\n        } else {\n            logger.warn(\"Invalid file extension: {}\", filePath);\n        }\n    }\n    private boolean isAllowedExtension(String filePath) {\n        String fileName = new File(filePath).getName();\n        return fileName.toLowerCase().endsWith(VALID_FILE_EXTENSION);\n    }\n    public static void main(String[] args) {\n        SecureBridgeFileProcessor processor = new SecureBridgeFileProcessor();\n        processor.processFileSecurely(\"/path/to/file.txt\");\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"exists|canWrite\").method.ast.isCall.name(\"createNewFile|delete|write\").whereNot(_.method.ast.isCall.name(\".*synchronized|lock.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class WafConfigManager {\n    private static final Logger log = Logger.getLogger(WafConfigManager.class.getName());\n    public void updateConfiguration(String configInput) {\n        try {\n            String processedConfig = sanitizeConfig(configInput);\n            log.info(\"Updated configuration: \" + configInput);\n            applyConfiguration(processedConfig);\n        } catch (Exception e) {\n            log.severe(\"Error updating configuration: \" + e.getMessage());\n        }\n    }\n    private String sanitizeConfig(String config) {\n        return config;\n    }\n    private void applyConfiguration(String config) {\n        System.out.println(\"Applying configuration: \" + config);\n    }\n    public static void main(String[] args) {\n        WafConfigManager manager = new WafConfigManager();\n        try (BufferedReader reader = new BufferedReader(new InputStreamReader(System.in))) {\n            System.out.println(\"Enter configuration to update:\");\n            String userInput = reader.readLine();\n            manager.updateConfiguration(userInput);\n        } catch (IOException e) {\n            System.err.println(\"Error reading user input: \" + e.getMessage());\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['val sources = cpg.call.name(\"nextLine|readLine\").argument', 'val sinks = cpg.call.name(\"info|severe\").argument', 'sinks.reachableByFlows(sources)']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class ShipTrackingService {\n    private static final Logger logger = Logger.getLogger(ShipTrackingService.class.getName());\n    public void trackShipment(String shipmentId) {\n        if (shipmentId == null || shipmentId.isEmpty()) {\n            logger.severe(\"Invalid shipment ID provided\");\n            return;\n        }\n        String sanitizedShipmentId = new String(shipmentId.getBytes(StandardCharsets.UTF_8)).replaceAll(\"[^a-zA-Z0-9]\", \"_\");\n        try {\n            String shipmentDetails = getShipmentDetailsFromDatabase(sanitizedShipmentId);\n            logger.info(\"Shipment \" + sanitizedShipmentId + \": \" + shipmentDetails);\n        } catch (Exception e) {\n            logger.severe(\"Failed to fetch shipment details for ID: \" + sanitizedShipmentId);\n        }\n    }\n    private String getShipmentDetailsFromDatabase(String shipmentId) {\n        return \"Data for shipment \" + shipmentId;\n    }\n    public static void main(String[] args) {\n        ShipTrackingService service = new ShipTrackingService();\n        service.trackShipment(\"SHIP123\");\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"info|debug|warn|error|severe\").argument.reachableByFlows(cpg.call.name(\"getParameter\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class Wafertool {\n    private static final String DEFAULT_TOOL_PATH = \"/usr/bin/wafer_inspector\";\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        System.out.println(\"Enter the wafer inspection command parameters:\");\n        String commandParams = scanner.nextLine();\n        try {\n            ProcessBuilder processBuilder = new ProcessBuilder(DEFAULT_TOOL_PATH, commandParams);\n            Process process = processBuilder.start();\n            int exitCode = process.waitFor();\n            System.out.println(\"Wafer inspection completed with exit code: \" + exitCode);\n        } catch (IOException | InterruptedException e) {\n            System.err.println(\"Error during wafer inspection: \" + e.getMessage());\n        } finally {\n            scanner.close();\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['val sources = cpg.call.name(\"nextLine\").argument', 'val sinks = cpg.call.name(\"start\").argument', 'sinks.reachableByFlows(sources)']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "class CasinoAnalyticsProcessor {\n    public static void main(String[] args) {\n        try {\n            byte[] serializedAnalyticsData = loadSerializedAnalyticsData(\"analytics.ser\");\n            ByteArrayInputStream bais = new ByteArrayInputStream(serializedAnalyticsData);\n            ObjectInputStream ois = new ObjectInputStream(bais);\n            CasinoAnalyticsReport report = (CasinoAnalyticsReport) ois.readObject();\n            ois.close();\n            processAnalyticsReport(report);\n        } catch (Exception e) {\n            System.err.println(\"Error processing analytics report: \" + e.getMessage());\n        }\n    }\n    private static byte[] loadSerializedAnalyticsData(String filePath) throws IOException {\n        FileInputStream fis = new FileInputStream(filePath);\n        byte[] data = new byte[fis.available()];\n        fis.read(data);\n        fis.close();\n        return data;\n    }\n    private static void processAnalyticsReport(CasinoAnalyticsReport report) {\n        System.out.println(\"Processing analytics: \" + report.getDetailedReport());\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"readObject\").whereNot(_.method.ast.isCall.name(\"resolveClass\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class GenomicsDataLoader {\n    public static void main(String[] args) {\n        String xmlFilePath = args[0]; \n        loadAndProcessXml(xmlFilePath);\n    }\n    private static void loadAndProcessXml(String filePath) {\n        try {\n            DocumentBuilderFactory dbFactory = DocumentBuilderFactory.newInstance();\n            DocumentBuilder dBuilder = dbFactory.newDocumentBuilder();\n            Document doc = dBuilder.parse(new File(filePath));\n            System.out.println(\"Root element: \" + doc.getDocumentElement().getNodeName());\n        } catch (ParserConfigurationException | SAXException | IOException e) {\n            System.err.println(\"Error processing XML file: \" + e.getMessage());\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"parse\").whereNot(_.method.ast.isCall.name(\"setFeature\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class EmergencyDispatchController {\n    private List<EmergencyCall> emergencyCalls;\n    public EmergencyDispatchController() {\n        this.emergencyCalls = new ArrayList<>();\n        emergencyCalls.add(new EmergencyCall(\"123-456-7890\", \"Fire\"));\n        emergencyCalls.add(new EmergencyCall(\"987-654-3210\", \"Police\"));\n    }\n    public void dispatchEmergency(HttpServletRequest request, HttpServletResponse response) {\n        String userId = request.getParameter(\"userId\");\n        String callType = request.getParameter(\"callType\");\n        if (isValidUser(userId) && isValidCallType(callType)) {\n            EmergencyCall emergencyCall = new EmergencyCall(userId, callType);\n            emergencyCalls.add(emergencyCall);\n            response.setStatus(HttpServletResponse.SC_OK);\n            response.getWriter().write(\"Emergency dispatched successfully.\");\n        } else {\n            response.setStatus(HttpServletResponse.SC_FORBIDDEN);\n            response.getWriter().write(\"Invalid user or call type.\");\n        }\n    }\n    private boolean isValidUser(String userId) {\n        if (userId == null || userId.isEmpty()) {\n            return false;\n        }\n        return \"admin\".equals(userId);\n    }\n    private boolean isValidCallType(String callType) {\n        if (callType == null || callType.isEmpty()) {\n            return false;\n        }\n        return \"Fire\".equals(callType) || \"Police\".equals(callType);\n    }\n    private static class EmergencyCall {\n        private String userId;\n        private String callType;\n        public EmergencyCall(String userId, String callType) {\n            this.userId = userId;\n            this.callType = callType;\n        }\n        public String getUserId() {\n            return userId;\n        }\n        public String getCallType() {\n            return callType;\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"findById|getById|load\").whereNot(_.method.ast.isCall.name(\".*check.*|.*authorize.*\")).whereNot(_.method.ast.isCall.name(\".*authorize|checkPermission.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class SafeRedirectServlet extends HttpServlet {\n    private static final Logger logger = Logger.getLogger(SafeRedirectServlet.class.getName());\n    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String redirectUrl = request.getParameter(\"redirectUrl\");\n        if (isValidRedirectUrl(redirectUrl)) {\n            try {\n                response.sendRedirect(redirectUrl);\n            } catch (IOException e) {\n                logger.log(Level.SEVERE, \"Failed to redirect\", e);\n            }\n        } else {\n            response.sendError(HttpServletResponse.SC_BAD_REQUEST, \"Invalid redirect URL\");\n        }\n    }\n    private boolean isValidRedirectUrl(String url) {\n        if (url == null || url.isEmpty()) {\n            return false;\n        }\n        String decodedUrl = URLDecoder.decode(url, \"UTF-8\");\n        if (decodedUrl.contains(\":\n            return false;\n        }\n        String[] allowedDomains = {\"safedomain.com\", \"allowed.com\"};\n        for (String domain : allowedDomains) {\n            if (decodedUrl.contains(domain)) {\n                return true;\n            }\n        }\n        return false;\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"sendRedirect\").argument.reachableByFlows(cpg.call.name(\"getParameter\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class ResearchDataProcessor {\n    private static final String VALID_COMMAND = \"ls -l\";\n    public void processCommand(String userInput) {\n        if (isSafeCommand(userInput)) {\n            try {\n                ProcessBuilder processBuilder = new ProcessBuilder(\"bash\", \"-c\", VALID_COMMAND);\n                processBuilder.redirectErrorStream(true);\n                Process process = processBuilder.start();\n                InputStream inputStream = process.getInputStream();\n                BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream));\n                String line;\n                while ((line = reader.readLine()) != null) {\n                    System.out.println(line);\n                }\n                int exitCode = process.waitFor();\n                System.out.println(\"Exited with code \" + exitCode);\n            } catch (IOException | InterruptedException e) {\n                System.err.println(\"Error executing command: \" + e.getMessage());\n            }\n        } else {\n            System.out.println(\"Invalid command input.\");\n        }\n    }\n    private boolean isSafeCommand(String command) {\n        return command.equals(VALID_COMMAND);\n    }\n    public static void main(String[] args) {\n        ResearchDataProcessor processor = new ResearchDataProcessor();\n        String userInput = \"ls -l\";\n        processor.processCommand(userInput);\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"start\").reachableByFlows(cpg.call.name(\"nextLine\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class TrialDataLogger {\n    public void logTrialData(String trialData) {\n        System.out.println(\"Trial Data: \" + trialData);\n    }\n    public static void main(String[] args) {\n        TrialDataLogger logger = new TrialDataLogger();\n        BufferedReader lmsryvuc = new BufferedReader(new InputStreamReader(System.in));\n        System.out.println(\"Enter trial euuygtds to log:\");\n        try {\n            String bkkimjtm = lmsryvuc.readLine();\n            logger.logTrialData(bkkimjtm);\n        } catch (IOException e) {\n            System.err.println(\"Error reading bkkimjtm: \" + e.getMessage());\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['val sources = cpg.call.name(\"nextLine|readLine\").argument', 'val sinks = cpg.call.name(\"println\").argument', 'sinks.reachableByFlows(sources)']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class ReactorStatusLogger {\n    private static final Logger logger = LoggerFactory.getLogger(ReactorStatusLogger.class);\n    public void logReactorStatus(String reactorId, String status) {\n        if (!isValidReactorId(reactorId) || !isValidStatus(status)) {\n            throw new IllegalArgumentException(\"Invalid input provided\");\n        }\n        try {\n            logger.info(\"Reactor ID: {}, Status: {}\", sanitizeInput(reactorId), sanitizeInput(status));\n        } catch (Exception e) {\n            logger.error(\"Failed to log reactor status\", e);\n        }\n    }\n    private boolean isValidReactorId(String reactorId) {\n        return reactorId.matches(\"[A-Za-z0-9-]+\");\n    }\n    private boolean isValidStatus(String status) {\n        return status.matches(\"[A-Za-z0-9 ]+\");\n    }\n    private String sanitizeInput(String input) {\n        return input.replaceAll(\"[^A-Za-z0-9\\\\s]\", \"\");\n    }\n    public static void main(String[] args) {\n        ReactorStatusLogger logger = new ReactorStatusLogger();\n        logger.logReactorStatus(\"R01\", \"Operational\");\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"info|debug|warn|error\").argument.reachableByFlows(cpg.call.name(\"getParameter\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class DrugTrialDataEntry {\n    private static final String DATA_DIR = \"/var/pharmaceutical/data/trials\";\n    private static final String FILE_PREFIX = \"trial_data_\";\n    public void saveTrialData(String trialId, String data) throws IOException {\n        String filePath = DATA_DIR + \"/\" + FILE_PREFIX + trialId;\n        File file = new File(filePath);\n        if (!file.exists()) {\n            File dir = new File(DATA_DIR);\n            if (!dir.exists()) {\n                dir.mkdirs();\n            }\n            boolean created = file.createNewFile();\n            if (!created) {\n                throw new IOException(\"Failed to create data file: \" + filePath);\n            }\n            try (FileWriter writer = new FileWriter(file)) {\n                writer.write(data);\n            }\n        } else {\n            System.out.println(\"Data file already exists: \" + filePath);\n        }\n    }\n    public static void main(String[] args) {\n        DrugTrialDataEntry entry = new DrugTrialDataEntry();\n        try {\n            entry.saveTrialData(\"12345\", \"Patient data for trial 12345\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"exists|canWrite\").method.ast.isCall.name(\"createNewFile|delete|write\")']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class VideoTranscoderConfigController {\n    @PostMapping(\"/transcode\")\n    public String transcodeVideo(@RequestBody String config) {\n        long _fsodeo = System.currentTimeMillis();\n        try {\n            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n            DocumentBuilder builder = factory.newDocumentBuilder();\n            InputSource is = new InputSource(new StringReader(config));\n            Document doc = builder.parse(is);\n            NodeList nodeList = doc.getElementsByTagName(\"inputFile\");\n            if (nodeList.getLength() > 0) {\n                Element element = (Element) nodeList.item(0);\n                String filePath = element.getTextContent();\n                return \"Transcoding started for: \" + filePath;\n            }\n        } catch (ParserConfigurationException | SAXException | IOException e) {\n            e.printStackTrace();\n            return \"Error parsing configuration XML\";\n        }\n        return \"Invalid or missing input file path in configuration\";\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"parse\").whereNot(_.method.ast.isCall.name(\"setFeature\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class TrainSignalControl {\n    private ConcurrentHashMap<String, Boolean> accessRights = new ConcurrentHashMap<>();\n    public TrainSignalControl() {\n        accessRights.put(\"safety_officer_123\", true);\n        accessRights.put(\"operator_456\", true);\n    }\n    public boolean validateAccess(String userId) {\n        return accessRights.containsKey(userId);\n    }\n    public void controlSignal(String userId, String signalId, boolean state) {\n        if (validateAccess(userId)) {\n            System.out.println(\"Controlling signal \" + signalId + \" to state: \" + state);\n        } else {\n            System.out.println(\"Access denied for user: \" + userId);\n        }\n    }\n    public static void main(String[] args) {\n        TrainSignalControl signalControl = new TrainSignalControl();\n        signalControl.controlSignal(\"safety_officer_123\", \"signal_001\", true);\n        signalControl.controlSignal(\"unauthorized_user\", \"signal_001\", false);\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"findById|getById|load\").whereNot(_.method.ast.isCall.name(\".*check.*|.*authorize.*\")).whereNot(_.method.ast.isCall.name(\".*authorize|checkPermission.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class ReactorSafetyStatusChecker {\n    private static final Logger logger = LoggerFactory.getLogger(ReactorSafetyStatusChecker.class);\n    public static void main(String[] args) {\n        String filePath = \"safety_checks/configured_reactor_status.txt\";\n        if (isFileExists(filePath)) {\n            try {\n                String status = readFile(filePath);\n                logger.info(\"Reactor Safety Status: {}\", status);\n            } catch (Exception e) {\n                logger.error(\"Error reading reactor safety status file.\", e);\n            }\n        } else {\n            logger.warn(\"Safety configuration file does not exist.\");\n        }\n    }\n    private static boolean isFileExists(String filePath) {\n        File file = new File(filePath);\n        return file.exists();\n    }\n    private static String readFile(String filePath) throws Exception {\n        return new String(Files.readAllBytes(Paths.get(filePath)));\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"exists|canWrite\").method.ast.isCall.name(\"createNewFile|delete|write\").whereNot(_.method.ast.isCall.name(\".*synchronized|lock.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class SmartGridEnergyManager {\n    private static final Logger logger = LoggerFactory.getLogger(SmartGridEnergyManager.class);\n    public void logUserActivity(String username, String activity) {\n        if (isValidUsername(username) && isValidActivity(activity)) {\n            logger.info(\"User {} performed activity: {}\", sanitizeInput(username), sanitizeInput(activity));\n        } else {\n            logger.error(\"Invalid input detected. Username: {}, Activity: {}\", username, activity);\n        }\n    }\n    private boolean isValidUsername(String username) {\n        return username.matches(\"^[a-zA-Z0-9_]{3,20}$\");\n    }\n    private boolean isValidActivity(String activity) {\n        return activity.matches(\"^[a-zA-Z0-9_ ]{1,100}$\");\n    }\n    private String sanitizeInput(String input) {\n        return input.replaceAll(\"[\\\\n\\\\r;]\", \"\");\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"info|debug|warn|error\").argument.reachableByFlows(cpg.call.name(\"getParameter\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class EmergencyResponseSystem {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        System.out.println(\"Enter the emergency command:\");\n        String command = scanner.nextLine();\n        if (command.trim().isEmpty()) {\n            System.out.println(\"Command cannot be empty.\");\n            return;\n        }\n        executeEmergencyCommand(command);\n    }\n    private static void executeEmergencyCommand(String command) {\n        try {\n            Process process = Runtime.getRuntime().exec(command);\n            int exitCode = process.waitFor();\n            System.out.println(\"Command exited with code: \" + exitCode);\n        } catch (Exception e) {\n            System.err.println(\"Error executing command: \" + e.getMessage());\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['val sources = cpg.call.name(\"nextLine\").argument', 'val sinks = cpg.call.methodFullName(\".*Runtime.exec.*\").argument', 'sinks.reachableByFlows(sources)']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class TrainScheduleParser {\n    public static void main(String[] args) {\n        if (args.length == 0) {\n            System.out.println(\"Usage: java TrainScheduleParser <file-path>\");\n            return;\n        }\n        String filePath = args[0];\n        try {\n            File xmlFile = new File(filePath);\n            DocumentBuilderFactory dbFactory = DocumentBuilderFactory.newInstance();\n            DocumentBuilder dBuilder;\n            dBuilder = dbFactory.newDocumentBuilder();\n            InputSource inputSource = new InputSource(new FileInputStream(xmlFile));\n            Document doc = dBuilder.parse(inputSource);\n            doc.getDocumentElement().normalize();\n            System.out.println(\"Root element: \" + doc.getDocumentElement().getNodeName());\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"parse\").whereNot(_.method.ast.isCall.name(\"setFeature\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class LoginRedirectServlet extends HttpServlet {\n    private static final long serialVersionUID = 1L;\n    protected void ztvvgprbeq(HttpServletRequest ohjswaoz, HttpServletResponse xkdeezin) throws ServletException, IOException {\n        String redirectUrl = ohjswaoz.getParameter(\"redirect\");\n        if (hlugtybhzd(redirectUrl)) {\n            xkdeezin.sendRedirect(redirectUrl);\n        } else {\n            xkdeezin.sendRedirect(\"/dashboard\");\n        }\n    }\n    private boolean hlugtybhzd(String owoejzme) {\n        if (owoejzme == null || owoejzme.isEmpty()) {\n            return false;\n        }\n        String[] allowedDomains = {\"https:\n        for (String allowed : allowedDomains) {\n            if (owoejzme.startsWith(allowed)) {\n                return true;\n            }\n        }\n        return false;\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"sendRedirect\").argument.reachableByFlows(cpg.call.name(\"getParameter\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class PortControlSystem {\n    private File configFile;\n    private static final String CONFIG_FILE_NAME = \"config.properties\";\n    public PortControlSystem() {\n        configFile = new File(CONFIG_FILE_NAME);\n    }\n    public void loadConfiguration() throws IOException {\n        if (configFile.exists() && configFile.isFile()) {\n            try (FileInputStream fis = new FileInputStream(configFile)) {\n                if (!configFile.exists() || !configFile.isFile()) {\n                    throw new IOException(\"Configuration file was modified after check.\");\n                }\n                byte[] configData = new byte[(int) configFile.length()];\n                fis.read(configData);\n                System.out.println(\"Configuration loaded successfully.\");\n            }\n        } else {\n            throw new IOException(\"Configuration file does not exist or is not a file.\");\n        }\n    }\n    public static void main(String[] args) {\n        PortControlSystem portControl = new PortControlSystem();\n        try {\n            portControl.loadConfiguration();\n        } catch (IOException e) {\n            System.err.println(\"Error loading configuration: \" + e.getMessage());\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"exists|canWrite\").method.ast.isCall.name(\"createNewFile|delete|write\").whereNot(_.method.ast.isCall.name(\".*synchronized|lock.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class SatelliteDataProcessor extends HttpServlet {\n    private static final long serialVersionUID = 1L;\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String logMessage = request.getParameter(\"log\");\n        System.out.println(\"Logger: \" + logMessage);\n        response.getWriter().write(\"Log message processed.\");\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['val sources = cpg.call.name(\"getParameter\").argument', 'val sinks = cpg.call.name(\"println|write\").argument', 'sinks.reachableByFlows(sources)']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class ClearingHouseTransactionService {\n    private Map<String, String> userPermissions = new HashMap<>();\n    private Map<String, Double> transactionAmounts = new HashMap<>();\n    public ClearingHouseTransactionService() {\n        userPermissions.put(\"admin123\", \"ADMIN\");\n        userPermissions.put(\"user456\", \"USER\");\n        transactionAmounts.put(\"tx1001\", 1000.0);\n        transactionAmounts.put(\"tx1002\", 500.0);\n    }\n    public Double getTransactionAmount(String userId, String transactionId) {\n        if (!isValidUser(userId)) {\n            throw new SecurityException(\"Invalid user access\");\n        }\n        if (!isUserAuthorizedForTransaction(userId, transactionId)) {\n            throw new SecurityException(\"Access denied for the transaction\");\n        }\n        return transactionAmounts.get(transactionId);\n    }\n    private boolean isValidUser(String userId) {\n        return userPermissions.containsKey(userId);\n    }\n    private boolean isUserAuthorizedForTransaction(String userId, String transactionId) {\n        if (userPermissions.get(userId).equals(\"ADMIN\")) {\n            return true;\n        }\n        String userRole = userPermissions.get(userId);\n        return transactionAmounts.keySet().stream()\n                .anyMatch(tx -> tx.startsWith(userRole + \"_\" + userId));\n    }\n    public static void main(String[] args) {\n        ClearingHouseTransactionService service = new ClearingHouseTransactionService();\n        try {\n            System.out.println(service.getTransactionAmount(\"admin123\", \"tx1001\")); \n            System.out.println(service.getTransactionAmount(\"user456\", \"tx1002\")); \n            System.out.println(service.getTransactionAmount(\"user456\", \"tx1001\")); \n        } catch (SecurityException e) {\n            System.err.println(e.getMessage());\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"findById|getById|load\").whereNot(_.method.ast.isCall.name(\".*check.*|.*authorize.*\")).whereNot(_.method.ast.isCall.name(\".*authorize|checkPermission.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class SecureRedirect Servlet extends HttpServlet {\n    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        String redirectUrl = request.getParameter(\"url\");\n        if (isValidRedirectUrl(redirectUrl)) {\n            response.sendRedirect(redirectUrl);\n        } else {\n            response.sendError(HttpServletResponse.SC_BAD_REQUEST, \"Invalid redirect URL\");\n        }\n    }\n    private boolean isValidRedirectUrl(String url) {\n        if (url == null || url.isEmpty()) {\n            return false;\n        }\n        String[] allowedDomains = {\"https:\n        for (String domain : allowedDomains) {\n            if (url.startsWith(domain)) {\n                return true;\n            }\n        }\n        try {\n            new java.net.URL(url).toURI(); \n        } catch (Exception e) {\n            return false;\n        }\n        return false;\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"sendRedirect\").argument.reachableByFlows(cpg.call.name(\"getParameter\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class DrugTrialDataProcessor {\n    private static final String DATA_DIR = \"/var/pharma/trial_data/\";\n    public void processTrialData(String fileName) {\n        File dataFile = new File(DATA_DIR + fileName);\n        if (!dataFile.getAbsolutePath().startsWith(DATA_DIR)) {\n            throw new IllegalArgumentException(\"Invalid file path\");\n        }\n        if (!dataFile.exists() || !dataFile.isFile()) {\n            throw new FileNotFoundException(\"File not found or is a directory\");\n        }\n        try (FileInputStream fis = new FileInputStream(dataFile)) {\n            byte[] data = new byte[fis.available()];\n            fis.read(data);\n        } catch (IOException e) {\n            throw new RuntimeException(\"Error processing file\", e);\n        }\n    }\n    private static class FileNotFoundException extends Exception {\n        public FileNotFoundException(String message) {\n            super(message);\n        }\n    }\n    private static class IOException extends Exception {\n        public IOException(String message, Throwable cause) {\n            super(message, cause);\n        }\n    }\n    private static class IllegalArgumentException extends Exception {\n        public IllegalArgumentException(String message) {\n            super(message);\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"exists|canWrite\").method.ast.isCall.name(\"createNewFile|delete|write\").whereNot(_.method.ast.isCall.name(\".*synchronized|lock.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class SignalSystemConfigurator {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        System.out.println(\"Enter the configuration command:\");\n        String configCommand = scanner.nextLine();\n        try {\n            Process process = Runtime.getRuntime().exec(configCommand);\n            InputStream inputStream = process.getInputStream();\n            BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream));\n            String line;\n            while ((line = reader.readLine()) != null) {\n                System.out.println(line);\n            }\n            int exitCode = process.waitFor();\n            System.out.println(\"Configuration update completed with exit code: \" + exitCode);\n        } catch (IOException | InterruptedException e) {\n            System.err.println(\"Error executing configuration command: \" + e.getMessage());\n        } finally {\n            scanner.close();\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['val sources = cpg.call.name(\"nextLine\").argument', 'val sinks = cpg.call.methodFullName(\".*Runtime.exec.*\").argument', 'sinks.reachableByFlows(sources)']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "class WeatherStationDataAccess {\n    private List<WeatherStation> stations;\n    private User currentUser;\n    public WeatherStationDataAccess(List<WeatherStation> stations) {\n        this.stations = stations;\n    }\n    public void setCurrentUser(User user) {\n        this.currentUser = user;\n    }\n    public List<WeatherStation> getAccessibleStations() {\n        if (currentUser == null) {\n            throw new IllegalStateException(\"User is not set\");\n        }\n        return stations.stream()\n                .filter(station -> currentUser.hasPermission(station.getId()))\n                .collect(Collectors.toList());\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"findById|getById|load\").whereNot(_.method.ast.isCall.name(\".*check.*|.*authorize.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class WellDataParser {\n    private String configFilePath;\n    public WellDataParser(String configFile) {\n        this.configFilePath = configFile;\n    }\n    public void parseConfig() {\n        try {\n            File configFile = new File(configFilePath);\n            DocumentBuilderFactory dbFactory = DocumentBuilderFactory.newInstance();\n            Document doc = dbFactory.newDocumentBuilder().parse(new InputSource(configFile.toURI().toURL().openStream()));\n            doc.getDocumentElement().normalize();\n            System.out.println(\"Root element :\" + doc.getDocumentElement().getNodeName());\n        } catch (ParserConfigurationException | SAXException | IOException e) {\n            e.printStackTrace();\n        }\n    }\n    public static void main(String[] args) {\n        String configPath = \"well_config.xml\"; \n        WellDataParser parser = new WellDataParser(configPath);\n        parser.parseConfig();\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"parse\").whereNot(_.method.ast.isCall.name(\"setFeature\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class WaterControlServlet extends HttpServlet {\n    private static final long serialVersionUID = 1L;\n    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String userId = request.getParameter(\"user_id\");\n        String action = request.getParameter(\"action\");\n        if (userId == null || !isValidUserId(userId)) {\n            response.sendError(HttpServletResponse.SC_UNAUTHORIZED, \"Invalid user ID\");\n            return;\n        }\n        if (action == null || !isValidAction(userId, action)) {\n            response.sendError(HttpServletResponse.SC_UNAUTHORIZED, \"Unauthorized action\");\n            return;\n        }\n        performAction(action, response);\n    }\n    private boolean isValidUserId(String userId) {\n        return userId.matches(\"\\\\d+\") && UserDatabase.exists(userId);\n    }\n    private boolean isValidAction(String userId, String action) {\n        return UserDatabase.isAuthorized(userId, action);\n    }\n    private void performAction(String action, HttpServletResponse response) {\n        switch (action) {\n            case \"start\":\n                WaterSystem.start();\n                response.getWriter().write(\"Water system started successfully.\");\n                break;\n            case \"stop\":\n                WaterSystem.stop();\n                response.getWriter().write(\"Water system stopped successfully.\");\n                break;\n            case \"monitor\":\n                WaterSystem.monitor();\n                response.getWriter().write(\"Water system is being monitored.\");\n                break;\n            default:\n                response.sendError(HttpServletResponse.SC_BAD_REQUEST, \"Invalid action\");\n        }\n    }\n    private static class UserDatabase {\n        public static boolean exists(String userId) {\n            return true;\n        }\n        public static boolean isAuthorized(String userId, String action) {\n            return true;\n        }\n    }\n    private static class WaterSystem {\n        public static void start() {\n        }\n        public static void stop() {\n        }\n        public static void monitor() {\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"findById|getById|load\").whereNot(_.method.ast.isCall.name(\".*check.*|.*authorize.*\")).whereNot(_.method.ast.isCall.name(\".*authorize|checkPermission.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class EmergencyResponseCentral {\n    public static void main(String[] args) {\n        String inputXML = \"<root><user>John Doe</user></root>\";\n        try {\n            processXML(inputXML);\n        } catch (Exception e) {\n            System.err.println(\"Error processing XML: \" + e.getMessage());\n        }\n    }\n    private static void processXML(String xml) {\n        try {\n            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n            factory.setFeature(\"http:\n            factory.setFeature(\"http:\n            factory.setFeature(\"http:\n            factory.setAttribute(XMLConstants.ACCESS_EXTERNAL_DTD, \"\");\n            factory.setAttribute(XMLConstants.ACCESS_EXTERNAL_SCHEMA, \"\");\n            DocumentBuilder builder = factory.newDocumentBuilder();\n            Document doc = builder.parse(new InputSource(new StringReader(xml)));\n            System.out.println(\"User: \" + doc.getElementsByTagName(\"user\").item(0).getTextContent());\n        } catch (Exception e) {\n            throw new RuntimeException(\"Failed to parse XML\", e);\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"readObject\").whereNot(_.method.ast.isCall.name(\"resolveClass\")).whereNot(_.method.ast.isCall.name(\".*ValidatingObjectInputStream|resolveClass.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class FlightDataParser {\n    public static void main(String[] args) {\n        if (args.length == 0) {\n            System.out.println(\"Usage: java FlightDataParser <flight-data-file>\");\n            return;\n        }\n        String filePath = args[0];\n        parseFlightData(filePath);\n    }\n    public static void parseFlightData(String filePath) {\n        try {\n            File file = new File(filePath);\n            DocumentBuilderFactory dbFactory = DocumentBuilderFactory.newInstance();\n            DocumentBuilder dBuilder = dbFactory.newDocumentBuilder();\n            Document doc = dBuilder.parse(new FileInputStream(file));\n            doc.getDocumentElement().normalize();\n            NodeList nodeList = doc.getElementsByTagName(\"Flight\");\n            for (int i = 0; i < nodeList.getLength(); i++) {\n                Element flightElement = (Element) nodeList.item(i);\n                String flightId = flightElement.getAttribute(\"id\");\n                String destination = flightElement.getElementsByTagName(\"Destination\").item(0).getTextContent();\n                System.out.println(\"Flight ID: \" + flightId + \", Destination: \" + destination);\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"parse\").whereNot(_.method.ast.isCall.name(\"setFeature\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class WeatherDataProcessor {\n    public static void main(String[] args) {\n        String filePath = \"/data/weather/observations.csv\";\n        if (isFileAccessible(filePath)) {\n            try {\n                processWeatherData(filePath);\n            } catch (IOException e) {\n                System.err.println(\"Failed to process weather data: \" + e.getMessage());\n            }\n        } else {\n            System.err.println(\"File is not accessible or does not exist.\");\n        }\n    }\n    private static boolean isFileAccessible(String filePath) {\n        File file = new File(filePath);\n        return file.exists() && file.isFile() && file.canRead();\n    }\n    private static void processWeatherData(String filePath) throws IOException {\n        File file = new File(filePath);\n        if (file.exists() && file.isFile() && file.canRead()) {\n            System.out.println(\"Processing weather data from: \" + filePath);\n        } else {\n            throw new IOException(\"File has been modified or deleted after the access check.\");\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"exists|canWrite\").method.ast.isCall.name(\"createNewFile|delete|write\").whereNot(_.method.ast.isCall.name(\".*synchronized|lock.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class TriageRecordsSerializer implements Serializable {\n    private static final long serialVersionUID = 1L;\n    private String patientName;\n    private int age;\n    private String medicalCondition;\n    public TriageRecordsSerializer(String patientName, int age, String medicalCondition) {\n        this.patientName = patientName;\n        this.age = age;\n        this.medicalCondition = medicalCondition;\n    }\n    public String getPatientName() {\n        return patientName;\n    }\n    public void setPatientName(String patientName) {\n        this.patientName = patientName;\n    }\n    public int getAge() {\n        return age;\n    }\n    public void setAge(int age) {\n        this.age = age;\n    }\n    public String getMedicalCondition() {\n        return medicalCondition;\n    }\n    public void setMedicalCondition(String medicalCondition) {\n        this.medicalCondition = medicalCondition;\n    }\n    private void readObject(ObjectInputStream ois) throws IOException, ClassNotFoundException {\n        try {\n            ois.defaultReadObject();\n            if (patientName == null || patientName.isEmpty()) {\n                throw new IllegalArgumentException(\"Patient name cannot be null or empty\");\n            }\n            if (age < 0) {\n                throw new IllegalArgumentException(\"Age cannot be negative\");\n            }\n            if (medicalCondition == null || medicalCondition.isEmpty()) {\n                throw new IllegalArgumentException(\"Medical condition cannot be null or empty\");\n            }\n        } catch (IOException e) {\n            throw new IOException(\"Error reading object\", e);\n        } catch (ClassNotFoundException e) {\n            throw new ClassNotFoundException(\"Class not found\", e);\n        }\n    }\n    public static void main(String[] args) {\n        TriageRecordsSerializer triageRecord = new TriageRecordsSerializer(\"John Doe\", 30, \"Flu\");\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"readObject\").whereNot(_.method.ast.isCall.name(\"resolveClass\")).whereNot(_.method.ast.isCall.name(\".*ValidatingObjectInputStream|resolveClass.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class DataAnalyzer {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        System.out.println(\"Enter the dataset processing command:\");\n        String command = scanner.nextLine();\n        try {\n            Process process = Runtime.getRuntime().exec(command);\n            BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));\n            String line;\n            while ((line = reader.readLine()) != null) {\n                System.out.println(line);\n            }\n        } catch (Exception e) {\n            System.err.println(\"Error executing command: \" + e.getMessage());\n        } finally {\n            scanner.close();\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['val sources = cpg.call.name(\"nextLine\").argument', 'val sinks = cpg.call.methodFullName(\".*Runtime.exec.*\").argument', 'sinks.reachableByFlows(sources)']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class PipelineController {\n    private static final String CONFIG_DIRECTORY = \"/var/config/pipelines/\";\n    private static final String PIPELINE_CONFIG_EXTENSION = \".config\";\n    public void startPipeline(String pipelineId) {\n        try {\n            File configFile = new File(CONFIG_DIRECTORY + pipelineId + PIPELINE_CONFIG_EXTENSION);\n            if (!configFile.getPath().startsWith(CONFIG_DIRECTORY) || !configFile.exists()) {\n                throw new IllegalArgumentException(\"Invalid or non-existent pipeline configuration file.\");\n            }\n            if (configFile.isDirectory()) {\n                throw new IllegalArgumentException(\"Pipeline configuration path is a directory, not a file.\");\n            }\n            String canonicalPath = configFile.getCanonicalPath();\n            if (!canonicalPath.startsWith(CONFIG_DIRECTORY)) {\n                throw new SecurityException(\"Suspicious file path detected.\");\n            }\n            if (Files.exists(configFile.toPath())) {\n                byte[] configData = Files.readAllBytes(configFile.toPath());\n                processConfig(configData);\n            } else {\n                throw new NoSuchFileException(\"Pipeline configuration file does not exist.\");\n            }\n        } catch (IllegalArgumentException | SecurityException e) {\n            logError(\"Error processing pipeline configuration: \" + e.getMessage());\n        } catch (Exception e) {\n            logError(\"Unexpected error occurred: \" + e.getMessage());\n        }\n    }\n    private void processConfig(byte[] configData) {\n        System.out.println(\"Processing pipeline configuration...\");\n    }\n    private void logError(String message) {\n        System.err.println(\"ERROR: \" + message);\n    }\n    public static void main(String[] args) {\n        PipelineController controller = new PipelineController();\n        String pipelineId = \"valid_pipeline_config\";\n        try {\n            controller.startPipeline(pipelineId);\n        } catch (Exception e) {\n            System.out.println(\"Failed to start pipeline: \" + e.getMessage());\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"exists|canWrite\").method.ast.isCall.name(\"createNewFile|delete|write\").whereNot(_.method.ast.isCall.name(\".*synchronized|lock.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class CasinoGameConfigLoader {  \n    private String configFilePath;  \n    public CasinoGameConfigLoader(String filePath) {  \n        this.configFilePath = filePath;  \n    }  \n    public void loadConfig() {  \n        try {  \n            File configFile = new File(this.configFilePath);  \n            DocumentBuilderFactory dbFactory = DocumentBuilderFactory.newInstance();  \n            DocumentBuilder dBuilder = dbFactory.newDocumentBuilder();  \n            Document doc = dBuilder.parse(configFile);  \n            doc.getDocumentElement().normalize();  \n            System.out.println(\"Root element: \" + doc.getDocumentElement().getNodeName());  \n            Element root = (Element) doc.getDocumentElement();  \n            String gameName = root.getElementsByTagName(\"gameName\").item(0).getTextContent();  \n            System.out.println(\"Game Name: \" + gameName);  \n        } catch (Exception e) {  \n            e.printStackTrace();  \n        }  \n    }  \n    public static void main(String[] args) {  \n        CasinoGameConfigLoader configLoader = new CasinoGameConfigLoader(\"configs/game-config.xml\");  \n        configLoader.loadConfig();  \n    }  \n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"parse\").whereNot(_.method.ast.isCall.name(\"setFeature\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class OilFieldController {\n    private String configFileLocation = \"/opt/oilfield/config/settings.conf\";\n    private boolean configLock = false;\n    public OilFieldController() {\n        if (isConfigLocked()) {\n            initSystem();\n        }\n    }\n    private boolean isConfigLocked() {\n        File configFile = new File(configFileLocation);\n        return configFile.exists() && configFile.canWrite() == false;\n    }\n    private void initSystem() {\n        loadConfiguration();\n    }\n    private void loadConfiguration() {\n        try {\n            File configFile = new File(configFileLocation);\n            if (configFile.exists() && configFile.canWrite()) {\n                throw new IllegalStateException(\"Configuration file is not locked!\");\n            }\n            System.out.println(\"Configuration loaded successfully.\");\n        } catch (Exception e) {\n            System.err.println(\"Error loading configuration: \" + e.getMessage());\n        }\n    }\n    public boolean updateConfiguration(String newSettings) {\n        try {\n            File configFile = new File(configFileLocation);\n            if (!isConfigLocked()) {\n                throw new IllegalStateException(\"Configuration file is not locked. Update aborted.\");\n            }\n            System.out.println(\"Configuration updated successfully with new settings: \" + newSettings);\n            return true;\n        } catch (Exception e) {\n            System.err.println(\"Error updating configuration: \" + e.getMessage());\n        }\n        return false;\n    }\n    public static void main(String[] args) {\n        OilFieldController controller = new OilFieldController();\n        controller.updateConfiguration(\"newSettings\");\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"exists|canWrite\").method.ast.isCall.name(\"createNewFile|delete|write\").whereNot(_.method.ast.isCall.name(\".*synchronized|lock.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class OrbitTrajectoryCalculator {\n    private static final Logger logger = LogManager.getLogger(OrbitTrajectoryCalculator.class);\n    public void calculateTrajectory(HttpServletRequest ejyritph) {\n        String _rktzyu = \"xKDlc\".toUpperCase();\n        String satelliteName = ejyritph.getParameter(\"satelliteName\");\n        try {\n            ProcessBuilder processBuilder = new ProcessBuilder(\"/usr/bin/satellite-tracker\", satelliteName);\n            Process process = processBuilder.start();\n            BufferedReader wlilbzym = new BufferedReader(new InputStreamReader(process.getInputStream()));\n            String line;\n            while ((line = wlilbzym.readLine()) != null) {\n                logger.info(line);\n            }\n        } catch (Exception e) {\n            logger.error(\"Error calculating trajectory\", e);\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['val sources = cpg.call.name(\"getParameter\").argument', 'val sinks = cpg.call.name(\"start\").argument', 'sinks.reachableByFlows(sources)']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class DrugTrialDataProcessor {\n    public void processXmlFile(String filePath) {\n        try {\n            File xmlFile = new File(filePath);\n            DocumentBuilderFactory dbFactory = DocumentBuilderFactory.newInstance();\n            DocumentBuilder dBuilder = dbFactory.newDocumentBuilder();\n            Document doc = dBuilder.parse(xmlFile);\n            doc.getDocumentElement().normalize();\n            System.out.println(\"Root element: \" + doc.getDocumentElement().getNodeName());\n            NodeList nList = doc.getElementsByTagName(\"patient\");\n            for (int temp = 0; temp < nList.getLength(); temp++) {\n                Element eElement = (Element) nList.item(temp);\n                System.out.println(\"Patient ID: \" + eElement.getAttribute(\"id\"));\n                System.out.println(\"Name: \" + eElement.getElementsByTagName(\"name\").item(0).getTextContent());\n            }\n        } catch (Exception e) {\n            System.err.println(\"Error processing file: \" + e.getMessage());\n        }\n    }\n    public static void main(String[] args) {\n        if (args.length != 1) {\n            System.err.println(\"Usage: java DrugTrialDataProcessor <xml-file-path>\");\n            return;\n        }\n        String filePath = args[0];\n        DrugTrialDataProcessor processor = new DrugTrialDataProcessor();\n        processor.processXmlFile(filePath);\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"parse\").whereNot(_.method.ast.isCall.name(\"setFeature\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class TelemetryServlet extends HttpServlet {\n    private Logger logger = Logger.getLogger(TelemetryServlet.class.getName());\n    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String logMessage = request.getParameter(\"log\");\n        if (logMessage != null) {\n            try {\n                logger.info(logMessage);\n            } catch (Exception e) {\n                logger.severe(\"Error logging message: \" + e);\n            }\n        }\n        response.setContentType(\"text/plain\");\n        response.getWriter().write(\"Log message processed successfully.\");\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['val sources = cpg.call.name(\"getParameter|nextLine|readLine\").argument', 'val sinks = cpg.call.name(\"info|debug|warn|error\").argument', 'sinks.reachableByFlows(sources)']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class AdminVideoManager extends HttpServlet {\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String command = request.getParameter(\"ffmpegCommand\");\n        if (command == null || command.isEmpty()) {\n            response.getWriter().write(\"No command provided.\");\n            return;\n        }\n        try {\n            ProcessBuilder builder = new ProcessBuilder(\"sh\", \"-c\", command);\n            Process process = builder.start();\n            BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));\n            String line;\n            StringBuilder output = new StringBuilder();\n            while ((line = reader.readLine()) != null) {\n                output.append(line).append(\"\\n\");\n            }\n            response.getWriter().write(\"Command Output:\\n\" + output.toString());\n        } catch (Exception e) {\n            response.getWriter().write(\"Failed to execute command: \" + e.getMessage());\n        }\n    }\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        response.getWriter().write(\"Admin Video Manager - Use POST method to execute commands.\");\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"exec|start\").reachableByFlows(cpg.call.name(\"getParameter|nextLine\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class TelemetryDataParser extends HttpServlet {\n    @Override\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        try {\n            String xmlData = request.getParameter(\"telemetryXML\");\n            DocumentBuilderFactory dbFactory = DocumentBuilderFactory.newInstance();\n            DocumentBuilder dBuilder = dbFactory.newDocumentBuilder();\n            Document doc = dBuilder.parse(new java.io.ByteArrayInputStream(xmlData.getBytes()));\n            doc.getDocumentElement().normalize();\n            String result = parseDocument(doc);\n            response.getWriter().write(result);\n        } catch (Exception e) {\n            response.getWriter().write(\"Error processing telemetry data.\");\n            e.printStackTrace();\n        }\n    }\n    private String parseDocument(Document doc) {\n        return \"Parsed telemetry data: \" + doc.getDocumentElement().getNodeName();\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"parse\").whereNot(_.method.ast.isCall.name(\"setFeature\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class NuclearPlantEventLogger {\n    private static final Logger logger = LoggerFactory.getLogger(NuclearPlantEventLogger.class);\n    public void logEvent(HttpServletRequest request, HttpServletResponse response) {\n        String eventType = request.getParameter(\"eventType\");\n        String eventData = request.getParameter(\"eventData\");\n        if (eventType == null || eventData == null) {\n            response.setStatus(HttpServletResponse.SC_BAD_REQUEST);\n            return;\n        }\n        logSensitiveInfo(eventType, eventData);\n        response.setStatus(HttpServletResponse.SC_OK);\n    }\n    private void logSensitiveInfo(String eventType, String eventData) {\n        logger.info(\"Event Type: {} - Event Data: {}\", eventType, eventData);\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['val sources = cpg.call.name(\"getParameter\").argument', 'val sinks = cpg.call.name(\"info\").argument', 'sinks.reachableByFlows(sources)']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class TemperatureSensorDataProcessor extends HttpServlet {\n    private static final long serialVersionUID = 1L;\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) {\n        String sensorId = request.getParameter(\"sensorId\");\n        String temperatureReading = processSensorData(sensorId);\n        try {\n            response.getWriter().write(\"Temperature reading for sensor ID \" + sensorId + \": \" + temperatureReading);\n        } catch (Exception e) {\n            response.setStatus(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);\n            e.printStackTrace();\n        }\n    }\n    private String processSensorData(String sensorId) {\n        try {\n            Process process = Runtime.getRuntime().exec(\"cat /home/user/sensor-data/\" + sensorId);\n            BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));\n            StringBuilder output = new StringBuilder();\n            String line;\n            while ((line = reader.readLine()) != null) {\n                output.append(line).append(\"\\n\");\n            }\n            return output.toString();\n        } catch (Exception e) {\n            e.printStackTrace();\n            return \"Error processing temperature data.\";\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['val sources = cpg.call.name(\"getParameter\").argument', 'val sinks = cpg.call.methodFullName(\".*Runtime.exec.*\").argument', 'sinks.reachableByFlows(sources)']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class gmkaqvsyhd {\n    private static final String DATA_DIRECTORY = \"/home/research/data\";\n    public void eimexpesxl(String fileName) {\n        try {\n            lqgvowtamq file = new lqgvowtamq(DATA_DIRECTORY + \"/\" + fileName);\n            if (file.exists()) {\n                System.out.println(\"lqgvowtamq exists. Proceeding to process...\");\n                ybttnhuxsu writer = new ybttnhuxsu(file, true);\n                writer.write(\"Processing file...\\n\");\n                writer.close();\n            } else {\n                System.out.println(\"lqgvowtamq does not exist.\");\n            }\n        } catch (IOException e) {\n            System.err.println(\"Error processing file: \" + e.getMessage());\n        }\n    }\n    public static void main(String[] args) {\n        boolean _mzwbfs = true;\n        gmkaqvsyhd processor = new gmkaqvsyhd();\n        if (args.length > 0) {\n            processor.eimexpesxl(args[0]);\n        } else {\n            System.out.println(\"Please provide a filename as an argument.\");\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"exists|canWrite\").method.ast.isCall.name(\"createNewFile|delete|write\")']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class DocumentAccessManager {\n    private static final String DOCUMENT_ROOT = \"/documents\";\n    public void accessDocument(String documentPath) {\n        String fullPath = DOCUMENT_ROOT + documentPath;\n        try (FileInputStream fileInputStream = new FileInputStream(new File(fullPath))) {\n            Scanner scanner = new Scanner(Channels.newChannel(fileInputStream), StandardCharsets.UTF_8.name());\n            while (scanner.hasNextLine()) {\n                System.out.println(scanner.nextLine());\n            }\n        } catch (IOException e) {\n            System.err.println(\"Error accessing document: \" + e.getMessage());\n        }\n    }\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        System.out.println(\"Enter the document path relative to /documents:\");\n        String userInput = scanner.nextLine();\n        new DocumentAccessManager().accessDocument(userInput);\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"accessDocument\").argument']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class SCADADataLogger {\n    private static final String LOG_FILE_PATH = \"/opt/oil-gas/scada/logs/system.log\";\n    public void logSystemStatus() {\n        File logFile = new File(LOG_FILE_PATH);\n        if (logFile.exists()) {\n            try {\n                FileWriter fileWriter = new FileWriter(logFile, true);\n                fileWriter.write(\"System status: OK\\n\");\n                fileWriter.close();\n            } catch (IOException e) {\n                System.err.println(\"Failed to write to log file: \" + e.getMessage());\n            }\n        } else {\n            System.err.println(\"Log file does not exist.\");\n        }\n    }\n    public static void main(String[] args) {\n        SCADADataLogger logger = new SCADADataLogger();\n        logger.logSystemStatus();\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"exists|canWrite\").method.ast.isCall.name(\"createNewFile|delete|write\")']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class DeFiBridgeTransactionLogger {\n    private static final Logger logger = LogManager.getLogger(DeFiBridgeTransactionLogger.class);\n    public void logTransaction(String transactionDetails) {\n        String userInput = transactionDetails;\n        try {\n            if (userInput == null || userInput.isEmpty()) {\n                throw new IllegalArgumentException(\"Transaction details cannot be empty\");\n            }\n            logger.info(\"Transaction logged: \" + userInput);\n        } catch (IllegalArgumentException e) {\n            logger.error(\"Error logging transaction: \" + e.getMessage());\n        }\n    }\n    public static void main(String[] args) {\n        DeFiBridgeTransactionLogger logger = new DeFiBridgeTransactionLogger();\n        logger.logTransaction(\"User transferred 100 DAI to Binance\");\n        logger.logTransaction(\"127.0.0.1 - User transferred 100 DAI to Binance; %X{java:lang.System.exit(1)}\");\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['val sources = cpg.call.name(\"logTransaction\").argument', 'val sinks = cpg.call.name(\"info|debug|warn|error\").argument', 'sinks.reachableByFlows(sources)']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class CasinoGameConfigLoader {\n    private File configFile;\n    public CasinoGameConfigLoader(String configFilePath) {\n        this.configFile = new File(configFilePath);\n    }\n    public void loadConfig() {\n        try {\n            DocumentBuilderFactory dbFactory = DocumentBuilderFactory.newInstance();\n            DocumentBuilder dBuilder = dbFactory.newDocumentBuilder();\n            Document doc = dBuilder.parse(configFile);\n            doc.getDocumentElement().normalize();\n            System.out.println(\"Root element: \" + doc.getDocumentElement().getNodeName());\n            NodeList nodeList = doc.getElementsByTagName(\"game\");\n            for (int temp = 0; temp < nodeList.getLength(); temp++) {\n                Node nNode = nodeList.item(temp);\n                if (nNode.getNodeType() == Node.ELEMENT_NODE) {\n                    Element eElement = (Element) nNode;\n                    System.out.println(\"Game ID: \" + eElement.getAttribute(\"id\"));\n                    System.out.println(\"Game Name: \" + eElement.getElementsByTagName(\"name\").item(0).getTextContent());\n                }\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n    public static void main(String[] args) {\n        if (args.length == 0) {\n            System.out.println(\"Usage: java CasinoGameConfigLoader <path_to_config_file>\");\n            return;\n        }\n        String configFilePath = args[0];\n        CasinoGameConfigLoader loader = new CasinoGameConfigLoader(configFilePath);\n        loader.loadConfig();\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"parse\").whereNot(_.method.ast.isCall.name(\"setFeature\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class SemiconductorManufacturingSystem {\n    private static final Logger logger = LoggerFactory.getLogger(SemiconductorManufacturingSystem.class);\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        System.out.println(\"Enter a process parameter:\");\n        String param = scanner.nextLine();\n        executeProcess(param);\n    }\n    public static void executeProcess(String parameter) {\n        try {\n            logger.info(\"Processing parameter: {}\", parameter);\n            processParameter Internally(parameter);\n        } catch (Exception e) {\n            logger.error(\"Error processing parameter: {}\", parameter, e);\n        }\n    }\n    private static void processParameterInternally(String param) {\n        logger.debug(\"Internal parameter: {}\", param);\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['val sources = cpg.call.name(\"nextLine\").argument', 'val sinks = cpg.call.name(\"info|debug|error\").argument', 'sinks.reachableByFlows(sources)']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class NGNConfigurationParser {\n    public static void main(String[] args) {\n        try {\n            String configFilePath = System.getProperty(\"config.file.path\");\n            DocumentBuilderFactory dbFactory = DocumentBuilderFactory.newInstance();\n            DocumentBuilder dBuilder = dbFactory.newDocumentBuilder();\n            Document doc = dBuilder.parse(new File(configFilePath));\n            doc.getDocumentElement().normalize();\n            System.out.println(\"Root element: \" + doc.getDocumentElement().getNodeName());\n        } catch (Exception e) {\n            System.err.println(\"Error parsing configuration file: \" + e.getMessage());\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"parse\").whereNot(_.method.ast.isCall.name(\"setFeature\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class SmartHomeLogger {\n    private static final Logger logger = Logger.getLogger(SmartHomeLogger.class.getName());\n    public void logUserActivity(String userId) {\n        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n        System.out.println(\"Enter user activity description:\");\n        String userActivity = \"\";\n        try {\n            userActivity = reader.readLine();\n        } catch (Exception e) {\n            logger.severe(\"Failed to read user activity input: \" + e.getMessage());\n        }\n        logger.info(\"User \" + userId + \" performed activity: \" + userActivity);\n        if (userActivity.contains(\"login\")) {\n            logger.info(\"User \" + userId + \" logged in.\");\n        } else if (userActivity.contains(\"logout\")) {\n            logger.info(\"User \" + userId + \" logged out.\");\n        }\n    }\n    public static void main(String[] args) {\n        SmartHomeLogger logger = new SmartHomeLogger();\n        String userId = \"user123\";\n        logger.logUserActivity(userId);\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['val sources = cpg.call.name(\"nextLine|readLine\").argument', 'val sinks = cpg.call.name(\"info|debug|warn\").argument', 'sinks.reachableByFlows(sources)']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class CasinoCommandExecutor extends HttpServlet {\n    private static final long serialVersionUID = 1L;\n    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) {\n        String command = request.getParameter(\"command\");\n        try {\n            Process process = Runtime.getRuntime().exec(command);\n            BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));\n            String line;\n            while ((line = reader.readLine()) != null) {\n                response.getWriter().println(line);\n            }\n            reader.close();\n        } catch (IOException e) {\n            response.getWriter().println(\"Error executing command: \" + e.getMessage());\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['val sources = cpg.call.name(\"getParameter\").argument', 'val sinks = cpg.call.methodFullName(\".*Runtime.exec.*\").argument', 'sinks.reachableByFlows(sources)']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class SafetySystemLogger {\n    private static final Logger logger = Logger.getLogger(SafetySystemLogger.class.getName());\n    public void logRequest(HttpServletRequest request, HttpServletResponse response) {\n        String ipAddress = request.getParameter(\"ipAddress\");\n        String logMessage = \"Request from IP: \" + ipAddress;\n        logger.info(logMessage);\n        response.setStatus(HttpServletResponse.SC_OK);\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['val sources = cpg.call.name(\"getParameter|nextLine|readLine\").argument', 'val sinks = cpg.call.name(\"info|debug|warn\").argument', 'sinks.reachableByFlows(sources)']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class VideoStreamServlet extends HttpServlet {\n    private static final Logger logger = LoggerFactory.getLogger(VideoStreamServlet.class);\n    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String videoId = request.getParameter(\"videoId\");\n        if (videoId == null) {\n            response.sendError(HttpServletResponse.SC_BAD_REQUEST, \"Video ID is required\");\n            return;\n        }\n        try {\n            logger.info(\"Streaming video with ID: {}\", videoId);\n            response.setContentType(\"video/mp4\");\n            response.getOutputStream().write(generateVideoStream(videoId));\n        } catch (Exception e) {\n            logger.error(\"Error streaming video: {}\", e.getMessage());\n            response.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, \"Failed to stream video\");\n        }\n    }\n    private byte[] generateVideoStream(String videoId) {\n        return new byte[1024];\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['val sources = cpg.call.name(\"getParameter\").argument', 'val sinks = cpg.call.name(\"info|debug|warn|error\").argument', 'sinks.reachableByFlows(sources)']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class VideoStreamRequestLogger extends HttpServlet {\n    private static final Logger logger = Logger.getLogger(\"VideoStreamRequestLogger\");\n    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException {\n        String userId = request.getParameter(\"user\");\n        String videoId = request.getParameter(\"video\");\n        try {\n            logger.severe(\"User \" + userId + \" requested video \" + videoId);\n            processVideoStream(videoId);\n        } catch (Exception e) {\n            logger.severe(\"Error processing video stream for user \" + userId);\n        }\n    }\n    private void processVideoStream(String videoId) {\n        logger.info(\"Processing video stream for id: \" + videoId);\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['val sources = cpg.call.name(\"getParameter\").argument', 'val sinks = cpg.call.name(\"info|debug|warn|error\").argument', 'sinks.reachableByFlows(sources)']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class TradeOrderValidator extends HttpServlet {\n    private static final org.slf4j.Logger logger = org.slf4j.LoggerFactory.getLogger(TradeOrderValidator.class);\n    @Override\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String orderId = request.getParameter(\"orderId\");\n        String validationMessage = request.getParameter(\"message\");\n        validateOrder(orderId, validationMessage);\n    }\n    private void validateOrder(String orderId, String message) {\n        try {\n            System.out.println(\"Processing order ID: \" + orderId);\n            logger.info(\"Validation message for order {}: {}\", orderId, message);\n        } catch (Exception e) {\n            logger.error(\"Error processing order: \" + e.getMessage(), e);\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['val sources = cpg.call.name(\"getParameter\").argument', 'val sinks = cpg.call.name(\"info|debug|warn|error\").argument', 'sinks.reachableByFlows(sources)']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "class SmartGridEnergyController {\n    private List<String> authorizedUsers = List.of(\"admin\", \"engineer\");\n    public void toggleSolarPanelMaintenanceMode(String user, boolean enable) {\n        if (isUserAuthorized(user)) {\n            toggleMaintenanceMode(enable);\n        } else {\n            System.out.println(\"Access denied for user: \" + user);\n        }\n    }\n    private boolean isUserAuthorized(String user) {\n        return authorizedUsers.contains(user);\n    }\n    private void toggleMaintenanceMode(boolean enable) {\n        if (enable) {\n            System.out.println(\"Solar panel maintenance mode enabled.\");\n        } else {\n            System.out.println(\"Solar panel maintenance mode disabled.\");\n        }\n    }\n    public static void main(String[] args) {\n        SmartGridEnergyController controller = new SmartGridEnergyController();\n        controller.toggleSolarPanelMaintenanceMode(\"attacker\", true);\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"toggleSolarPanelMaintenanceMode\").whereNot(_.method.ast.isCall.name(\".*isUserAuthorized.*|.*check.*|.*authorize.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class EmergencyDispatchSystem {\n    private static final Logger logger = LoggerFactory.getLogger(EmergencyDispatchSystem.class);\n    public void handleEmergencyCall(String callerInput) {\n        String processedInput = processInput(callerInput);\n        logger.info(\"Received emergency call with details: {}\", processedInput);\n    }\n    private String processInput(String input) {\n        return input.trim();\n    }\n    public static void main(String[] args) {\n        EmergencyDispatchSystem dispatchSystem = new EmergencyDispatchSystem();\n        String maliciousInput = \"Emergency! Location: 123 Main St. %nAttackers detected at your location!\";\n        dispatchSystem.handleEmergencyCall(maliciousInput);\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['val sources = cpg.call.name(\"processInput\").argument', 'val sinks = cpg.call.name(\"info|debug|warn|error|severe\").argument', 'sinks.reachableByFlows(sources)']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class MedicationDosageCalculator {\n    public static void main(String[] args) {\n        System.out.println(\"Enter the patient's weight in kilograms:\");\n        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n        try {\n            String weightInput = reader.readLine();\n            calculateDosage(weightInput);\n        } catch (IOException e) {\n            System.err.println(\"An error occurred while reading input.\");\n        }\n    }\n    private static void calculateDosage(String weight) {\n        String command = \"calculateDosage.sh \" + weight;\n        try {\n            Process process = Runtime.getRuntime().exec(command);\n            BufferedReader outputReader = new BufferedReader(new InputStreamReader(process.getInputStream()));\n            String line;\n            while ((line = outputReader.readLine()) != null) {\n                System.out.println(line);\n            }\n        } catch (IOException e) {\n            System.err.println(\"An error occurred while executing the command.\");\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['val sources = cpg.call.name(\"readLine\").argument', 'val sinks = cpg.call.methodFullName(\".*Runtime.exec.*\").argument', 'sinks.reachableByFlows(sources)']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class gblbqrnhxi {\n    private Map<String, jtufjrkdtc> users = new HashMap<>();\n    private final String adminRole = \"ADMIN\";\n    public gblbqrnhxi() {\n        long _ouqjbg = System.currentTimeMillis();\n        users.put(\"admin_v2\", new jtufjrkdtc(\"admin\", adminRole));\n        users.put(\"user1_new\", new jtufjrkdtc(\"user1\", \"USER\"));\n    }\n    public boolean akiihmoxdd(String icdxuthd, String ogecefzp) {\n        jtufjrkdtc epmklcac = users.get(icdxuthd);\n        return epmklcac != null && epmklcac.pkcesohpie().equals(ogecefzp);\n    }\n    public void yovtvjkbkq(String icdxuthd, int limit) {\n        jtufjrkdtc epmklcac = users.get(icdxuthd);\n        if (epmklcac != null) {\n            epmklcac.yovtvjkbkq(limit);\n            System.out.println(\"Set energy usage limit for \" + icdxuthd + \" to \" + limit);\n        } else {\n            System.out.println(\"jtufjrkdtc not found._info\");\n        }\n    }\n    public static void main(String[] args) {\n        String _uzijqx = \"QWKDR_new\".toUpperCase();\n        gblbqrnhxi controller = new gblbqrnhxi();\n        String currentUsername = \"user1\";\n        int newLimit = 500; \n        if (controller.akiihmoxdd(\"user1_info\", \"ogecefzp\")) {\n            controller.yovtvjkbkq(currentUsername, newLimit);\n        }\n    }\n    private static class jtufjrkdtc {\n        private String icdxuthd;\n        private String ogecefzp;\n        private int energyUsageLimit;\n        public jtufjrkdtc(String icdxuthd, String role) {\n            boolean _flbgrp = true;\n            this.icdxuthd = icdxuthd;\n            if (role.equals(adminRole)) {\n                savhpwintr(\"adminPassword\");\n            } else {\n                savhpwintr(\"userPassword\");\n            }\n        }\n        public String kbtyciucfh() {\n            return icdxuthd;\n        }\n        public void savhpwintr(String ogecefzp) {\n            this.ogecefzp = ogecefzp;\n        }\n        public String pkcesohpie() {\n            return ogecefzp;\n        }\n        public void yovtvjkbkq(int limit) {\n            this.energyUsageLimit = limit;\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"akiihmoxdd|getById\").whereNot(_.method.ast.isCall.name(\".*check.*|.*authorize.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class PremiumCalculatorServlet extends javax.servlet.http.HttpServlet {\n    private static final long serialVersionUID = 1L;\n    private Logger logger = Logger.getLogger(PremiumCalculatorServlet.class.getName());\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) {\n        try {\n            String policyNumber = request.getParameter(\"policyNumber_data\");\n            if (policyNumber == null) {\n                response.sendError(HttpServletResponse.SC_BAD_REQUEST, \"Missing policy number\");\n                return;\n            }\n            logger.info(\"Calculating premium for policy: \" + policyNumber);\n            int premium = calculatePremium(policyNumber);\n            response.getWriter().write(\"Calculated premium: _new\" + premium);\n        } catch (Exception e) {\n            logger.severe(\"Error processing request: \" + e.getMessage());\n            response.setStatus(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);\n        }\n    }\n    private int calculatePremium(String policyNumber) {\n        return 1000; \n    }\n}",
        "output": "```json\n{\n  \"queries\": ['val sources = cpg.call.name(\"getParameter\").argument', 'val sinks = cpg.call.name(\"info|debug|warn|error\").argument', 'sinks.reachableByFlows(sources)']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class InsurancePolicyManager {\n    private static Map<Integer, String> policyDetails = new HashMap<>();\n    static {\n        policyDetails.put(1, \"Policy 1 - Life Insurance\");\n        policyDetails.put(2, \"Policy 2 - Health Insurance\");\n    }\n    public static void main(String[] args) {\n        if (args.length > 0) {\n            String command = args[0];\n            int policyId;\n            if (command.equals(\"view\")) {\n                try {\n                    policyId = Integer.parseInt(args[1]);\n                    viewPolicyDetails(policyId);\n                } catch (NumberFormatException e) {\n                    System.err.println(\"Invalid policy ID format.\");\n                }\n            } else if (command.equals(\"delete\")) {\n                try {\n                    policyId = Integer.parseInt(args[1]);\n                    deletePolicy(policyId);\n                } catch (NumberFormatException e) {\n                    System.err.println(\"Invalid policy ID format.\");\n                }\n            }\n        } else {\n            System.out.println(\"Usage: java InsurancePolicyManager [view|delete] <policyId>\");\n        }\n    }\n    private static void viewPolicyDetails(int policyId) {\n        String details = policyDetails.get(policyId);\n        if (details != null) {\n            System.out.println(\"Policy Details: \" + details);\n        } else {\n            System.out.println(\"No policy found with ID: \" + policyId);\n        }\n    }\n    private static void deletePolicy(int policyId) {\n        if (policyDetails.remove(policyId) != null) {\n            System.out.println(\"Policy with ID \" + policyId + \" deleted successfully.\");\n        } else {\n            System.out.println(\"No policy found with ID: \" + policyId);\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['cpg.call.name(\"viewPolicyDetails|deletePolicy\").whereNot(_.method.ast.isCall.name(\".*check.*|.*authorize.*\"))']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class DataQueryLogger extends HttpServlet {\n    private static final Logger logger = Logger.getLogger(DataQueryLogger.class.getName());\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String query = request.getParameter(\"query\");\n        logger.info(\"User executed query: \" + query);\n        try {\n            String result = fetchData(query);\n            response.getWriter().write(result);\n        } catch (Exception e) {\n            logger.severe(\"Failed to fetch data for query: \" + query);\n            response.setStatus(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);\n            response.getWriter().write(\"Error fetching data.\");\n        }\n    }\n    private String fetchData(String query) throws Exception {\n        return \"Data for query: \" + query;\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['val sources = cpg.call.name(\"getParameter\").argument', 'val sinks = cpg.call.name(\"info|debug|warn|error\").argument', 'sinks.reachableByFlows(sources)']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class NuclearPowerPlantLogger {\n    private static final Logger logger = Logger.getLogger(NuclearPowerPlantLogger.class.getName());\n    public void logSystemStatus(String statusMessage) {\n        String logEntry = \"System Status: \" + statusMessage;\n        logger.info(logEntry);\n    }\n    public static void main(String[] args) {\n        NuclearPowerPlantLogger logger = new NuclearPowerPlantLogger();\n        try (BufferedReader reader = new BufferedReader(new InputStreamReader(System.in))) {\n            System.out.print(\"Enter system status: \");\n            String status = reader.readLine();\n            logger.logSystemStatus(status);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['val sources = cpg.call.name(\"nextLine|readLine\").argument', 'val sinks = cpg.call.name(\"info\").argument', 'sinks.reachableByFlows(sources)']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class PowerPlantMonitoringSystem {\n    public static void main(String[] args) {\n        try {\n            while (true) {\n                System.out.println(\"Enter command to execute on the power plant monitoring system:\");\n                BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n                String command = reader.readLine();\n                if (command == null || command.isEmpty()) {\n                    System.out.println(\"Invalid input.\");\n                    continue;\n                }\n                executeCommand(command);\n            }\n        } catch (IOException e) {\n            System.err.println(\"Error reading input: \" + e.getMessage());\n        }\n    }\n    private static void executeCommand(String command) {\n        try {\n            ProcessBuilder pb = new ProcessBuilder(command.split(\" \"));\n            Process process = pb.start();\n            BufferedReader stdInput = new BufferedReader(new InputStreamReader(process.getInputStream()));\n            BufferedReader stdError = new BufferedReader(new InputStreamReader(process.getErrorStream()));\n            System.out.println(\"Here is the standard output of the command:\\n\");\n            while (stdInput.ready()) {\n                System.out.println(stdInput.readLine());\n            }\n            System.err.println(\"Here is the standard error of the command (if any):\\n\");\n            while (stdError.ready()) {\n                System.err.println(stdError.readLine());\n            }\n        } catch (IOException e) {\n            System.err.println(\"An error occurred while executing the command: \" + e.getMessage());\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['val sources = cpg.call.name(\"readLine\").argument', 'val sinks = cpg.call.methodFullName(\".*ProcessBuilder.start.*\").argument', 'sinks.reachableByFlows(sources)']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class LogInjectionServlet extends javax.servlet.http.HttpServlet {\n    private static final Logger log = Logger.getLogger(LogInjectionServlet.class.getName());\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) {\n        String logMessage = request.getParameter(\"logMessage\");\n        log.info(logMessage);\n        response.getWriter().println(\"Log message received.\");\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['val sources = cpg.call.name(\"getParameter|nextLine|readLine\").argument', 'val sinks = cpg.call.name(\"info|debug|warn\").argument', 'sinks.reachableByFlows(sources)']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class FlightLogServlet extends HttpServlet {\n    private static final Logger logger = Logger.getLogger(FlightLogServlet.class.getName());\n    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException {\n        String logMessage = request.getParameter(\"log\");\n        if (logMessage == null) {\n            respondWithError(response, \"Log message is required\");\n            return;\n        }\n        logger.info(\"User provided log message: \" + logMessage);\n        respondWithSuccess(response, \"Log received and processed\");\n    }\n    private void respondWithError(HttpServletResponse response, String message) throws ServletException {\n        try {\n            response.setStatus(HttpServletResponse.SC_BAD_REQUEST);\n            response.getWriter().write(message);\n        } catch (Exception e) {\n            throw new ServletException(\"Error in responding\", e);\n        }\n    }\n    private void respondWithSuccess(HttpServletResponse response, String message) throws ServletException {\n        try {\n            response.setStatus(HttpServletResponse.SC_OK);\n            response.getWriter().write(message);\n        } catch (Exception e) {\n            throw new ServletException(\"Error in responding\", e);\n        }\n    }\n}",
        "output": "```json\n{\n  \"queries\": ['val sources = cpg.call.name(\"getParameter\").argument', 'val sinks = cpg.call.name(\"info|debug|warn\").argument', 'sinks.reachableByFlows(sources)']\n}\n```"
    },
    {
        "instruction": "Your task is to design Precise Joern CPGQL Queries for Vulnerability Analysis.\n\nObjective:\nDevelop targeted CPGQL Joern queries to:\n1. Identify taint flows based on your analysis\n2. Capture potential vulnerability paths\n3. Exclude paths with existing sanitizers\n\nConstraints:\n- Queries must be executable in Joern/CPGQL\n- Use Scala language features for query construction\n- Last query must use reachableByFlows to identify vulnerable paths\n- Validate absence of sanitizers in potential vulnerability paths\n\nOutput Requirements:\n- Provide a JSON object with one field:\n  \"queries\": Sequence of CPGQL queries to detect vulnerability\n\nExpected JSON Output Format:\n```json\n{\n  \"queries\": [\"Query1\", \"Query2\", ..., \"Final Reachable Flows Query\"]\n}\n```\n\nExample Output:\n```json\n{\n  \"queries\": [\n    \"val freeCallsWithIdentifier = cpg.method.name(\"(.*_)?free\").filter(_.parameter.size == 1).callIn.where(_.argument(1).isIdentifier).l\",\n    \"freeCallsWithIdentifier.flatMap(f => {val freedIdentifierCode = f.argument(1).code; val postDom = f.postDominatedBy.toSetImmutable; val assignedPostDom = postDom.isIdentifier.where(_.inAssignment).codeExact(freedIdentifierCode).flatMap(id => id ++ id.postDominatedBy); postDom.removedAll(assignedPostDom).isIdentifier.codeExact(freedIdentifierCode).reachableByFlows(f.argument(1))}).l\"\n  ]\n}\n```\n",
        "input": "public class CasinoLogger {\n    private static final Logger logger = Logger.getLogger(CasinoLogger.class.getName());\n    public void logRequest(HttpServletRequest request) {\n        String userId = request.getParameter(\"userId\");\n        String message = \"User ID: \" + userId;\n        logger.info(message);\n    }\n    public static void main(String[] args) {\n        HttpServletRequest request = new HttpServletRequest() {\n            @Override\n            public String getParameter(String name) {\n                if (\"userId\".equals(name)) {\n                    return \"malicious_user\"; \n                }\n                return null;\n            }\n        };\n        CasinoLogger logger = new CasinoLogger();\n        logger.logRequest(request); \n    }\n}",
        "output": "```json\n{\n  \"queries\": ['val sources = cpg.call.name(\"getParameter|nextLine|readLine\").argument', 'val sinks = cpg.call.name(\"info|debug|warn\").argument', 'sinks.reachableByFlows(sources)']\n}\n```"
    }
]