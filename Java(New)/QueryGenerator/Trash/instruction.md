

Prompt Note for Antigravity Script Generation
Role: You are a Senior Python Backend Engineer and DevOps Architect.
Objective: Write a robust, asynchronous Python script to automate a Synthetic Data Generation Pipeline for cybersecurity vulnerability detection.
Tech Stack Requirements:
Language: Python 3.10+
Concurrency: asyncio (Strict requirement for managing parallel workers).
Container Orchestration: docker (Python Docker SDK).
AI Integration: google-generativeai (Gemini Pro 1.5).
Joern Interface: cpgqls-client (or websockets if raw implementation is needed) to communicate with Joern servers.
Data Handling: aiofiles for non-blocking file writing (JSONL format).

System Architecture & Workflow
1. The Infrastructure (Worker Pool)
The script must initialize 7 Docker Containers running the Joern Server (joern --server).
Port Mapping: Map internal container port 8080 to host ports 9001 through 9015.
Maintain a Worker class that manages the state of one container (Host, Port, Container ID, and Busy/Available status).
2. The Data Input
Read a source file input_data.json containing an array of code snippets.
Input Format:
JSON
{
    "language": "JavaScript",
    "code": "...",
    "description": "SQL injection...",
    "complexity": "Low"
}




3. The Processing Logic (Per Code Snippet)
Use a Producer-Consumer pattern where the queue feeds code snippets to available Workers. For each snippet, perform the following Workflow:
Step A: Parallel Execution (Crucial)
Use asyncio.gather to perform these two tasks simultaneously to save time:
Task 1 (Joern): Connect to the assigned worker's WebSocket. Send the code to the Joern server to generate the CPG (Code Property Graph).
Task 2 (Gemini LLM): Send the code + description to Gemini Pro. Use a "Chain of Thought" system prompt to ask for a specific Joern Query script that detects the vulnerability.
Step B: Validation Loop (The Retry Logic)
Attempt 1: Execute the query generated by Gemini on the same Joern worker (which now holds the CPG).
Condition:
If Valid (Returns result): Success. Proceed to Save.
If Invalid (Syntax error or empty): Capture the error message.
Attempt 2 (Retry): Send the Original Code, Failed Query, and Error Message back to Gemini. Ask it to fix the query. Run the new query.
Attempt 3 (Final Retry): Repeat the fix process one last time.
Failure: If it fails on the 3rd try, DROP the code snippet. Do not save it. Log the failure.
Step C: Cleanup & State Management
Success Action: Append the result to valid_dataset.jsonl.
Reset: Regardless of success or failure, send the command to the Joern server to clear the workspace/reset the CPG so it is ready for the next file. Do not kill the container, just reset the session.
Release: Mark the worker as "Available" for the next item in the queue.
4. The Output Data
Format (JSONL):
JSON
{"input": "original code snippet...", "output": "valid joern query..."}





Specific Implementation Details for the AI
Gemini System Prompt:
Embed this system instruction in the API call:
"You are an expert in Static Application Security Testing (SAST) using Joern. Your goal is to write a Scala-based CPG query to detect the vulnerability described.
Analyze the code flow.
Write a query that finds the flow from source to sink.
OUTPUT ONLY THE RAW QUERY CODE. No markdown formatting, no explanations."
Error Handling:
Handle Docker connection errors gracefully.
Implement a simple rate limiter (sleep) if Gemini returns a 429 (Too Many Requests).
Deliverables:
Write the complete main.py script.
Include a helper function to spin up the Docker containers at the start and tear them down at the end.
Include placeholder variables for GEMINI_API_KEY.


