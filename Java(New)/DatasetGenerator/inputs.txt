1. { 	struct nlist *p; 	Elf_Off symoff = 0, symstroff = 0; 	Elf_Word symsize = 0, symstrsize = 0; 	Elf_Sword cc, i; 	int nent = -1; 	int errsave; 	Elf_Sym sbuf[1024]; 	Elf_Sym *s; 	Elf_Ehdr ehdr; 	char *strtab = NULL; 	Elf_Shdr *shdr = NULL; 	Elf_Word shdr_size; 	struct stat st;  	/* Make sure obj is OK */ 	if (lseek(fd, (off_t)0, SEEK_SET) == -1 || 	    read(fd, &ehdr, sizeof(Elf_Ehdr)) != sizeof(Elf_Ehdr) || 	    !__elf_is_okay__(&ehdr) || 	    fstat(fd, &st) < 0) 		return (-1);  	if (ehdr.e_shnum == 0 || 	    ehdr.e_shentsize != sizeof(Elf_Shdr)) { 		errno = ERANGE; 		return (-1); 	}  	/* calculate section header table size */ 	shdr_size = ehdr.e_shentsize * ehdr.e_shnum;  	/* Make sure it's not too big to mmap */ 	if (shdr_size > SIZE_T_MAX || shdr_size > st.st_size) { 		errno = EFBIG; 		return (-1); 	}  	shdr = malloc((size_t)shdr_size); 	if (shdr == NULL) 		return (-1);  	/* Load section header table. */ 	if (pread(fd, shdr, (size_t)shdr_size, (off_t)ehdr.e_shoff) != (ssize_t)shdr_size) 		goto done;  	/* 	 * Find the symbol table entry and it's corresponding 	 * string table entry.	Version 1.1 of the ABI states 	 * that there is only one symbol table but that this 	 * could change in the future. 	 */ 	for (i = 0; i < ehdr.e_shnum; i++) { 		if (shdr[i].sh_type == SHT_SYMTAB) { 			if (shdr[i].sh_link >= ehdr.e_shnum) 				goto done;  			symoff = shdr[i].sh_offset; 			symsize = shdr[i].sh_size; 			symstroff = shdr[shdr[i].sh_link].sh_offset; 			symstrsize = shdr[shdr[i].sh_link].sh_size; 			break; 		} 	}  	/* Check for files too large to mmap. */ 	if (symstrsize > SIZE_T_MAX || symstrsize > st.st_size) { 		errno = EFBIG; 		goto done; 	} 	/* 	 * Load string table into our address space.  This gives us 	 * an easy way to randomly access all the strings, without 	 * making the memory allocation permanent as with malloc/free 	 * (i.e., munmap will return it to the system). 	 */ 	strtab = malloc((size_t)symstrsize); 	if (strtab == NULL) 		goto done;  	if (pread(fd, strtab, (size_t)symstrsize, (off_t)symstroff) != (ssize_t)symstrsize) 		goto done;  	/* 	 * clean out any left-over information for all valid entries. 	 * Type and value defined to be 0 if not found; historical 	 * versions cleared other and desc as well.  Also figure out 	 * the largest string length so don't read any more of the 	 * string table than we have to. 	 * 	 * XXX clearing anything other than n_type and n_value violates 	 * the semantics given in the man page. 	 */ 	nent = 0; 	for (p = list; !ISLAST(p); ++p) { 		p->n_type = 0; 		p->n_other = 0; 		p->n_desc = 0; 		p->n_value = 0; 		++nent; 	}  	/* Don't process any further if object is stripped. */ 	if (symoff == 0) 		goto done; 		 	if (lseek(fd, (off_t) symoff, SEEK_SET) == -1) { 		nent = -1; 		goto done; 	}  	while (symsize > 0 && nent > 0) { 		cc = MIN(symsize, sizeof(sbuf)); 		if (read(fd, sbuf, cc) != cc) 			break; 		symsize -= cc; 		for (s = sbuf; cc > 0 && nent > 0; ++s, cc -= sizeof(*s)) { 			char *name; 			Elf_Word size; 			struct nlist *p;  			name = strtab + s->st_name; 			if (name[0] == '\0') 				continue; 			size = symstrsize - s->st_name;  			for (p = list; !ISLAST(p); p++) { 				if ((p->n_un.n_name[0] == '_' && 				     strncmp(name, p->n_un.n_name+1, size) == 0) || 				    strncmp(name, p->n_un.n_name, size) == 0) { 					elf_sym_to_nlist(p, s, shdr, 					    ehdr.e_shnum); 					if (--nent <= 0) 						break; 				} 			} 		} 	}   done: 	errsave = errno; 	free(strtab); 	free(shdr); 	errno = errsave; 	return (nent); }
2. {     uint8_t state[CONTEXT_SIZE];     int i, j, context_count = -1; //-1 to avoid warning     RangeCoder *const c = &f->slice_context[0]->c;       memset(state, 128, sizeof(state));        if (f->version < 2) {         int chroma_planes, chroma_h_shift, chroma_v_shift, transparency, colorspace, bits_per_raw_sample;          unsigned v= get_symbol(c, state, 0);          if (v >= 2) {              av_log(f->avctx, AV_LOG_ERROR, "invalid version %d in ver01 header\n", v);             return AVERROR_INVALIDDATA;         }         f->version = v;         f->ac      = f->avctx->coder_type = get_symbol(c, state, 0);         if (f->ac > 1) {             for (i = 1; i < 256; i++)                  f->state_transition[i] = get_symbol(c, state, 1) + c->one_state[i];          }           colorspace     = get_symbol(c, state, 0); //YUV cs type         bits_per_raw_sample = f->version > 0 ? get_symbol(c, state, 0) : f->avctx->bits_per_raw_sample;          chroma_planes  = get_rac(c, state);          chroma_h_shift = get_symbol(c, state, 0);          chroma_v_shift = get_symbol(c, state, 0);          transparency   = get_rac(c, state);            if (f->plane_count) {             if (   colorspace    != f->colorspace                 || bits_per_raw_sample != f->avctx->bits_per_raw_sample                 || chroma_planes != f->chroma_planes                  || chroma_h_shift!= f->chroma_h_shift                  || chroma_v_shift!= f->chroma_v_shift                  || transparency  != f->transparency) {                 av_log(f->avctx, AV_LOG_ERROR, "Invalid change of global parameters\n");                 return AVERROR_INVALIDDATA;              }          }           f->colorspace     = colorspace;         f->avctx->bits_per_raw_sample = bits_per_raw_sample;          f->chroma_planes  = chroma_planes;          f->chroma_h_shift = chroma_h_shift;          f->chroma_v_shift = chroma_v_shift;         f->transparency   = transparency;          f->plane_count    = 2 + f->transparency;     }      if (f->colorspace == 0) {         if (!f->transparency && !f->chroma_planes) {             if (f->avctx->bits_per_raw_sample <= 8)                 f->avctx->pix_fmt = AV_PIX_FMT_GRAY8;             else                 f->avctx->pix_fmt = AV_PIX_FMT_GRAY16;         } else if (f->avctx->bits_per_raw_sample<=8 && !f->transparency) {             switch(16 * f->chroma_h_shift + f->chroma_v_shift) {             case 0x00: f->avctx->pix_fmt = AV_PIX_FMT_YUV444P; break;             case 0x01: f->avctx->pix_fmt = AV_PIX_FMT_YUV440P; break;             case 0x10: f->avctx->pix_fmt = AV_PIX_FMT_YUV422P; break;             case 0x11: f->avctx->pix_fmt = AV_PIX_FMT_YUV420P; break;             case 0x20: f->avctx->pix_fmt = AV_PIX_FMT_YUV411P; break;             case 0x22: f->avctx->pix_fmt = AV_PIX_FMT_YUV410P; break;             default:                 av_log(f->avctx, AV_LOG_ERROR, "format not supported\n");                 return AVERROR(ENOSYS);             }         } else if (f->avctx->bits_per_raw_sample <= 8 && f->transparency) {             switch(16*f->chroma_h_shift + f->chroma_v_shift) {             case 0x00: f->avctx->pix_fmt = AV_PIX_FMT_YUVA444P; break;             case 0x10: f->avctx->pix_fmt = AV_PIX_FMT_YUVA422P; break;             case 0x11: f->avctx->pix_fmt = AV_PIX_FMT_YUVA420P; break;             default:                 av_log(f->avctx, AV_LOG_ERROR, "format not supported\n");                 return AVERROR(ENOSYS);             }         } else if (f->avctx->bits_per_raw_sample == 9) {             f->packed_at_lsb = 1;             switch(16 * f->chroma_h_shift + f->chroma_v_shift) {             case 0x00: f->avctx->pix_fmt = AV_PIX_FMT_YUV444P9; break;             case 0x10: f->avctx->pix_fmt = AV_PIX_FMT_YUV422P9; break;             case 0x11: f->avctx->pix_fmt = AV_PIX_FMT_YUV420P9; break;             default:                 av_log(f->avctx, AV_LOG_ERROR, "format not supported\n");                 return AVERROR(ENOSYS);             }         } else if (f->avctx->bits_per_raw_sample == 10) {             f->packed_at_lsb = 1;             switch(16 * f->chroma_h_shift + f->chroma_v_shift) {             case 0x00: f->avctx->pix_fmt = AV_PIX_FMT_YUV444P10; break;             case 0x10: f->avctx->pix_fmt = AV_PIX_FMT_YUV422P10; break;             case 0x11: f->avctx->pix_fmt = AV_PIX_FMT_YUV420P10; break;             default:                 av_log(f->avctx, AV_LOG_ERROR, "format not supported\n");                 return AVERROR(ENOSYS);             }         } else {             switch(16 * f->chroma_h_shift + f->chroma_v_shift) {             case 0x00: f->avctx->pix_fmt = AV_PIX_FMT_YUV444P16; break;             case 0x10: f->avctx->pix_fmt = AV_PIX_FMT_YUV422P16; break;             case 0x11: f->avctx->pix_fmt = AV_PIX_FMT_YUV420P16; break;             default:                 av_log(f->avctx, AV_LOG_ERROR, "format not supported\n");                 return AVERROR(ENOSYS);             }         }     } else if (f->colorspace == 1) {         if (f->chroma_h_shift || f->chroma_v_shift) {             av_log(f->avctx, AV_LOG_ERROR,                    "chroma subsampling not supported in this colorspace\n");             return AVERROR(ENOSYS);         }         if (     f->avctx->bits_per_raw_sample ==  9)             f->avctx->pix_fmt = AV_PIX_FMT_GBRP9;         else if (f->avctx->bits_per_raw_sample == 10)             f->avctx->pix_fmt = AV_PIX_FMT_GBRP10;         else if (f->avctx->bits_per_raw_sample == 12)             f->avctx->pix_fmt = AV_PIX_FMT_GBRP12;         else if (f->avctx->bits_per_raw_sample == 14)             f->avctx->pix_fmt = AV_PIX_FMT_GBRP14;         else         if (f->transparency) f->avctx->pix_fmt = AV_PIX_FMT_RGB32;         else                 f->avctx->pix_fmt = AV_PIX_FMT_0RGB32;     } else {         av_log(f->avctx, AV_LOG_ERROR, "colorspace not supported\n");         return AVERROR(ENOSYS);     }      av_dlog(f->avctx, "%d %d %d\n",             f->chroma_h_shift, f->chroma_v_shift, f->avctx->pix_fmt);     if (f->version < 2) {         context_count = read_quant_tables(c, f->quant_table);         if (context_count < 0) {             av_log(f->avctx, AV_LOG_ERROR, "read_quant_table error\n");             return AVERROR_INVALIDDATA;         }     } else if (f->version < 3) {         f->slice_count = get_symbol(c, state, 0);     } else {         const uint8_t *p = c->bytestream_end;         for (f->slice_count = 0;              f->slice_count < MAX_SLICES && 3 < p - c->bytestream_start;              f->slice_count++) {             int trailer = 3 + 5*!!f->ec;             int size = AV_RB24(p-trailer);             if (size + trailer > p - c->bytestream_start)                 break;             p -= size + trailer;         }     }     if (f->slice_count > (unsigned)MAX_SLICES || f->slice_count <= 0) {         av_log(f->avctx, AV_LOG_ERROR, "slice count %d is invalid\n", f->slice_count);         return AVERROR_INVALIDDATA;     }      for (j = 0; j < f->slice_count; j++) {         FFV1Context *fs = f->slice_context[j];         fs->ac            = f->ac;         fs->packed_at_lsb = f->packed_at_lsb;          fs->slice_damaged = 0;          if (f->version == 2) {             fs->slice_x      =  get_symbol(c, state, 0)      * f->width ;             fs->slice_y      =  get_symbol(c, state, 0)      * f->height;             fs->slice_width  = (get_symbol(c, state, 0) + 1) * f->width  + fs->slice_x;             fs->slice_height = (get_symbol(c, state, 0) + 1) * f->height + fs->slice_y;              fs->slice_x     /= f->num_h_slices;             fs->slice_y     /= f->num_v_slices;             fs->slice_width  = fs->slice_width  / f->num_h_slices - fs->slice_x;             fs->slice_height = fs->slice_height / f->num_v_slices - fs->slice_y;             if ((unsigned)fs->slice_width  > f->width ||                 (unsigned)fs->slice_height > f->height)                 return AVERROR_INVALIDDATA;             if (   (unsigned)fs->slice_x + (uint64_t)fs->slice_width  > f->width                 || (unsigned)fs->slice_y + (uint64_t)fs->slice_height > f->height)                 return AVERROR_INVALIDDATA;         }          for (i = 0; i < f->plane_count; i++) {             PlaneContext *const p = &fs->plane[i];              if (f->version == 2) {                 int idx = get_symbol(c, state, 0);                 if (idx > (unsigned)f->quant_table_count) {                     av_log(f->avctx, AV_LOG_ERROR,                            "quant_table_index out of range\n");                     return AVERROR_INVALIDDATA;                 }                 p->quant_table_index = idx;                 memcpy(p->quant_table, f->quant_tables[idx],                        sizeof(p->quant_table));                 context_count = f->context_count[idx];             } else {                 memcpy(p->quant_table, f->quant_table, sizeof(p->quant_table));             }              if (f->version <= 2) {                 av_assert0(context_count >= 0);                 if (p->context_count < context_count) {                     av_freep(&p->state);                     av_freep(&p->vlc_state);                 }                 p->context_count = context_count;             }         }     }     return 0; }
3. #include <stdio.h> #include <stdlib.h> #include <string.h>  #define MAX_LINE_LENGTH 1024 #define MAX_FILE_SIZE (1024 * 1024)  typedef struct {     char *filename;     FILE *file;     long filesize;     char *buffer; } FileContext;  FileContext *FileOpen(const char *filename) {     FileContext *context = (FileContext *) malloc(sizeof(FileContext));     if (context == NULL) {         printf("Error: failed to allocate memory for file context.\n");         exit(EXIT_FAILURE);     }      context->filename = strdup(filename);     context->file = fopen(filename, "r");     if (context->file == NULL) {         printf("Error: failed to open file '%s'.\n", filename);         free(context->filename);         free(context);         exit(EXIT_FAILURE);     }      fseek(context->file, 0, SEEK_END);     context->filesize = ftell(context->file);     rewind(context->file);      context->buffer = (char *) malloc(MAX_LINE_LENGTH);     if (context->buffer == NULL) {         printf("Error: failed to allocate memory for file buffer.\n");         fclose(context->file);         free(context->filename);         free(context);         exit(EXIT_FAILURE);     }      return context; }  void FileClose(FileContext *context) {     fclose(context->file);     free(context->filename);     free(context->buffer);     free(context); }  int FileReadLine(FileContext *context, char **line) {     char *buffer = context->buffer;     long bytes_read = 0;     int line_length = 0;      while (bytes_read < MAX_LINE_LENGTH && (context->filesize - ftell(context->file)) > 0) {         int c = fgetc(context->file);         if (c == EOF) {             break;         }          if (c == '\n') {             *line = strndup(buffer, line_length);             return 1;         }          buffer[line_length++] = c;         bytes_read++;     }      *line = strndup(buffer, line_length);     return 0; }  int main() {     FileContext *context = FileOpen("example.txt");     if (context == NULL) {         return 1;     }      char *line = NULL;     while (FileReadLine(context, &line) == 1) {         printf("%s", line);         free(line);         line = NULL;     }      FileClose(context);     return 0; }
4. #include <stdio.h> #include <stdlib.h> #include <string.h>  // Define the structure of a book struct Book {     char *title;     char *author;     int num_pages;     char *content; };  // Create a new book struct Book *create_book(char *title, char *author, int num_pages, char *content) {     struct Book *book = malloc(sizeof(struct Book));     book->title = strdup(title);     book->author = strdup(author);     book->num_pages = num_pages;     book->content = strdup(content);     return book; }  // Free the memory allocated for a book void free_book(struct Book *book) {     free(book->title);     free(book->author);     free(book->content);     free(book); }  // Print the information about a book void print_book(struct Book *book) {     printf("Title: %s\n", book->title);     printf("Author: %s\n", book->author);     printf("Number of pages: %d\n", book->num_pages);     printf("Content:\n%s\n", book->content); }  // Read a book from a file struct Book *read_book(char *filename) {     FILE *fp = fopen(filename, "r");     if (fp == NULL) {         fprintf(stderr, "Error opening file: %s\n", filename);         return NULL;     }      char *title = NULL;     size_t title_len = 0;     getline(&title, &title_len, fp);      char *author = NULL;     size_t author_len = 0;     getline(&author, &author_len, fp);      int num_pages;     fscanf(fp, "%d\n", &num_pages);      char *content = NULL;     size_t content_len = 0;     while (!feof(fp)) {         char *line = NULL;         size_t line_len = 0;         getline(&line, &line_len, fp);         if (line_len > 0) {             content = realloc(content, content_len + line_len);             memcpy(content + content_len, line, line_len);             content_len += line_len;         }     }      fclose(fp);      return create_book(title, author, num_pages, content); }  // Write a book to a file void write_book(struct Book *book, char *filename) {     FILE *fp = fopen(filename, "w");     if (fp == NULL) {         fprintf(stderr, "Error opening file: %s\n", filename);         return;     }      fprintf(fp, "%s\n", book->title);     fprintf(fp, "%s\n", book->author);     fprintf(fp, "%d\n", book->num_pages);     fprintf(fp, "%s", book->content);      fclose(fp); }  // Create a new ebook reader struct EbookReader {     struct Book *book;     int current_page; };  // Create a new ebook reader struct EbookReader *create_ebook_reader(struct Book *book) {     struct EbookReader *reader = malloc(sizeof(struct EbookReader));     reader->book = book;     reader->current_page = 1;     return reader; }  // Free the memory allocated for an ebook reader void free_ebook_reader(struct EbookReader *reader) {     free_book(reader->book);     free(reader); }  // Turn to a specific page in the book void turn_to_page(struct EbookReader *reader, int page_number) {     if (page_number < 1 || page_number > reader->book->num_pages) {         fprintf(stderr, "Error: Page number out of range\n");         return;     }      reader->current_page = page_number; }  // Read the current page of the book char *read_current_page(struct EbookReader *reader) {     int start = (reader->current_page - 1) * 80;     int end = start + 80;     if (end > strlen(reader->book->content)) {         end = strlen(reader->book->content);     }     return strndup(reader->book->content + start, end - start); }  // Main function int main(int argc, char *argv[]) {     if (argc < 2) {         fprintf(stderr, "Usage: %s <ebook file>\n", argv[0]);         return EXIT_FAILURE;     }      struct Book *book = read_book(argv[1]);     if (book == NULL) {         fprintf(stderr, "Error reading book: %s\n", argv[1]);         return EXIT_FAILURE;     }      struct EbookReader *reader = create_ebook_reader(book);      // Print the first page of the book     char *page = read_current_page(reader);     printf("%s\n", page);     free(page);      // Turn to the next page     turn_to_page(reader, 2);      // Print the second page of the book     page = read_current_page(reader);     printf("%s\n", page);     free(page);      // Free the memory allocated for the book and the ebook reader     free_ebook_reader(reader);     free_book(book);      return EXIT_SUCCESS; }
